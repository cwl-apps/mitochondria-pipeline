{
  "class": "Workflow",
  "cwlVersion": "v1.2",
  "label": "mitochondria-pipeline",
  "$namespaces": {
    "sbg": "https://sevenbridges.com"
  },
  "inputs": [
    {
      "id": "ref_fasta",
      "sbg:fileTypes": "FASTA",
      "type": "File?",
      "secondaryFiles": [
        {
          "pattern": ".fai",
          "required": true
        },
        {
          "pattern": "^.dict",
          "required": true
        }
      ],
      "sbg:x": 0,
      "sbg:y": 284.34375
    },
    {
      "id": "cram",
      "type": "File?",
      "secondaryFiles": [
        {
          "pattern": ".crai",
          "required": true
        }
      ],
      "sbg:x": 0,
      "sbg:y": 391.515625
    },
    {
      "id": "reference_index_tar",
      "sbg:fileTypes": "TAR",
      "type": "File",
      "label": "Non shifted Reference Index TAR",
      "doc": "Reference fasta file with its BWA index files packed in a TAR archive.",
      "sbg:x": 0,
      "sbg:y": 177.171875
    },
    {
      "id": "shifted_reference_index_tar",
      "sbg:fileTypes": "TAR",
      "type": "File",
      "label": "Shifted Reference Index TAR",
      "doc": "Reference fasta file with its BWA index files packed in a TAR archive.",
      "sbg:x": 0,
      "sbg:y": 70
    },
    {
      "id": "in_reference_and_index",
      "sbg:fileTypes": "FASTA, FA",
      "type": "File",
      "label": "Shifted Reference FASTA and index",
      "doc": "Reference FASTA or FA sequence file and associated index and dict.",
      "secondaryFiles": [
        {
          "pattern": ".fai",
          "required": true
        },
        {
          "pattern": "^.dict",
          "required": true
        }
      ],
      "sbg:x": 992.677978515625,
      "sbg:y": 163.171875
    },
    {
      "id": "in_reference_and_index_1",
      "sbg:fileTypes": "FASTA, FA",
      "type": "File",
      "label": "Non ShiftedReference FASTA and index",
      "doc": "Reference FASTA or FA sequence file and associated index and dict.",
      "secondaryFiles": [
        {
          "pattern": ".fai",
          "required": true
        },
        {
          "pattern": "^.dict",
          "required": true
        }
      ],
      "sbg:x": 992.677978515625,
      "sbg:y": 56
    }
  ],
  "outputs": [
    {
      "id": "theoretical_sensitivity_out_file",
      "outputSource": [
        "picard_collectwgsmetricswithnonzerocoverage_2_21_6_cwl1_2/theoretical_sensitivity_out_file",
        "picard_collectwgsmetricswithnonzerocoverage_2_21_6_cwl1_2/wgs_metrics",
        "picard_collectwgsmetricswithnonzerocoverage_2_21_6_cwl1_2/output_chart"
      ],
      "type": "File?",
      "label": "Theoretical sensitivity output file",
      "doc": "Theoretical sensitivity output file.",
      "sbg:x": 1551.78955078125,
      "sbg:y": -9.155171394348145
    },
    {
      "id": "out_variants",
      "outputSource": [
        "gatk_mutect2_shifted_mt/out_variants",
        "gatk_mutect2_shifted_mt/out_stats",
        "gatk_mutect2_shifted_mt/out_alignments",
        "gatk_mutect2_shifted_mt/f1r2_counts"
      ],
      "type": "File?",
      "label": "Output variants",
      "doc": "Output variants in VCF or VCF.GZ format.",
      "sbg:x": 1556.78955078125,
      "sbg:y": 281.84869384765625
    },
    {
      "id": "out_variants_1",
      "outputSource": [
        "gatk_mutect2_non_shifted_mt/out_variants",
        "gatk_mutect2_non_shifted_mt/out_stats",
        "gatk_mutect2_non_shifted_mt/out_alignments",
        "gatk_mutect2_non_shifted_mt/f1r2_counts"
      ],
      "type": "File?",
      "label": "Output variants",
      "doc": "Output variants in VCF or VCF.GZ format.",
      "sbg:x": 1535.40625,
      "sbg:y": 417.4424133300781
    },
    {
      "id": "wgs_metrics",
      "outputSource": [
        "picard_collectwgsmetricswithnonzerocoverage_2_21_6_cwl1_1/wgs_metrics",
        "picard_collectwgsmetricswithnonzerocoverage_2_21_6_cwl1_1/theoretical_sensitivity_out_file",
        "picard_collectwgsmetricswithnonzerocoverage_2_21_6_cwl1_1/output_chart"
      ],
      "type": "File?",
      "label": "WGS metrics",
      "doc": "Output metrics file.",
      "sbg:x": 1559.19970703125,
      "sbg:y": 117.27950286865234
    }
  ],
  "steps": [
    {
      "id": "subset_bam_to_chrom_m",
      "in": [
        {
          "id": "cram",
          "source": "cram"
        },
        {
          "id": "contig_name",
          "default": "chrM"
        },
        {
          "id": "ref_fasta",
          "source": "ref_fasta"
        }
      ],
      "out": [
        {
          "id": "chrM_bam"
        }
      ],
      "run": {
        "class": "CommandLineTool",
        "cwlVersion": "v1.2",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "id": "dave/build-mitochondria-pipeline/subset-bam-to-chrom-m/5",
        "baseCommand": [
          "gatk",
          "PrintReads",
          "--read-filter",
          "MateOnSameContigOrNoMappedMateReadFilter",
          "--read-filter",
          "MateUnmappedAndUnmappedReadFilter"
        ],
        "inputs": [
          {
            "id": "cram",
            "type": "File?",
            "inputBinding": {
              "prefix": "-I",
              "shellQuote": false,
              "position": 0
            },
            "secondaryFiles": [
              {
                "pattern": ".crai",
                "required": true
              }
            ]
          },
          {
            "id": "contig_name",
            "type": "string?",
            "inputBinding": {
              "prefix": "-L",
              "shellQuote": false,
              "position": 0
            }
          },
          {
            "id": "ref_fasta",
            "type": "File?",
            "inputBinding": {
              "prefix": "-R",
              "shellQuote": false,
              "position": 0
            },
            "sbg:fileTypes": "FASTA",
            "secondaryFiles": [
              {
                "pattern": ".fai",
                "required": true
              },
              {
                "pattern": "^.dict",
                "required": true
              }
            ]
          }
        ],
        "outputs": [
          {
            "id": "chrM_bam",
            "type": "File?",
            "outputBinding": {
              "glob": "*.bam"
            },
            "secondaryFiles": [
              {
                "pattern": "*.bam.bai",
                "required": false
              }
            ]
          }
        ],
        "label": "subset-bam-to-chrom-m",
        "arguments": [
          {
            "prefix": "--read-index",
            "shellQuote": false,
            "position": 0,
            "valueFrom": "$(inputs.cram.path + \".crai\")"
          },
          {
            "prefix": "-O",
            "shellQuote": false,
            "position": 0,
            "valueFrom": "$(inputs.cram.nameroot + \"_chrM.bam\")"
          }
        ],
        "requirements": [
          {
            "class": "ShellCommandRequirement"
          },
          {
            "class": "DockerRequirement",
            "dockerPull": "us.gcr.io/broad-gatk/gatk:4.1.7.0"
          },
          {
            "class": "InitialWorkDirRequirement",
            "listing": [
              {
                "entryname": "original.wdl",
                "entry": "task SubsetBamToChrM {\n  input {\n    File input_bam\n    File input_bai\n    String contig_name\n    String basename = basename(basename(input_bam, \".cram\"), \".bam\")\n    String? requester_pays_project\n    File? ref_fasta\n    File? ref_fasta_index\n    File? ref_dict\n\n    File? gatk_override\n    String? gatk_docker_override\n\n    # runtime\n    Int? preemptible_tries\n  }\n  Float ref_size = if defined(ref_fasta) then size(ref_fasta, \"GB\") + size(ref_fasta_index, \"GB\") + size(ref_dict, \"GB\") else 0\n  Int disk_size = ceil(size(input_bam, \"GB\") + ref_size) + 20\n\n  meta {\n    description: \"Subsets a whole genome bam to just Mitochondria reads\"\n  }\n  parameter_meta {\n    ref_fasta: \"Reference is only required for cram input. If it is provided ref_fasta_index and ref_dict are also required.\"\n    input_bam: {\n      localization_optional: true\n    }\n    input_bai: {\n      localization_optional: true\n    }\n  }\n  command <<<\n    set -e\n    export GATK_LOCAL_JAR=~{default=\"/root/gatk.jar\" gatk_override}\n\n    gatk PrintReads \\\n      ~{\"-R \" + ref_fasta} \\\n      -L ~{contig_name} \\\n      --read-filter MateOnSameContigOrNoMappedMateReadFilter \\\n      --read-filter MateUnmappedAndUnmappedReadFilter \\\n      ~{\"--gcs-project-for-requester-pays \" + requester_pays_project} \\\n      -I ~{input_bam} \\\n      --read-index ~{input_bai} \\\n      -O ~{basename}.bam\n  >>>\n  runtime {\n    memory: \"3 GB\"\n    disks: \"local-disk \" + disk_size + \" HDD\"\n    docker: select_first([gatk_docker_override, \"us.gcr.io/broad-gatk/gatk:4.1.7.0\"])\n    preemptible: select_first([preemptible_tries, 5])\n  }\n  output {\n    File output_bam = \"~{basename}.bam\"\n    File output_bai = \"~{basename}.bai\"\n  }\n}\nd",
                "writable": false
              }
            ]
          },
          {
            "class": "InlineJavascriptRequirement"
          }
        ],
        "sbg:projectName": "BUILD: Mitochondria Pipeline",
        "sbg:revisionsInfo": [
          {
            "sbg:revision": 0,
            "sbg:modifiedBy": "dave",
            "sbg:modifiedOn": 1620309846,
            "sbg:revisionNotes": null
          },
          {
            "sbg:revision": 1,
            "sbg:modifiedBy": "dave",
            "sbg:modifiedOn": 1620309931,
            "sbg:revisionNotes": ""
          },
          {
            "sbg:revision": 2,
            "sbg:modifiedBy": "dave",
            "sbg:modifiedOn": 1621978713,
            "sbg:revisionNotes": ""
          },
          {
            "sbg:revision": 3,
            "sbg:modifiedBy": "dave",
            "sbg:modifiedOn": 1621979134,
            "sbg:revisionNotes": ""
          },
          {
            "sbg:revision": 4,
            "sbg:modifiedBy": "dave",
            "sbg:modifiedOn": 1621979192,
            "sbg:revisionNotes": "FASTA"
          },
          {
            "sbg:revision": 5,
            "sbg:modifiedBy": "dave",
            "sbg:modifiedOn": 1621989342,
            "sbg:revisionNotes": ""
          }
        ],
        "sbg:image_url": null,
        "sbg:appVersion": [
          "v1.2"
        ],
        "sbg:id": "dave/build-mitochondria-pipeline/subset-bam-to-chrom-m/5",
        "sbg:revision": 5,
        "sbg:revisionNotes": "",
        "sbg:modifiedOn": 1621989342,
        "sbg:modifiedBy": "dave",
        "sbg:createdOn": 1620309846,
        "sbg:createdBy": "dave",
        "sbg:project": "dave/build-mitochondria-pipeline",
        "sbg:sbgMaintained": false,
        "sbg:validationErrors": [],
        "sbg:contributors": [
          "dave"
        ],
        "sbg:latestRevision": 5,
        "sbg:publisher": "sbg",
        "sbg:content_hash": "a8ed2320b344c2a12c20404c9b7c638c05da2197f2c4f07f88e58576eaf576320"
      },
      "label": "subset-bam-to-chrom-m",
      "sbg:x": 276.5,
      "sbg:y": 223.7578125
    },
    {
      "id": "revert_sam",
      "in": [
        {
          "id": "bam",
          "source": "subset_bam_to_chrom_m/chrM_bam"
        }
      ],
      "out": [
        {
          "id": "unaligned_bam"
        }
      ],
      "run": {
        "class": "CommandLineTool",
        "cwlVersion": "v1.2",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "id": "dave/build-mitochondria-pipeline/revert-sam/5",
        "baseCommand": [
          "java",
          "-Xmx1000m",
          "-jar",
          "/usr/gitc/picard.jar",
          "RevertSam",
          "OUTPUT_BY_READGROUP=false",
          "VALIDATION_STRINGENCY=LENIENT",
          "ATTRIBUTE_TO_CLEAR=FT",
          "ATTRIBUTE_TO_CLEAR=CO",
          "SORT_ORDER=queryname",
          "RESTORE_ORIGINAL_QUALITIES=false"
        ],
        "inputs": [
          {
            "id": "bam",
            "type": "File",
            "inputBinding": {
              "prefix": "INPUT=",
              "separate": false,
              "shellQuote": false,
              "position": 0
            },
            "sbg:fileTypes": "BAM",
            "secondaryFiles": [
              {
                "pattern": ".bai",
                "required": false
              }
            ]
          }
        ],
        "outputs": [
          {
            "id": "unaligned_bam",
            "type": "File?",
            "outputBinding": {
              "glob": "*.bam"
            }
          }
        ],
        "label": "revert-sam",
        "arguments": [
          {
            "prefix": "OUTPUT=",
            "separate": false,
            "shellQuote": false,
            "position": 0,
            "valueFrom": "$(inputs.bam.nameroot + \"_u\" + \".bam\")"
          }
        ],
        "requirements": [
          {
            "class": "ShellCommandRequirement"
          },
          {
            "class": "DockerRequirement",
            "dockerPull": "us.gcr.io/broad-gotc-prod/genomes-in-the-cloud:2.4.2-1552931386"
          },
          {
            "class": "InitialWorkDirRequirement",
            "listing": [
              {
                "entryname": "original.wdl",
                "entry": "task RevertSam {\n  input {\n    File input_bam\n    String basename = basename(input_bam, \".bam\")\n\n    # runtime\n    Int? preemptible_tries\n  }\n  Int disk_size = ceil(size(input_bam, \"GB\") * 2.5) + 20\n\n  meta {\n    description: \"Removes alignment information while retaining recalibrated base qualities and original alignment tags\"\n  }\n  parameter_meta {\n    input_bam: \"aligned bam\"\n  }\n  command {\n    java -Xmx1000m -jar /usr/gitc/picard.jar \\\n    RevertSam \\\n    INPUT=~{input_bam} \\\n    OUTPUT_BY_READGROUP=false \\\n    OUTPUT=~{basename}.bam \\\n    VALIDATION_STRINGENCY=LENIENT \\\n    ATTRIBUTE_TO_CLEAR=FT \\\n    ATTRIBUTE_TO_CLEAR=CO \\\n    SORT_ORDER=queryname \\\n    RESTORE_ORIGINAL_QUALITIES=false\n  }\n  runtime {\n    disks: \"local-disk \" + disk_size + \" HDD\"\n    memory: \"2 GB\"\n    docker: \"us.gcr.io/broad-gotc-prod/genomes-in-the-cloud:2.4.2-1552931386\"\n    preemptible: select_first([preemptible_tries, 5])\n  }\n  output {\n    File unmapped_bam = \"~{basename}.bam\"\n  }\n}\n\n\n RevertSam  INPUT=~{input_bam} \\ OUTPUT_BY_READGROUP=false \\\n    OUTPUT=~{basename}.bam \\\n    VALIDATION_STRINGENCY=LENIENT \\\n    ATTRIBUTE_TO_CLEAR=FT \\\n    ATTRIBUTE_TO_CLEAR=CO \\\n    SORT_ORDER=queryname \\\n    RESTORE_ORIGINAL_QUALITIES=false",
                "writable": false
              }
            ]
          },
          {
            "class": "InlineJavascriptRequirement"
          }
        ],
        "sbg:projectName": "BUILD: Mitochondria Pipeline",
        "sbg:revisionsInfo": [
          {
            "sbg:revision": 0,
            "sbg:modifiedBy": "dave",
            "sbg:modifiedOn": 1620309974,
            "sbg:revisionNotes": null
          },
          {
            "sbg:revision": 1,
            "sbg:modifiedBy": "dave",
            "sbg:modifiedOn": 1620310016,
            "sbg:revisionNotes": ""
          },
          {
            "sbg:revision": 2,
            "sbg:modifiedBy": "dave",
            "sbg:modifiedOn": 1622052547,
            "sbg:revisionNotes": ""
          },
          {
            "sbg:revision": 3,
            "sbg:modifiedBy": "dave",
            "sbg:modifiedOn": 1622052847,
            "sbg:revisionNotes": ""
          },
          {
            "sbg:revision": 4,
            "sbg:modifiedBy": "dave",
            "sbg:modifiedOn": 1622052920,
            "sbg:revisionNotes": ""
          },
          {
            "sbg:revision": 5,
            "sbg:modifiedBy": "dave",
            "sbg:modifiedOn": 1622053186,
            "sbg:revisionNotes": ""
          }
        ],
        "sbg:image_url": null,
        "sbg:appVersion": [
          "v1.2"
        ],
        "sbg:id": "dave/build-mitochondria-pipeline/revert-sam/5",
        "sbg:revision": 5,
        "sbg:revisionNotes": "",
        "sbg:modifiedOn": 1622053186,
        "sbg:modifiedBy": "dave",
        "sbg:createdOn": 1620309974,
        "sbg:createdBy": "dave",
        "sbg:project": "dave/build-mitochondria-pipeline",
        "sbg:sbgMaintained": false,
        "sbg:validationErrors": [],
        "sbg:contributors": [
          "dave"
        ],
        "sbg:latestRevision": 5,
        "sbg:publisher": "sbg",
        "sbg:content_hash": "a7c97f4c0e0ac482a6f90458680eb53d1201c37d7d8da42092e4cf41b764694b2"
      },
      "label": "revert-sam",
      "sbg:x": 481.63592529296875,
      "sbg:y": 230.7578125
    },
    {
      "id": "gatk_samtofastq",
      "in": [
        {
          "id": "in_alignments",
          "source": "revert_sam/unaligned_bam"
        }
      ],
      "out": [
        {
          "id": "out_reads"
        },
        {
          "id": "unmapped_reads"
        }
      ],
      "run": {
        "class": "CommandLineTool",
        "cwlVersion": "v1.2",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "id": "dave/build-mitochondria-pipeline/gatk-samtofastq/1",
        "baseCommand": [],
        "inputs": [
          {
            "sbg:altPrefix": "-CLIP_ACT",
            "sbg:category": "Optional Arguments",
            "sbg:toolDefaultValue": "null",
            "id": "clipping_action",
            "type": "string?",
            "inputBinding": {
              "prefix": "--CLIPPING_ACTION",
              "shellQuote": false,
              "position": 5
            },
            "label": "Clipping action",
            "doc": "The action that should be taken with clipped reads: 'X' means the reads and qualities should be trimmed at the clipped position; 'N' means the bases should be changed to Ns in the clipped region; and any integer means that the base qualities should be set to that value in the clipped region."
          },
          {
            "sbg:altPrefix": "-CLIP_ATTR",
            "sbg:category": "Optional Arguments",
            "sbg:toolDefaultValue": "null",
            "id": "clipping_attribute",
            "type": "string?",
            "inputBinding": {
              "prefix": "--CLIPPING_ATTRIBUTE",
              "shellQuote": false,
              "position": 5
            },
            "label": "Clipping attribute",
            "doc": "The attribute that stores the position at which the SAM record should be clipped."
          },
          {
            "sbg:altPrefix": "-CLIP_MIN",
            "sbg:category": "Optional Arguments",
            "sbg:toolDefaultValue": "0",
            "id": "clipping_min_length",
            "type": "int?",
            "inputBinding": {
              "prefix": "--CLIPPING_MIN_LENGTH",
              "shellQuote": false,
              "position": 5
            },
            "label": "Clipping min length",
            "doc": "When performing clipping with the CLIPPING_ATTRIBUTE and CLIPPING_ACTION parameters, ensure that the resulting reads after clipping are at least CLIPPING_MIN_LENGTH bases long. If the original read is shorter than CLIPPING_MIN_LENGTH then the original read length will be maintained."
          },
          {
            "sbg:altPrefix": "-GZOPRG",
            "sbg:category": "Optional Arguments",
            "sbg:toolDefaultValue": "false",
            "id": "compress_outputs_per_rg",
            "type": "boolean?",
            "inputBinding": {
              "prefix": "--COMPRESS_OUTPUTS_PER_RG",
              "shellQuote": false,
              "position": 5
            },
            "label": "Compress outputs per RG",
            "doc": "Compress output FASTQ files per read group using gzip and append a .gz extension to the file names. Cannot be used in conjuction with argument(s) FASTQ (F) SECOND_END_FASTQ (F2) UNPAIRED_FASTQ (FU)."
          },
          {
            "sbg:category": "Optional Arguments",
            "sbg:toolDefaultValue": "2",
            "id": "compression_level",
            "type": "int?",
            "inputBinding": {
              "prefix": "--COMPRESSION_LEVEL",
              "shellQuote": false,
              "position": 5
            },
            "label": "Compression level",
            "doc": "Compression level for all compressed files created (e.g. BAM and VCF)."
          },
          {
            "sbg:altPrefix": "-NON_PF",
            "sbg:category": "Optional Arguments",
            "sbg:toolDefaultValue": "false",
            "id": "include_non_pf_reads",
            "type": "boolean?",
            "inputBinding": {
              "prefix": "--INCLUDE_NON_PF_READS",
              "shellQuote": false,
              "position": 5
            },
            "label": "Include non PF reads",
            "doc": "Include non-PF reads from the SAM file into the output FASTQ files. PF means 'passes filtering'. Reads whose 'not passing quality controls' flag is set are non-PF reads. See GATK Dictionary for more info."
          },
          {
            "sbg:category": "Optional Arguments",
            "sbg:toolDefaultValue": "false",
            "id": "include_non_primary_alignments",
            "type": "boolean?",
            "inputBinding": {
              "prefix": "--INCLUDE_NON_PRIMARY_ALIGNMENTS",
              "shellQuote": false,
              "position": 5
            },
            "label": "Include non primary alignments",
            "doc": "If true, include non-primary alignments in the output. Support of non-primary alignments in SamToFastq is not comprehensive, so there may be exceptions if this is set to true and there are paired reads with non-primary alignments."
          },
          {
            "sbg:altPrefix": "-I",
            "sbg:category": "Required Arguments",
            "id": "in_alignments",
            "type": "File",
            "inputBinding": {
              "prefix": "--INPUT",
              "shellQuote": false,
              "position": 5
            },
            "label": "Input SAM/BAM file",
            "doc": "Input SAM/BAM file to extract reads from.",
            "sbg:fileTypes": "SAM, BAM"
          },
          {
            "sbg:altPrefix": "-INTER",
            "sbg:category": "Optional Arguments",
            "sbg:toolDefaultValue": "false",
            "id": "interleave",
            "type": "boolean?",
            "inputBinding": {
              "prefix": "--INTERLEAVE",
              "shellQuote": false,
              "position": 5
            },
            "label": "Interleave",
            "doc": "Will generate an interleaved FASTQ if paired, each line will have /1 or /2 to describe which end it came from."
          },
          {
            "sbg:category": "Platform Options",
            "id": "memory_overhead_per_job",
            "type": "int?",
            "label": "Memory overhead per job",
            "doc": "This input allows a user to set the desired overhead memory when running a tool or adding it to a workflow. This amount will be added to the Memory per job in the Memory requirements section but it will not be added to the -Xmx parameter leaving some memory not occupied which can be used as stack memory (-Xmx parameter defines heap memory). This input should be defined in MB (for both the platform part and the -Xmx part if Java tool is wrapped)."
          },
          {
            "sbg:category": "Platform Options",
            "sbg:toolDefaultValue": "2048 MB",
            "id": "memory_per_job",
            "type": "int?",
            "label": "Memory per job",
            "doc": "This input allows a user to set the desired memory requirement when running a tool or adding it to a workflow. This value should be propagated to the -Xmx parameter too.This input should be defined in MB (for both the platform part and the -Xmx part if Java tool is wrapped)."
          },
          {
            "sbg:altPrefix": "-OPRG",
            "sbg:category": "Optional Arguments",
            "sbg:toolDefaultValue": "false",
            "id": "output_per_rg",
            "type": "boolean?",
            "inputBinding": {
              "prefix": "--OUTPUT_PER_RG",
              "shellQuote": false,
              "position": 5
            },
            "label": "Output per RG",
            "doc": "Output a FASTQ file per read group (two FASTQ files per read group if the group is paired). Cannot be used in conjuction with argument(s)FASTQ (F) SECOND_END_FASTQ (F2) UNPAIRED_FASTQ (FU)."
          },
          {
            "sbg:altPrefix": "-Q",
            "sbg:category": "Optional Arguments",
            "sbg:toolDefaultValue": "null",
            "id": "quality",
            "type": "int?",
            "inputBinding": {
              "prefix": "--QUALITY",
              "shellQuote": false,
              "position": 5
            },
            "label": "Quality",
            "doc": "End-trim reads using the phred/bwa quality trimming algorithm and this quality."
          },
          {
            "sbg:altPrefix": "-RC",
            "sbg:category": "Optional Arguments",
            "sbg:toolDefaultValue": "true",
            "id": "re_reverse",
            "type": [
              "null",
              {
                "type": "enum",
                "symbols": [
                  "true",
                  "false"
                ],
                "name": "re_reverse"
              }
            ],
            "inputBinding": {
              "prefix": "--RE_REVERSE",
              "shellQuote": false,
              "position": 5
            },
            "label": "Re reverse",
            "doc": "Re-reverse bases and qualities of reads with negative strand flag set before writing them to FASTQ."
          },
          {
            "sbg:altPrefix": "-R1_MAX_BASES",
            "sbg:category": "Optional Arguments",
            "sbg:toolDefaultValue": "null",
            "id": "read1_max_bases_to_write",
            "type": "int?",
            "inputBinding": {
              "prefix": "--READ1_MAX_BASES_TO_WRITE",
              "shellQuote": false,
              "position": 5
            },
            "label": "Read1 max bases to write",
            "doc": "The maximum number of bases to write from read 1 after trimming. If there are fewer than this many bases left after trimming, all will be written. If this value is null then all bases left after trimming will be written."
          },
          {
            "sbg:altPrefix": "-R1_TRIM",
            "sbg:category": "Optional Arguments",
            "sbg:toolDefaultValue": "0",
            "id": "read1_trim",
            "type": "int?",
            "inputBinding": {
              "prefix": "--READ1_TRIM",
              "shellQuote": false,
              "position": 5
            },
            "label": "Read1 trim",
            "doc": "The number of bases to trim from the beginning of read 1."
          },
          {
            "sbg:altPrefix": "-R2_MAX_BASES",
            "sbg:category": "Optional Arguments",
            "sbg:toolDefaultValue": "null",
            "id": "read2_max_bases_to_write",
            "type": "int?",
            "inputBinding": {
              "prefix": "--READ2_MAX_BASES_TO_WRITE",
              "shellQuote": false,
              "position": 5
            },
            "label": "Read2 max bases to write",
            "doc": "The maximum number of bases to write from read 2 after trimming. If there are fewer than this many bases left after trimming, all will be written. If this value is null then all bases left after trimming will be written."
          },
          {
            "sbg:altPrefix": "-R2_TRIM",
            "sbg:category": "Optional Arguments",
            "sbg:toolDefaultValue": "0",
            "id": "read2_trim",
            "type": "int?",
            "inputBinding": {
              "prefix": "--READ2_TRIM",
              "shellQuote": false,
              "position": 5
            },
            "label": "Read2 trim",
            "doc": "The number of bases to trim from the beginning of read 2."
          },
          {
            "sbg:altPrefix": "-RGT",
            "sbg:category": "Optional Arguments",
            "sbg:toolDefaultValue": "PU",
            "id": "rg_tag",
            "type": "string?",
            "inputBinding": {
              "prefix": "--RG_TAG",
              "shellQuote": false,
              "position": 5
            },
            "label": "RG tag",
            "doc": "The read group tag (PU or ID) to be used to output a FASTQ file per read group."
          },
          {
            "sbg:category": "Optional Arguments",
            "sbg:toolDefaultValue": "STRICT",
            "id": "validation_stringency",
            "type": [
              "null",
              {
                "type": "enum",
                "symbols": [
                  "STRICT",
                  "LENIENT",
                  "SILENT"
                ],
                "name": "validation_stringency"
              }
            ],
            "inputBinding": {
              "prefix": "--VALIDATION_STRINGENCY",
              "shellQuote": false,
              "position": 5
            },
            "label": "Validation stringency",
            "doc": "Validation stringency for all SAM files read by this program. Setting stringency to silent can improve performance when processing a BAM file in which variable-length data (read, qualities, tags) do not otherwise need to be decoded."
          },
          {
            "sbg:category": "Optional Arguments",
            "id": "output_prefix",
            "type": "string?",
            "label": "Output prefix",
            "doc": "Output file name prefix."
          },
          {
            "sbg:category": "Optional parameters",
            "sbg:toolDefaultValue": "false",
            "id": "compress_outputs",
            "type": "boolean?",
            "label": "Compress output file(s)",
            "doc": "Compress output file(s)."
          },
          {
            "sbg:category": "Platform Options",
            "sbg:toolDefaultValue": "1",
            "id": "cpu_per_job",
            "type": "int?",
            "label": "CPU per job",
            "doc": "CPU per job."
          }
        ],
        "outputs": [
          {
            "id": "out_reads",
            "doc": "Output FASTQ file(s).",
            "label": "Output FASTQ file(s)",
            "type": "File[]?",
            "outputBinding": {
              "glob": "${\n    var output_ext = inputs.compress_outputs ? \".fastq.gz\" : \".fastq\";\n    var interleave = inputs.interleave;\n    if (!inputs.outputs_by_readgroup)\n    {\n        if (interleave)\n        {\n            return \"*interleaved\" + output_ext;\n        }\n        else\n        {\n            return [\"*pe_1\" + output_ext, \"*pe_2\" + output_ext, \"*se\" + output_ext];\n        }\n\n    }\n    else\n    {\n        return \"*\" + output_ext;\n    }\n}",
              "outputEval": "${ \n    self = [].concat(self)\n    \n    function getPairedEnd(filename)\n    {\n        if (filename.lastIndexOf(\".fastq\") !== 0 && filename[filename.lastIndexOf(\".fastq\") - 2 ]==\"_\") \n        {\n            return filename[filename.lastIndexOf(\".fastq\") - 1 ];\n        } \n        else \n        {\n            return \"\";\n        }\n    }\n    \n    var out = inheritMetadata(self,inputs.in_alignments);\n    for (var i=0; i < out.length; i++)\n    {\n        out[i].metadata['paired_end'] = getPairedEnd(out[i].path);\n    }\n    \n    return out;\n}"
            },
            "sbg:fileTypes": "FASTQ, FASTQ.GZ"
          },
          {
            "id": "unmapped_reads",
            "doc": "Unpaired reads.",
            "label": "Unpaired reads",
            "type": "File?",
            "outputBinding": {
              "glob": "${\n    var output_ext = inputs.compress_outputs ? \".fastq.gz\" : \".fastq\";\n    var interleave = inputs.interleave;\n    if (!inputs.outputs_by_readgroup)\n    {\n        if (!interleave)\n        {\n            return \"*unpaired\" + output_ext;\n        }\n        else \n        {\n             return \"\"; \n        }      \n    }\n  else {\n       return \"\";  \n  \n  }\n}",
              "outputEval": "$(inheritMetadata(self, inputs.in_alignments))"
            },
            "sbg:fileTypes": "FASTQ, FASTQ.GZ"
          }
        ],
        "doc": "The **GATK SamToFastq** tool converts a SAM or BAM file to FASTQ.\n\nThis tool extracts read sequences and qualities from the input SAM/BAM file and writes them into the output file in Sanger FASTQ format.\n\nIn the RC mode (default is True), if the read is aligned and the alignment is to the reverse strand on the genome, the read sequence from input SAM file will be reverse-complemented prior to writing it to FASTQ in order to correctly restore the original read sequence as it was generated by the sequencer [1].\n\n*A list of **all inputs and parameters** with corresponding descriptions can be found at the bottom of the page.*\n\n###Common Use Cases\n\n* The **GATK SamToFastq** tool requires a BAM/SAM file on its **Input BAM/SAM file** (`--INPUT`) input. The tool generates a single-end FASTQ file on its **Output FASTQ file(s)** output if the input BAM/SAM file is single end. In case the input file is paired end, the tool outputs the first end of the pair FASTQ and the second end of the pair FASTQ on its **Output FASTQ file(s)** output, except when the **Interleave** (`--INTERLEAVE`) option is set to True. If the output is an interleaved FASTQ file, if paired, each line will have /1 or /2 to describe which end it came from.\n\n* The **GATK SamToFastq** tool supports an optional parameter  **Output by readgroup** (`--OUTPUT_BY_READGROUP`) which, when true, outputs a FASTQ file per read group (two FASTQ files per read group if the group is paired).\n\n* Usage example (input BAM file is single-end):\n\n```\ngatk SamToFastq \n     --INPUT input.bam\n     --FASTQ output.fastq\n```\n\n\n\n\n\n* Usage example (input BAM file is paired-end):\n\n```\ngatk SamToFastq \n     --INPUT input.bam\n     --FASTQ output.pe_1.fastq\n     --SECOND_END_FASTQ output.pe_2.fastq\n     --UNPAIRED_FASTQ unpaired.fastq\n\n```\n\n###Changes Introduced by Seven Bridges\n\n* The GATK SamToFastq tool is implemented to check if the input alignments file contains single-end or paired-end data and according to that generates different command lines for these two modes and thus produces appropriate output files on its **Output FASTQ file(s)** output (one FASTQ file in single-end mode and two FASTQ files if the input alignment file contains paired-end data). \n\n* All output files will be prefixed using the **Output prefix** parameter. In case the **Output prefix** is not provided, the output prefix will be the same as the Sample ID metadata from the **input SAM/BAM file**, if the Sample ID metadata exists. Otherwise, the output prefix will be inferred from the **Input SAM/BAM** filename. This way, having identical names of the output files between runs is avoided.\n\n* For paired-end read files, in order to successfully run alignment with STAR, this tool adds the appropriate **paired-end** metadata field in the output FASTQ files.\n\n###Common Issues and Important Notes\n\n* None\n\n###Performance Benchmarking\n\nBelow is a table describing runtimes and task costs of **GATK SamToFastq** for a couple of different samples, executed on the AWS cloud instances:\n\n| Experiment type |  Input size | Paired-end | # of reads | Read length | Duration |  Cost | Instance (AWS) | \n|:--------------:|:------------:|:--------:|:-------:|:---------:|:----------:|:------:|:------:|\n|     RNA-Seq     |  1.9 GB |     Yes    |     16M     |     101     |   4min   | ~0.03$ | c4.2xlarge (8 CPUs) | \n|     RNA-Seq     |  5.7 GB |     Yes    |     50M     |     101     |   7min   | ~0.04$ | c4.2xlarge (8 CPUs) | \n|     RNA-Seq     | 9.5 GB |     Yes    |     82M    |     101     |  10min  | ~0.07$ | c4.2xlarge (8 CPUs) | \n|     RNA-Seq     | 19 GB |     Yes    |     164M    |     101     |  20min  | ~0.13$ | c4.2xlarge (8 CPUs) |\n\n*Cost can be significantly reduced by using **spot instances**. Visit the [Knowledge Center](https://docs.sevenbridges.com/docs/about-spot-instances) for more details.*\n\n\n###References\n\n[1] [GATK SamToFastq](https://software.broadinstitute.org/gatk/documentation/tooldocs/4.0.12.0/picard_sam_SamToFastq)",
        "label": "GATK SamToFastq",
        "arguments": [
          {
            "prefix": "",
            "shellQuote": false,
            "position": 0,
            "valueFrom": "${\n    var in_alignments = [].concat(inputs.in_alignments)[0];\n    var output_ext    = inputs.compress_outputs ? \".fastq.gz\" : \".fastq\";\n    var interleave    = inputs.interleave;\n    var output_prefix = ''; \n    var cmd_line      = '';\n    cmd_line          = \"cmd='' && paired_end=`samtools view -h \" + in_alignments.path + \" | head -n 500000 | samtools view -Sc -f 0x1 -`\";\n\n  if (!inputs.outputs_by_readgroup)\n    {\n        if (inputs.output_prefix)\n        {\n            output_prefix = inputs.output_prefix;\n        }\n        else\n        {\n            if (in_alignments.metadata && in_alignments.metadata.sample_id)\n            {\n                output_prefix = in_alignments.metadata.sample_id;\n            }\n            else\n            {\n                output_prefix = in_alignments.path.split('/').pop().split('.')[0];\n            }          \n        }           \n        \n        cmd_line = cmd_line + \" && if [ $paired_end != 0 ]; then cmd='--FASTQ \" + output_prefix; \n        \n        if (interleave)\n        {\n            cmd_line = cmd_line + \".interleaved\" + output_ext + \"';\";\n        }\n        else\n        {\n            cmd_line = cmd_line + \".pe_1\" + output_ext;\n            cmd_line = cmd_line + \" --SECOND_END_FASTQ \" + output_prefix + \".pe_2\" + output_ext;\n            cmd_line = cmd_line + \" --UNPAIRED_FASTQ \" + output_prefix + \".unpaired\" + output_ext + \"';\";\n        }        \n        cmd_line = cmd_line + \" else cmd='--FASTQ \" + output_prefix  + \".se\" + output_ext + \"'; fi;\";\n        return cmd_line;\n    }\n    else\n    {\n        return \"cmd='--OUTPUT_DIR .'\";\n    }\n}\n\n"
          },
          {
            "prefix": "",
            "shellQuote": false,
            "position": 1,
            "valueFrom": "/opt/gatk"
          },
          {
            "prefix": "",
            "shellQuote": false,
            "position": 2,
            "valueFrom": "${\n    if (inputs.memory_per_job)\n    {\n        return \"--java-options\";\n    }\n    else {\n        return '';\n    }\n    \n}"
          },
          {
            "prefix": "",
            "shellQuote": false,
            "position": 3,
            "valueFrom": "${\n    if (inputs.memory_per_job) {\n        return '\\\"-Xmx'.concat(inputs.memory_per_job, 'M') + '\\\"';\n    }\n    else {\n        return \"\";\n    }\n}"
          },
          {
            "prefix": "",
            "shellQuote": false,
            "position": 4,
            "valueFrom": "SamToFastq"
          },
          {
            "prefix": "",
            "shellQuote": false,
            "position": 6,
            "valueFrom": "${\n        return '$cmd';\n}"
          }
        ],
        "requirements": [
          {
            "class": "ShellCommandRequirement"
          },
          {
            "class": "ResourceRequirement",
            "ramMin": "${\n    var memory = 4096;\n    if (inputs.memory_per_job) \n    {\n        memory = inputs.memory_per_job;\n    }\n    if (inputs.memory_overhead_per_job)\n    {\n        memory += inputs.memory_overhead_per_job;\n    }\n    return memory;\n}",
            "coresMin": "${\n    return inputs.cpu_per_job ? inputs.cpu_per_job : 1;\n}"
          },
          {
            "class": "DockerRequirement",
            "dockerPull": "images.sbgenomics.com/stefan_stojanovic/gatk:4.1.0.0"
          },
          {
            "class": "InitialWorkDirRequirement",
            "listing": []
          },
          {
            "class": "InlineJavascriptRequirement",
            "expressionLib": [
              "var updateMetadata = function(file, key, value) {\n    file['metadata'][key] = value;\n    return file;\n};\n\n\nvar setMetadata = function(file, metadata) {\n    if (!('metadata' in file))\n        file['metadata'] = metadata;\n    else {\n        for (var key in metadata) {\n            file['metadata'][key] = metadata[key];\n        }\n    }\n    return file\n};\n\nvar inheritMetadata = function(o1, o2) {\n    var commonMetadata = {};\n    if (!Array.isArray(o2)) {\n        o2 = [o2]\n    }\n    for (var i = 0; i < o2.length; i++) {\n        var example = o2[i]['metadata'];\n        for (var key in example) {\n            if (i == 0)\n                commonMetadata[key] = example[key];\n            else {\n                if (!(commonMetadata[key] == example[key])) {\n                    delete commonMetadata[key]\n                }\n            }\n        }\n    }\n    if (!Array.isArray(o1)) {\n        o1 = setMetadata(o1, commonMetadata)\n    } else {\n        for (var i = 0; i < o1.length; i++) {\n            o1[i] = setMetadata(o1[i], commonMetadata)\n        }\n    }\n    return o1;\n};\n\nvar toArray = function(file) {\n    return [].concat(file);\n};\n\nvar groupBy = function(files, key) {\n    var groupedFiles = [];\n    var tempDict = {};\n    for (var i = 0; i < files.length; i++) {\n        var value = files[i]['metadata'][key];\n        if (value in tempDict)\n            tempDict[value].push(files[i]);\n        else tempDict[value] = [files[i]];\n    }\n    for (var key in tempDict) {\n        groupedFiles.push(tempDict[key]);\n    }\n    return groupedFiles;\n};\n\nvar orderBy = function(files, key, order) {\n    var compareFunction = function(a, b) {\n        if (a['metadata'][key].constructor === Number) {\n            return a['metadata'][key] - b['metadata'][key];\n        } else {\n            var nameA = a['metadata'][key].toUpperCase();\n            var nameB = b['metadata'][key].toUpperCase();\n            if (nameA < nameB) {\n                return -1;\n            }\n            if (nameA > nameB) {\n                return 1;\n            }\n            return 0;\n        }\n    };\n\n    files = files.sort(compareFunction);\n    if (order == undefined || order == \"asc\")\n        return files;\n    else\n        return files.reverse();\n};",
              "\nvar setMetadata = function(file, metadata) {\n    if (!('metadata' in file)) {\n        file['metadata'] = {}\n    }\n    for (var key in metadata) {\n        file['metadata'][key] = metadata[key];\n    }\n    return file\n};\n\nvar inheritMetadata = function(o1, o2) {\n    var commonMetadata = {};\n    if (!Array.isArray(o2)) {\n        o2 = [o2]\n    }\n    for (var i = 0; i < o2.length; i++) {\n        var example = o2[i]['metadata'];\n        for (var key in example) {\n            if (i == 0)\n                commonMetadata[key] = example[key];\n            else {\n                if (!(commonMetadata[key] == example[key])) {\n                    delete commonMetadata[key]\n                }\n            }\n        }\n    }\n    if (!Array.isArray(o1)) {\n        o1 = setMetadata(o1, commonMetadata)\n    } else {\n        for (var i = 0; i < o1.length; i++) {\n            o1[i] = setMetadata(o1[i], commonMetadata)\n        }\n    }\n    return o1;\n};"
            ]
          }
        ],
        "sbg:categories": [
          "Utilities",
          "BAM Processing"
        ],
        "sbg:image_url": null,
        "sbg:license": "Open source BSD (3-clause) license",
        "sbg:links": [
          {
            "id": "https://software.broadinstitute.org/gatk/",
            "label": "Homepage"
          },
          {
            "id": "https://github.com/broadinstitute/gatk/",
            "label": "Source Code"
          },
          {
            "id": "https://github.com/broadinstitute/gatk/releases/download/4.1.0.0/gatk-4.1.0.0.zip",
            "label": "Download"
          },
          {
            "id": "https://www.ncbi.nlm.nih.gov/pubmed?term=20644199",
            "label": "Publications"
          },
          {
            "id": "https://software.broadinstitute.org/gatk/documentation/tooldocs/4.1.0.0/picard_sam_SamToFastq.php",
            "label": "Documentation"
          }
        ],
        "sbg:projectName": "BUILD: Mitochondria Pipeline",
        "sbg:revisionsInfo": [
          {
            "sbg:revision": 0,
            "sbg:modifiedBy": "dave",
            "sbg:modifiedOn": 1622141489,
            "sbg:revisionNotes": "Uploaded using sbpack v2020.10.05. \nSource: \nrepo: https://github.com/cwl-apps/gatk-best-practices.git\nfile: \ncommit: (uncommitted file)"
          },
          {
            "sbg:revision": 1,
            "sbg:modifiedBy": "dave",
            "sbg:modifiedOn": 1622861214,
            "sbg:revisionNotes": ""
          }
        ],
        "sbg:toolAuthor": "Broad Institute",
        "sbg:toolkit": "GATK",
        "sbg:toolkitVersion": "4.1.0.0",
        "sbg:appVersion": [
          "v1.2"
        ],
        "sbg:id": "dave/build-mitochondria-pipeline/gatk-samtofastq/1",
        "sbg:revision": 1,
        "sbg:revisionNotes": "",
        "sbg:modifiedOn": 1622861214,
        "sbg:modifiedBy": "dave",
        "sbg:createdOn": 1622141489,
        "sbg:createdBy": "dave",
        "sbg:project": "dave/build-mitochondria-pipeline",
        "sbg:sbgMaintained": false,
        "sbg:validationErrors": [],
        "sbg:contributors": [
          "dave"
        ],
        "sbg:latestRevision": 1,
        "sbg:publisher": "sbg",
        "sbg:content_hash": "a9218b248ce7e6eab4ebdcb8e04418844c942fdc689a9e743f1f24819e5f79338"
      },
      "label": "GATK SamToFastq",
      "sbg:x": 683.4907836914062,
      "sbg:y": 292.5499267578125
    },
    {
      "id": "bwa_mem_bundle",
      "in": [
        {
          "id": "input_reads",
          "source": [
            "gatk_samtofastq/out_reads"
          ]
        },
        {
          "id": "reference_index_tar",
          "source": "reference_index_tar"
        }
      ],
      "out": [
        {
          "id": "aligned_reads"
        },
        {
          "id": "dups_metrics"
        }
      ],
      "run": {
        "class": "CommandLineTool",
        "cwlVersion": "v1.2",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "id": "dave/build-mitochondria-pipeline/bwa-mem-bundle/6",
        "baseCommand": [],
        "inputs": [
          {
            "sbg:category": "BWA Algorithm options",
            "sbg:toolDefaultValue": "0.50",
            "id": "drop_chains_fraction",
            "type": "float?",
            "inputBinding": {
              "prefix": "-D",
              "shellQuote": false,
              "position": 4
            },
            "label": "Drop chains fraction",
            "doc": "Drop chains shorter than a given fraction (FLOAT) of the longest overlapping chain."
          },
          {
            "sbg:category": "BWA Input/output options",
            "sbg:toolDefaultValue": "3",
            "id": "verbose_level",
            "type": [
              "null",
              {
                "type": "enum",
                "symbols": [
                  "1",
                  "2",
                  "3",
                  "4"
                ],
                "name": "verbose_level"
              }
            ],
            "inputBinding": {
              "prefix": "-v",
              "shellQuote": false,
              "position": 4
            },
            "label": "Verbose level",
            "doc": "Select verbose level: 1=error, 2=warning, 3=message, 4+=debugging."
          },
          {
            "sbg:category": "Execution",
            "id": "sort_memory",
            "type": "int?",
            "label": "Memory for BAM sorting",
            "doc": "Amount of RAM [Gb] to give to the sorting algorithm (if not provided will be set to one-third of the total memory)."
          },
          {
            "sbg:category": "Execution",
            "sbg:toolDefaultValue": "False",
            "id": "wgs_hg38_mode_threads",
            "type": "int?",
            "label": "Optimize threads for HG38",
            "doc": "Lower the number of threads if HG38 reference genome is used."
          },
          {
            "sbg:category": "BWA Algorithm options",
            "sbg:toolDefaultValue": "100",
            "id": "band_width",
            "type": "int?",
            "inputBinding": {
              "prefix": "-w",
              "shellQuote": false,
              "position": 4
            },
            "label": "Band width",
            "doc": "Band width for banded alignment."
          },
          {
            "sbg:category": "BWA Input/output options",
            "id": "smart_pairing_in_input_fastq",
            "type": "boolean?",
            "inputBinding": {
              "prefix": "-p",
              "shellQuote": false,
              "position": 4
            },
            "label": "Smart pairing in input FASTQ file",
            "doc": "Smart pairing in input FASTQ file (ignoring in2.fq)."
          },
          {
            "sbg:category": "BWA Read Group Options",
            "sbg:toolDefaultValue": "Inferred from metadata",
            "id": "rg_library_id",
            "type": "string?",
            "label": "Library ID",
            "doc": "Specify the identifier for the sequencing library preparation, which will be placed in RG line."
          },
          {
            "sbg:category": "BWA Algorithm options",
            "sbg:toolDefaultValue": "50",
            "id": "mate_rescue_rounds",
            "type": "string?",
            "inputBinding": {
              "prefix": "-m",
              "shellQuote": false,
              "position": 4
            },
            "label": "Mate rescue rounds",
            "doc": "Perform at the most a given number (INT) of rounds of mate rescues for each read."
          },
          {
            "sbg:category": "Configuration",
            "sbg:toolDefaultValue": "1",
            "id": "reserved_threads",
            "type": "int?",
            "label": "Reserved number of threads on the instance",
            "doc": "Reserved number of threads on the instance used by scheduler."
          },
          {
            "sbg:category": "Input files",
            "id": "input_reads",
            "type": "File[]",
            "inputBinding": {
              "shellQuote": false,
              "position": 105,
              "valueFrom": "${\n    /// Set input reads in the correct order depending of the paired end from metadata\n\n    // Set output file name\n    function flatten(files){\n        var a = [];\n        for(var i=0;i<files.length;i++){\n            if(files[i]){\n                if(files[i].constructor == Array) a = a.concat(flatten(files[i]));\n                else a = a.concat(files[i]);}}\n        var b = a.filter(function (el) {return el != null;})\n        return b;}\n    var files1 = [].concat(inputs.input_reads);\n    var in_reads=flatten(files1);\n\n    // Read metadata for input reads\n    var read_metadata = in_reads[0].metadata;\n    if (!read_metadata) read_metadata = [];\n\n    var order = 0; // Consider this as normal order given at input: pe1 pe2\n\n    // Check if paired end 1 corresponds to the first given read\n    if (read_metadata == []) order = 0;\n    else if ('paired_end' in read_metadata) {\n        var pe1 = read_metadata.paired_end;\n        if (pe1 != 1) order = 1; // change order\n    }\n\n    // Return reads in the correct order\n    if (in_reads.length == 1) return in_reads[0].path; // Only one read present\n    else if (in_reads.length == 2) {\n        if (order == 0) return in_reads[0].path + ' ' + in_reads[1].path;\n        else return in_reads[1].path + ' ' + in_reads[0].path;\n    }\n}"
            },
            "label": "Input reads",
            "doc": "Input sequence reads.",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FQ, FQ.GZ"
          },
          {
            "sbg:category": "BWA Scoring options",
            "sbg:toolDefaultValue": "17",
            "id": "unpaired_read_penalty",
            "type": "int?",
            "inputBinding": {
              "prefix": "-U",
              "shellQuote": false,
              "position": 4
            },
            "label": "Unpaired read penalty",
            "doc": "Penalty for an unpaired read pair."
          },
          {
            "sbg:category": "BWA Scoring options",
            "sbg:toolDefaultValue": "[5,5]",
            "id": "clipping_penalty",
            "type": "int[]?",
            "inputBinding": {
              "prefix": "-L",
              "separate": false,
              "itemSeparator": ",",
              "shellQuote": false,
              "position": 4
            },
            "label": "Clipping penalty",
            "doc": "Penalty for 5'- and 3'-end clipping."
          },
          {
            "sbg:category": "BWA Algorithm options",
            "sbg:toolDefaultValue": "1.5",
            "id": "select_seeds",
            "type": "float?",
            "inputBinding": {
              "prefix": "-r",
              "shellQuote": false,
              "position": 4
            },
            "label": "Select seeds",
            "doc": "Look for internal seeds inside a seed longer than {-k} * FLOAT."
          },
          {
            "sbg:category": "BWA Scoring options",
            "sbg:toolDefaultValue": "1",
            "id": "score_for_a_sequence_match",
            "type": "int?",
            "inputBinding": {
              "prefix": "-A",
              "shellQuote": false,
              "position": 4
            },
            "label": "Score for a sequence match",
            "doc": "Score for a sequence match, which scales options -TdBOELU unless overridden."
          },
          {
            "sbg:category": "BWA Algorithm options",
            "sbg:toolDefaultValue": "100",
            "id": "dropoff",
            "type": "int?",
            "inputBinding": {
              "prefix": "-d",
              "shellQuote": false,
              "position": 4
            },
            "label": "Dropoff",
            "doc": "Off-diagonal X-dropoff."
          },
          {
            "id": "num_input_bases_in_each_batch",
            "type": "int?",
            "inputBinding": {
              "prefix": "-K",
              "shellQuote": false,
              "position": 4
            },
            "label": "Number of input bases to process",
            "doc": "Process a given number (INT) of input bases in each batch regardless of nThreads (for reproducibility)."
          },
          {
            "sbg:category": "Execution",
            "sbg:toolDefaultValue": "15",
            "id": "total_memory",
            "type": "int?",
            "label": "Total memory",
            "doc": "Total memory to be used by the tool in GB. It's the sum of BWA and BIOBAMBAM2 processes. For FASTQ files of a total size less than 10GB, we suggest using the default setting of 15GB, for larger files, we suggest using 58GB of memory (and 32CPU cores)."
          },
          {
            "sbg:category": "BWA Scoring options",
            "sbg:toolDefaultValue": "[1,1]",
            "id": "gap_extension_penalties",
            "type": "int[]?",
            "inputBinding": {
              "prefix": "-E",
              "separate": false,
              "itemSeparator": ",",
              "shellQuote": false,
              "position": 4
            },
            "label": "Gap extension",
            "doc": "Gap extension penalty; a gap of size k cost '{-O} + {-E}*k'. \nThis array can't have more than two values."
          },
          {
            "sbg:category": "Biobambam2 parameters",
            "sbg:toolDefaultValue": "MarkDuplicates",
            "id": "deduplication",
            "type": [
              "null",
              {
                "type": "enum",
                "symbols": [
                  "None",
                  "MarkDuplicates",
                  "RemoveDuplicates"
                ],
                "name": "deduplication"
              }
            ],
            "label": "PCR duplicate detection",
            "doc": "Use Biobambam2 for finding duplicates on sequence reads."
          },
          {
            "sbg:category": "BWA Input/output options",
            "id": "ignore_alt_file",
            "type": "boolean?",
            "inputBinding": {
              "prefix": "-j",
              "shellQuote": false,
              "position": 4
            },
            "label": "Ignore ALT file",
            "doc": "Treat ALT contigs as part of the primary assembly (i.e. ignore <idxbase>.alt file)."
          },
          {
            "sbg:category": "Configuration",
            "sbg:toolDefaultValue": "1",
            "id": "rg_id",
            "type": "string?",
            "label": "Read group ID",
            "doc": "Set read group ID."
          },
          {
            "sbg:category": "BWA Input/output options",
            "id": "use_soft_clipping",
            "type": "boolean?",
            "inputBinding": {
              "prefix": "-Y",
              "shellQuote": false,
              "position": 4
            },
            "label": "Use soft clipping",
            "doc": "Use soft clipping for supplementary alignments."
          },
          {
            "sbg:category": "BWA Input/output options",
            "sbg:toolDefaultValue": "[5, 200]",
            "id": "output_in_xa",
            "type": "int[]?",
            "inputBinding": {
              "prefix": "-h",
              "separate": false,
              "itemSeparator": ",",
              "shellQuote": false,
              "position": 4
            },
            "label": "Output in XA",
            "doc": "If there are < number (INT) of hits with a score >80% of the max score, output all in XA. \nThis array should have no more than two values."
          },
          {
            "sbg:category": "BWA Read Group Options",
            "sbg:toolDefaultValue": "Inferred from metadata",
            "id": "rg_platform",
            "type": [
              "null",
              {
                "type": "enum",
                "symbols": [
                  "454",
                  "Helicos",
                  "Illumina",
                  "Solid",
                  "IonTorrent"
                ],
                "name": "rg_platform"
              }
            ],
            "label": "Platform",
            "doc": "Specify the version of the technology that was used for sequencing, which will be placed in RG line."
          },
          {
            "sbg:category": "Execution",
            "sbg:toolDefaultValue": "8",
            "id": "threads",
            "type": "int?",
            "label": "Threads",
            "doc": "The number of threads for BWA and Biobambam2 sort processes (both will use the given number)."
          },
          {
            "sbg:category": "BWA Algorithm options",
            "id": "skip_pairing",
            "type": "boolean?",
            "inputBinding": {
              "prefix": "-P",
              "shellQuote": false,
              "position": 4
            },
            "label": "Skip pairing",
            "doc": "Skip pairing; mate rescue performed unless -S also in use."
          },
          {
            "sbg:category": "BWA Input/output options",
            "id": "insert_string_to_header",
            "type": "string?",
            "inputBinding": {
              "prefix": "-H",
              "shellQuote": false,
              "position": 4
            },
            "label": "Insert string to header",
            "doc": "Insert STR to output header if it starts with \"@\"."
          },
          {
            "sbg:category": "BWA Input/output options",
            "id": "output_header",
            "type": "boolean?",
            "inputBinding": {
              "prefix": "-V",
              "shellQuote": false,
              "position": 4
            },
            "label": "Output header",
            "doc": "Output the reference FASTA header in the XR tag."
          },
          {
            "sbg:category": "BWA Algorithm options",
            "sbg:toolDefaultValue": "20",
            "id": "seed_occurrence_for_the_3rd_round",
            "type": "int?",
            "inputBinding": {
              "prefix": "-y",
              "shellQuote": false,
              "position": 4
            },
            "label": "Seed occurrence",
            "doc": "Seed occurrence for the 3rd round seeding."
          },
          {
            "sbg:category": "BWA Scoring options",
            "id": "read_type",
            "type": [
              "null",
              {
                "type": "enum",
                "symbols": [
                  "pacbio",
                  "ont2d",
                  "intractg"
                ],
                "name": "read_type"
              }
            ],
            "inputBinding": {
              "prefix": "-x",
              "shellQuote": false,
              "position": 4
            },
            "label": "Sequencing technology-specific settings",
            "doc": "Sequencing technology-specific settings; Setting -x changes multiple parameters unless overridden. \npacbio: -k17 -W40 -r10 -A1 -B1 -O1 -E1 -L0  (PacBio reads to ref). \nont2d: -k14 -W20 -r10 -A1 -B1 -O1 -E1 -L0  (Oxford Nanopore 2D-reads to ref).\nintractg: -B9 -O16 -L5  (intra-species contigs to ref)."
          },
          {
            "sbg:category": "Input files",
            "id": "reference_index_tar",
            "type": "File",
            "label": "Reference Index TAR",
            "doc": "Reference fasta file with its BWA index files packed in a TAR archive.",
            "sbg:fileTypes": "TAR"
          },
          {
            "sbg:category": "BWA Input/output options",
            "id": "mark_shorter",
            "type": "boolean?",
            "inputBinding": {
              "prefix": "-M",
              "shellQuote": false,
              "position": 4
            },
            "label": "Mark shorter",
            "doc": "Mark shorter split hits as secondary."
          },
          {
            "sbg:category": "BWA Input/output options",
            "id": "speficy_distribution_parameters",
            "type": "float[]?",
            "inputBinding": {
              "prefix": "-I",
              "separate": false,
              "itemSeparator": " -I",
              "shellQuote": false,
              "position": 4,
              "valueFrom": "${\n    var out = \"\";\n    for (var i = 0; i < [].concat(self).length; i++ ){\n        out += \" -I\" + [].concat(self)[i];\n    }    \n    return out\n}"
            },
            "label": "Specify distribution parameters",
            "doc": "Specify the mean, standard deviation (10% of the mean if absent), max (4 sigma from the mean if absent), and min of the insert size distribution. \nFR orientation only. \nThis array can have maximum of four values, where the first two should be specified as FLOAT and the last two as INT."
          },
          {
            "sbg:category": "BWA Input/output options",
            "sbg:toolDefaultValue": "30",
            "id": "minimum_output_score",
            "type": "int?",
            "inputBinding": {
              "prefix": "-T",
              "shellQuote": false,
              "position": 4
            },
            "label": "Minimum alignment score for a read to be output in SAM/BAM",
            "doc": "Minimum alignment score for a read to be output in SAM/BAM."
          },
          {
            "sbg:category": "Execution",
            "sbg:toolDefaultValue": "Coordinate Sorted BAM",
            "id": "output_format",
            "type": [
              "null",
              {
                "type": "enum",
                "symbols": [
                  "SAM",
                  "BAM",
                  "CRAM",
                  "Queryname Sorted BAM",
                  "Queryname Sorted SAM"
                ],
                "name": "output_format"
              }
            ],
            "label": "Output format",
            "doc": "Coordinate sorted BAM file (option BAM) is the default output."
          },
          {
            "sbg:category": "BWA Algorithm options",
            "id": "skip_mate_rescue",
            "type": "boolean?",
            "inputBinding": {
              "prefix": "-S",
              "shellQuote": false,
              "position": 4
            },
            "label": "Skip mate rescue",
            "doc": "Skip mate rescue."
          },
          {
            "sbg:category": "BWA Algorithm options",
            "sbg:toolDefaultValue": "500",
            "id": "skip_seeds",
            "type": "int?",
            "inputBinding": {
              "prefix": "-c",
              "shellQuote": false,
              "position": 4
            },
            "label": "Skip seeds",
            "doc": "Skip seeds with more than a given number (INT) of occurrences."
          },
          {
            "sbg:category": "Configuration",
            "id": "output_name",
            "type": "string?",
            "label": "Output alignements file name",
            "doc": "Name for the output alignments (SAM, BAM, or CRAM) file."
          },
          {
            "sbg:category": "BWA Algorithm options",
            "sbg:toolDefaultValue": "19",
            "id": "minimum_seed_length",
            "type": "int?",
            "inputBinding": {
              "prefix": "-k",
              "shellQuote": false,
              "position": 4
            },
            "label": "Minimum seed length",
            "doc": "Minimum seed length for BWA MEM."
          },
          {
            "sbg:category": "BWA Scoring options",
            "sbg:toolDefaultValue": "[6,6]",
            "id": "gap_open_penalties",
            "type": "int[]?",
            "inputBinding": {
              "prefix": "-O",
              "separate": false,
              "itemSeparator": ",",
              "shellQuote": false,
              "position": 4
            },
            "label": "Gap open penalties",
            "doc": "Gap open penalties for deletions and insertions. \nThis array can't have more than two values."
          },
          {
            "sbg:category": "BWA Read Group Options",
            "id": "rg_median_fragment_length",
            "type": "string?",
            "label": "Median fragment length",
            "doc": "Specify the median fragment length for RG line."
          },
          {
            "sbg:category": "BWA Scoring options",
            "sbg:toolDefaultValue": "4",
            "id": "mismatch_penalty",
            "type": "int?",
            "inputBinding": {
              "prefix": "-B",
              "shellQuote": false,
              "position": 4
            },
            "label": "Mismatch penalty",
            "doc": "Penalty for a mismatch."
          },
          {
            "sbg:category": "BWA Input/output options",
            "id": "output_alignments",
            "type": "boolean?",
            "inputBinding": {
              "prefix": "-a",
              "shellQuote": false,
              "position": 4
            },
            "label": "Output alignments",
            "doc": "Output all alignments for SE or unpaired PE."
          },
          {
            "sbg:category": "BWA Algorithm options",
            "id": "discard_exact_matches",
            "type": "boolean?",
            "inputBinding": {
              "prefix": "-e",
              "shellQuote": false,
              "position": 4
            },
            "label": "Discard exact matches",
            "doc": "Discard full-length exact matches."
          },
          {
            "sbg:category": "BWA Read Group Options",
            "sbg:toolDefaultValue": "Inferred from metadata",
            "id": "rg_platform_unit_id",
            "type": "string?",
            "label": "Platform unit ID",
            "doc": "Specify the platform unit (lane/slide) for RG line - An identifier for lanes (Illumina), or for slides (SOLiD) in the case that a library was split and ran over multiple lanes on the flow cell or slides."
          },
          {
            "id": "mapQ_of_suplementary",
            "type": "boolean?",
            "inputBinding": {
              "prefix": "-q",
              "shellQuote": false,
              "position": 4
            },
            "label": "Don't modify mapQ",
            "doc": "Don't modify mapQ of supplementary alignments."
          },
          {
            "sbg:category": "BWA Read Group Options",
            "sbg:toolDefaultValue": "Inferred from metadata",
            "id": "rg_sample_id",
            "type": "string?",
            "label": "Sample ID",
            "doc": "Specify the sample ID for RG line - A human readable identifier for a sample or specimen, which could contain some metadata information. A sample or specimen is material taken from a biological entity for testing, diagnosis, propagation, treatment, or research purposes, including but not limited to tissues, body fluids, cells, organs, embryos, body excretory products, etc."
          },
          {
            "sbg:category": "BWA Read Group Options",
            "id": "rg_data_submitting_center",
            "type": "string?",
            "label": "Data submitting center",
            "doc": "Specify the data submitting center for RG line."
          },
          {
            "sbg:category": "BWA Algorithm options",
            "sbg:toolDefaultValue": "0",
            "id": "discard_chain_length",
            "type": "int?",
            "inputBinding": {
              "prefix": "-W",
              "shellQuote": false,
              "position": 4
            },
            "label": "Discard chain length",
            "doc": "Discard a chain if seeded bases are shorter than a given number (INT)."
          },
          {
            "id": "split_alignment_primary",
            "type": "boolean?",
            "inputBinding": {
              "prefix": "-5",
              "shellQuote": false,
              "position": 4
            },
            "label": "Split alignment - smallest coordinate as primary",
            "doc": "for split alignment, take the alignment with the smallest coordinate as primary."
          },
          {
            "sbg:category": "BWA Input/output options",
            "id": "append_comment",
            "type": "boolean?",
            "inputBinding": {
              "prefix": "-C",
              "shellQuote": false,
              "position": 4
            },
            "label": "Append comment",
            "doc": "Append FASTA/FASTQ comment to the output file."
          },
          {
            "sbg:category": "BWA Read Group Options",
            "sbg:toolDefaultValue": "Constructed from per-attribute parameters or inferred from metadata.",
            "id": "read_group_header",
            "type": "string?",
            "label": "Read group header",
            "doc": "Read group header line such as '@RG\\tID:foo\\tSM:bar'.  This value takes precedence over per-attribute parameters."
          },
          {
            "sbg:category": "BWA Read Group Options",
            "id": "ignore_default_rg_id",
            "type": "boolean?",
            "label": "Ignore default RG ID",
            "doc": "Ignore default RG ID ('1')."
          },
          {
            "sbg:category": "Input files",
            "id": "fasta_index",
            "type": "File?",
            "inputBinding": {
              "shellQuote": false,
              "position": 4,
              "valueFrom": "${\n    return \"\";\n}"
            },
            "label": "Fasta Index file for CRAM output",
            "doc": "Fasta index file is required for CRAM output when no PCR Deduplication is selected.",
            "sbg:fileTypes": "FAI"
          }
        ],
        "outputs": [
          {
            "id": "aligned_reads",
            "doc": "Aligned reads.",
            "label": "Aligned SAM/BAM",
            "type": "File?",
            "outputBinding": {
              "glob": "${ \n    return [\"*.sam\", \"*.bam\", \"*.cram\"] \n}",
              "outputEval": "${  \n    /// Set metadata from input parameters, metadata or default value\n\n    function flatten(files){\n        var a = []\n        for(var i=0;i<files.length;i++){\n            if(files[i]){\n                if(files[i].constructor == Array) a = a.concat(flatten(files[i]));\n                else a = a.concat(files[i]);}}\n        var b = a.filter(function (el) {return el != null});\n        return b;\n    }\n    function sharedStart(array){\n        var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n        while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n        return a1.substring(0, i);\n    }\n    /// Key-setting functions\n    // Reference genome \n    var add_metadata_key_reference_genome = function(self, inputs) {\n        var reference_file = inputs.reference_index_tar.basename;\n        var ref_list = reference_file.split('.');\n        var  a = '';\n        a = ref_list.pop();\n        a = ref_list.pop();\n        a = ref_list.pop();\n        a = ref_list.pop(); // strip '.bwa-mem2-2.1-index-archive.tar'\n        return ref_list.join('.');\n    };\n    // Platform \n    var add_metadata_key_platform = function(self, inputs) {\n        /// Set platform from input parameters/input metadata/default value\n        var platform = '';\n        var pl = '';\n        // Find PL from header\n        if (inputs.read_group_header){\n            var header = inputs.read_group_header;\n            header = header.split(\"'\").join(\"\") //remove single quotes\n            var a = header.split('\\\\t');\n            for (var i = 0; i < a.length; i++){ //find PL field\n                if (a[i].includes(\"PL:\")) pl= a[i];\n                else;\n            }}\n        else;\n        \n        if (pl) platform = pl.split(':')[1];\n        else if (inputs.rg_platform) platform = inputs.rg_platform;\n        else if (read_metadata.platform) platform = read_metadata.platform;\n        else platform = 'Illumina';\n        \n        return platform\n    };\n    // Sample ID \n    var add_metadata_key_sample_id = function(self, inputs) {\n        /// Set sample ID from input parameters/input metadata/default value from input reads file names\n        var sample_id = '';\n        var sm = '';\n        // Find SM from header\n        if (inputs.read_group_header){\n            var header = inputs.read_group_header;\n            header = header.split(\"'\").join(\"\") //remove single quotes\n            var a = header.split('\\\\t');\n            for (var i = 0; i < a.length; i++){ //find SM field\n                if (a[i].includes(\"SM:\")) var sm= a[i];\n                else;\n            }}\n        else;\n        \n        if (sm) sample_id = sm.split(':')[1];\n        else if (inputs.rg_sample_id) sample_id = inputs.rg_sample_id;\n        else if (read_metadata.sample_id) sample_id = read_metadata.sample_id;\n        else {\n            var read_names = [];\n            var files1 = [].concat(inputs.input_reads);\n            var files=flatten(files1);\n            \n            for (var i=0;i<files.length;i++) {\n                var file_ext=files[i].nameext;\n                var file_base=files[i].basename;\n                \n                if (file_ext === '.gz' || file_ext === '.GZ')\n                    file_base = file_base.slice(0, -3);\n                    file_ext= '.'+ file_base.split('.').pop();\n                if (file_ext === '.fq' || file_ext === '.FQ')\n                    file_base = file_base.slice(0, -3);\n                if (file_ext === '.fastq' || file_ext === '.FASTQ')\n                    file_base = file_base.slice(0, -6);\n                \n                read_names.push(file_base.replace(/pe1|pe2|pe\\.1|pe\\.2|pe\\_1|pe\\_2|\\_pe1|\\_pe2|\\_pe\\.1|\\_pe\\.2|\\_pe\\_1|\\_pe\\_2|\\.pe1|\\.pe2|\\.pe\\.1|\\.pe\\.2|\\.pe\\_1|\\.pe\\_2/,''));\n              }\n              ////strip out any trailing dashes/dots/underscores...\n              var unique_prefix = sharedStart(read_names).replace( /\\-$|\\_$|\\.$/, '');\n              var tmp_prefix = unique_prefix.replace( /^\\_|\\.pe$|\\.R$|\\_pe$|\\_R$/,'');\n              var final_prefix = tmp_prefix.replace( /^_\\d(\\d)?_/, '' );\n              \n              var fname=final_prefix;\n            sample_id = fname;\n        }\n        return sample_id\n    };\n    \n   \n    var files1 = [].concat(inputs.input_reads);\n    var files=flatten(files1);\n    var read_metadata = files[0].metadata;\n    if (!read_metadata) read_metadata = [];\n    \n    self = inheritMetadata(self, files);\n\n    for (var i = 0; i < self.length; i++) {\n        var out_metadata = {\n            'reference_genome': add_metadata_key_reference_genome(self[i], inputs),\n            'platform': add_metadata_key_platform(self[i], inputs),\n            'sample_id': add_metadata_key_sample_id(self[i], inputs)\n        };\n        self[i] = setMetadata(self[i], out_metadata);\n    }\n\n    return self;\n\n}"
            },
            "secondaryFiles": [
              {
                "pattern": ".bai",
                "required": false
              }
            ],
            "sbg:fileTypes": "SAM, BAM, CRAM"
          },
          {
            "id": "dups_metrics",
            "doc": "Metrics file for biobambam mark duplicates",
            "label": "Sormadup metrics",
            "type": "File?",
            "outputBinding": {
              "glob": "*.sormadup_metrics.log"
            },
            "sbg:fileTypes": "LOG"
          }
        ],
        "doc": "BWA-MEM is an algorithm designed for aligning sequence reads onto a large reference genome. BWA-MEM is implemented as a component of BWA. The algorithm can automatically choose between performing end-to-end and local alignments. BWA-MEM is capable of outputting multiple alignments, and finding chimeric reads. It can be applied to a wide range of read lengths, from 70 bp to several megabases. \n\n*A list of **all inputs and parameters** with corresponding descriptions can be found at the bottom of the page.*\n\n\n## Common Use Cases\nIn order to obtain possibilities for additional fast processing of aligned reads, **Biobambam2 sortmadup** (2.0.87) tool is embedded together into the same package with BWA-MEM (0.7.15).\n\nIn order to obtain possibilities for additional fast processing of aligned reads, **Biobambam2** (2.0.87) is embedded together with the BWA 0.7.15 toolkit into the **BWA-MEM Bundle 0.7.15 CWL1.0**.  Two tools are used (**bamsort** and **bamsormadup**) to allow the selection of three output formats (SAM, BAM, or CRAM), different modes of sorting (Quarryname/Coordinate sorting), and Marking/Removing duplicates that can arise during sample preparation e.g. library construction using PCR. This is done by setting the **Output format** and **PCR duplicate detection** parameters.\n- Additional notes:\n    - The default **Output format** is coordinate sorted BAM (option **BAM**).\n    - SAM and BAM options are query name sorted, while CRAM format is not advisable for data sorted by query name.\n    - Coordinate Sorted BAM file in all options and CRAM Coordinate sorted output with Marked Duplicates come with the accompanying index file. The generated index name will be the same as the output alignments file, with the extension BAM.BAI or CRAM.CRAI. However, when selecting the CRAM Coordinate sorted and CRAM Coordinate sorted output with Removed Duplicates, the generated files will not have the index file generated. This is a result of the usage of different Biobambam2 tools - **bamsort** does not have the ability to write CRAI files (only supports outputting BAI index files), while **bamsormadup** can write CRAI files.\n    - Passing data from BWA-MEM to Biobambam2 tools has been done through the Linux piping which saves processing times (up to an hour of the execution time for whole-genome sample) of reading and writing of aligned reads into the hard drive. \n    - **BWA-MEM Bundle 0.7.15 CWL1** first needs to construct the FM-index  (Full-text index in Minute space) for the reference genome using the **BWA INDEX 0.7.17 CWL1.0** tool. The two BWA versions are compatible.\n\n### Changes Introduced by Seven Bridges\n\n- **Aligned SAM/BAM/CRAM** file will be prefixed using the **Output SAM/BAM/CRAM file name** parameter. In case **Output SAM/BAM/CRAM file name** is not provided, the output prefix will be the same as the **Sample ID** metadata field from the file if the **Sample ID** metadata field exists. Otherwise, the output prefix will be inferred from the **Input reads** file names.\n-  The **Platform** metadata field for the output alignments will be automatically set to \"Illumina\" unless it is present in **Input reads** metadata, or given through **Read group header** or **Platform** input parameters. This will prevent possible errors in downstream analysis using the GATK toolkit.\n- If the **Read group ID** parameter is not defined, by default it will be set to \u20181\u2019. If the tool is scattered within a workflow it will assign the **Read Group ID** according to the order of the scattered folders. This ensures a unique **Read Group ID** when processing multi-read group input data from one sample.\n\n### Common Issues and Important Notes \n \n- For input reads FASTQ files of total size less than 10 GB we suggest using the default setting for parameter **Total memory** of 15GB, for larger files we suggest using 58 GB of memory and 32 CPU cores.\n- When the desired output is a CRAM file without deduplication of the PCR duplicates, it is necessary to provide the FASTA Index file (FAI) as input.\n- Human reference genome version 38 comes with ALT contigs, a collection of diverged alleles present in some humans but not the others. Making effective use of these contigs will help to reduce mapping artifacts, however, to facilitate mapping these ALT contigs to the primary assembly, GRC decided to add to each contig long flanking sequences almost identical to the primary assembly. As a result, a naive mapping against GRCh38+ALT will lead to many mapQ-zero mappings in these flanking regions. Please use post-processing steps to fix these alignments or implement [steps](https://sourceforge.net/p/bio-bwa/mailman/message/32845712/) described by the author of the BWA toolkit.  \n- Inputs **Read group header** and **Insert string to header** need to be given in the correct format - under single-quotes.\n- BWA-MEM is not a splice aware aligner, so it is not the appropriate tool for mapping RNAseq to the genome. For RNAseq reads **Bowtie2 Aligner** and **STAR** are recommended tools. \n- Input paired reads need to have the identical read names - if not, the tool will throw a ``[mem_sam_pe] paired reads have different names`` error.\n- This wrapper was tested and is fully compatible with cwltool v3.0.\n\n### Performance Benchmarking\n\nBelow is a table describing the runtimes and task costs on on-demand instances for a set of samples with different file sizes :\n\n| Input reads       | Size [GB] | Output format | Instance (AWS)           | Duration  | Cost   | Threads |\n|-------------------|-----------|---------------|--------------------------|-----------|--------|---------|\n| HG001-NA12878-30x | 2 x 23.8  | SAM           | c5.9xlarge (36CPU, 72GB) | 5h 12min  | $7.82  | 36      |\n| HG001-NA12878-30x | 2 x 23.8  | BAM           | c5.9xlarge (36CPU, 72GB) | 5h 16min  | $8.06  | 36      |\n| HG002-NA24385-50x | 2 x 66.4  | SAM           | c5.9xlarge (36CPU, 72GB) | 8h 33min  | $13.08 | 36      |\n\n\n*Cost can be significantly reduced by using **spot instances**. Visit the [Knowledge Center](https://docs.sevenbridges.com/docs/about-spot-instances) for more details.*",
        "label": "BWA MEM Bundle 0.7.15 CWL1.0",
        "arguments": [
          {
            "prefix": "",
            "shellQuote": false,
            "position": -1,
            "valueFrom": "${\n    /// Check number of input FASTQ files ///\n    \n    function flatten(files){\n    var a = []\n    for(var i=0;i<files.length;i++){\n        if(files[i]){\n            if(files[i].constructor == Array) a = a.concat(flatten(files[i]));\n            else a = a.concat(files[i])}}\n        var b = a.filter(function (el) {return el != null})\n        return b\n    }\n    \n    var files1 = [].concat(inputs.input_reads);\n    var in_reads=flatten(files1);\n    \n    if ( in_reads.length > 2 ) return 'ERROR: Number of input FASTQ files needs to be one (if single-end/interleaved file) or two (if paired-end files)';\n    else return '';\n}"
          },
          {
            "prefix": "",
            "shellQuote": false,
            "position": 0,
            "valueFrom": "${\n    var cmd = \"/bin/bash -c \\\"\";\n    return cmd + \" export REF_CACHE=${PWD} && \";\n}"
          },
          {
            "prefix": "",
            "shellQuote": false,
            "position": 1,
            "valueFrom": "${\n    /// Unpack Reference TAR archive ///\n    \n    var in_index=[].concat(inputs.reference_index_tar)[0];\n    var reference_file = in_index.basename;\n    return 'tar -tvf ' + reference_file + ' 1>&2 && tar -xf ' + reference_file + ' && ';\n    \n}"
          },
          {
            "prefix": "",
            "shellQuote": false,
            "position": 2,
            "valueFrom": "bwa mem"
          },
          {
            "prefix": "",
            "shellQuote": false,
            "position": 5,
            "valueFrom": "${\n    /// Set RG header ///\n\n    function add_param(key, val) {\n        if (!val) return;\n        param_list.push(key + ':' + val);}\n        \n    function flatten(files){\n        var a = [];\n        for(var i=0;i<files.length;i++){\n            if(files[i]){\n                if(files[i].constructor == Array) a = a.concat(flatten(files[i]));\n                else a = a.concat(files[i]);}}\n        var b = a.filter(function (el) {return el != null;});\n        return b;}\n        \n    function sharedStart(array){\n        var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n        while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n        return a1.substring(0, i);}\n\n    \n    /// If it exists - return input read group header from input parameter\n    if (inputs.read_group_header) return '-R ' + inputs.read_group_header;\n\n    // Flatten input reads\n    var in_reads1 = [].concat(inputs.input_reads);\n    var in_reads = flatten(in_reads1)\n    var input_1=in_reads[0];\n\n    var param_list = [];\n    //Read metadata for input reads\n    var read_metadata = input_1.metadata;\n    if (!read_metadata) read_metadata = [];\n\n    // Set CN\n    if (inputs.rg_data_submitting_center) add_param('CN', inputs.rg_data_submitting_center);\n    else if ('data_submitting_center' in read_metadata) add_param('CN', read_metadata.data_submitting_center);\n    else;\n\n    // Set LB\n    if (inputs.rg_library_id) add_param('LB', inputs.rg_library_id);\n    else if ('library_id' in read_metadata) add_param('LB', read_metadata.library_id);\n    else;\n\n    // Set PI\n    if (inputs.rg_median_fragment_length) add_param('PI', inputs.rg_median_fragment_length);\n    else;\n\n    // Set PL (default Illumina)\n    var rg_platform = '';\n    if (inputs.rg_platform) add_param('PL', inputs.rg_platform);\n    else if ('platform' in read_metadata) {\n        if (read_metadata.platform == 'HiSeq X Ten') rg_platform = 'Illumina';\n        else rg_platform = read_metadata.platform;\n        add_param('PL', rg_platform);}\n    else add_param('PL', 'Illumina');\n\n    // Set PU\n    if (inputs.rg_platform_unit_id) add_param('PU', inputs.rg_platform_unit_id);\n    else if ('platform_unit_id' in read_metadata) add_param('PU', read_metadata.platform_unit_id);\n    else;\n    \n    // Set RG_ID\n    var folder = input_1.path.split('/').slice(-2,-1).toString();\n    var suffix = \"_s\";\n    \n    if (inputs.rg_id) add_param('ID', inputs.rg_id);\n    else if (folder.indexOf(suffix, folder.length - suffix.length) !== -1){/// Set unique RG_ID when in scatter mode\n        var rg = folder.split(\"_\").slice(-2)[0];\n        if (parseInt(rg)) add_param('ID', rg);\n        else add_param('ID', 1);}\n    else  add_param('ID', 1);\n\n    // Set SM from input/metadata/filename\n    if (inputs.rg_sample_id) add_param('SM', inputs.rg_sample_id);\n    else if ('sample_id' in read_metadata) add_param('SM', read_metadata.sample_id);\n    else {\n        var read_names = [];\n        for (var i=0;i<in_reads.length;i++) {\n            var file_ext=in_reads[i].nameext;\n            var file_base=in_reads[i].basename;\n            \n            if (file_ext === '.gz' || file_ext === '.GZ')\n                file_base = file_base.slice(0, -3);\n                file_ext= '.'+ file_base.split('.').pop();\n            if (file_ext === '.fq' || file_ext === '.FQ')\n                file_base = file_base.slice(0, -3);\n            if (file_ext === '.fastq' || file_ext === '.FASTQ')\n                file_base = file_base.slice(0, -6);\n            \n            read_names.push(file_base.replace(/pe1|pe2|pe\\.1|pe\\.2|pe\\_1|pe\\_2|\\_pe1|\\_pe2|\\_pe\\.1|\\_pe\\.2|\\_pe\\_1|\\_pe\\_2|\\.pe1|\\.pe2|\\.pe\\.1|\\.pe\\.2|\\.pe\\_1|\\.pe\\_2/,''));}\n          \n        ////strip out any trailing dashes/dots/underscores...\n        var unique_prefix = sharedStart(read_names).replace( /\\-$|\\_$|\\.$/, '');\n        var tmp_prefix = unique_prefix.replace( /^\\_|\\.pe$|\\.R$|\\_pe$|\\_R$/,'');\n        var final_prefix = tmp_prefix.replace( /^_\\d(\\d)?_/, '' );\n      \n        var sample_id=final_prefix;\n        add_param('SM', sample_id);\n    };\n    \n    if (!inputs.ignore_default_rg_id) {\n      return \"-R '@RG\\\\t\" + param_list.join('\\\\t') + \"'\";\n    } else {\n      return '';\n    }\n\n}"
          },
          {
            "prefix": "-t",
            "shellQuote": false,
            "position": 6,
            "valueFrom": "${\n    /// Set BWA2 threads ///\n\n    var  MAX_THREADS = 36;\n    var  suggested_threads = 8;\n    var threads  = 0;\n  \n    if (inputs.threads) threads = inputs.threads;\n    else if (inputs.wgs_hg38_mode_threads) {\n        var ref_name = inputs.reference_index_tar.basename;\n        if (ref_name.search('38') >= 0) threads = inputs.wgs_hg38_mode_threads;\n        else threads = MAX_THREADS;\n    } else threads = suggested_threads;\n    \n    return threads;\n}"
          },
          {
            "prefix": "",
            "shellQuote": false,
            "position": 14,
            "valueFrom": "${\n    /// Extract common prefix for Index files ///\n    \n    var reference_tar = [].concat(inputs.reference_index_tar)[0];\n    \n    var prefix = \"$(tar -tf \" + reference_tar.basename + \" --wildcards '*.bwt' | rev | cut -c 5- | rev)\";\n    return prefix;\n\n}"
          },
          {
            "prefix": "",
            "separate": false,
            "shellQuote": false,
            "position": 116,
            "valueFrom": "${\n    ///  BIOBAMBAM2  ///\n      \n     // Get shared start and flatten input reads\n    function sharedStart(array){\n        var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n        while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n        return a1.substring(0, i);\n    }\n    function flatten(files){\n        var a = [];\n        for(var i=0;i<files.length;i++){\n            if(files[i]){\n                if(files[i].constructor == Array) a = a.concat(flatten(files[i]));\n                else a = a.concat(files[i]);}}\n        var b = a.filter(function (el) {return el != null;});\n        return b;}\n   \n    var input_reads = [].concat(inputs.input_reads);\n    var files=flatten(input_reads);\n\n    // Set output file name\n    var fname = '';\n    \n    /// from given prefix\n    if (inputs.output_name) fname = inputs.output_name;\n    /// from sample_id metadata\n    else if (files[0].metadata && files[0].metadata['sample_id']) fname=files[0].metadata['sample_id'];\n    /// from common prefix, and strip out any unnecessary characters\n    else {\n        var read_names = [];\n        for (var i=0;i<files.length;i++) {\n            var file_ext=files[i].nameext;\n            var file_base=files[i].basename;\n            \n            if (file_ext === '.gz' || file_ext === '.GZ')\n                file_base = file_base.slice(0, -3);\n                file_ext= '.'+ file_base.split('.').pop();\n            if (file_ext === '.fq' || file_ext === '.FQ')\n                file_base = file_base.slice(0, -3);\n            if (file_ext === '.fastq' || file_ext === '.FASTQ')\n                file_base = file_base.slice(0, -6);\n            \n            read_names.push(file_base.replace(/pe1|pe2|pe\\.1|pe\\.2|pe\\_1|pe\\_2|\\_pe1|\\_pe2|\\_pe\\.1|\\_pe\\.2|\\_pe\\_1|\\_pe\\_2|\\.pe1|\\.pe2|\\.pe\\.1|\\.pe\\.2|\\.pe\\_1|\\.pe\\_2/,''));\n              \n          }\n          ////strip out any trailing dashes/dots/underscores...\n          var unique_prefix = sharedStart(read_names).replace( /\\-$|\\_$|\\.$/, '');\n          var tmp_prefix = unique_prefix.replace( /^\\_|\\.pe$|\\.R$|\\_pe$|\\_R$/,'');\n          var final_prefix = tmp_prefix.replace( /^_\\d(\\d)?_/, '' );\n          \n          fname=final_prefix;}\n\n\n    // Read number of threads if defined\n    var threads = 0;\n    var MAX_THREADS = 0;\n    var ref_name = '';\n    if (inputs.threads) threads = inputs.threads;\n    else if (inputs.wgs_hg38_mode_threads) {\n        MAX_THREADS = 36;\n        ref_name = inputs.reference_index_tar.basename;\n        if (ref_name.search('38') >= 0) threads = inputs.wgs_hg38_mode_threads;\n        else threads = MAX_THREADS;\n        } \n    else threads = 8;\n\n    var tool = '';\n    var dedup = '';\n    if (inputs.deduplication == \"MarkDuplicates\") {\n        tool = 'bamsormadup';\n        dedup = ' markduplicates=1';\n    } else {\n        if (inputs.output_format == 'CRAM') tool = 'bamsort index=0';\n        else tool = 'bamsort index=1';\n        if (inputs.deduplication == \"RemoveDuplicates\") dedup = ' rmdup=1';\n        else dedup = '';\n    }\n    var sort_path = tool + dedup;\n\n    var indexfilename = '';\n    var out_format = '';\n    var extension  = '';\n    // Coordinate Sorted BAM is default\n    if (inputs.output_format == 'CRAM') {\n        out_format = ' outputformat=cram SO=coordinate';\n        ref_name = inputs.reference_index_tar.basename.split('.tar')[0];\n        out_format += ' reference=' + ref_name;\n        if (sort_path != 'bamsort index=0') indexfilename = ' indexfilename=' + fname + '.cram.crai';\n        extension = '.cram';\n    } else if (inputs.output_format == 'SAM') {\n        out_format = ' outputformat=sam SO=coordinate';\n        extension = '.sam';\n    } else if (inputs.output_format == 'Queryname Sorted BAM') {\n        out_format = ' outputformat=bam SO=queryname';\n        extension = '.bam';\n    } else if (inputs.output_format == 'Queryname Sorted SAM') {\n        out_format = ' outputformat=sam SO=queryname';\n        extension = '.sam';\n    } else {\n        out_format = ' outputformat=bam SO=coordinate';\n        indexfilename = ' indexfilename=' + fname + '.bam.bai';\n        extension = '.bam';\n    }\n    var cmd = \" | \" + sort_path + \" threads=\" + threads + \" level=1 tmplevel=-1 inputformat=sam\";\n    cmd += out_format;\n    cmd += indexfilename;\n    // capture metrics file\n    cmd += \" M=\" + fname + \".sormadup_metrics.log\";\n\n    if (inputs.output_format == 'SAM') cmd = '';\n    \n    return cmd + ' > ' + fname + extension;\n    \n}"
          },
          {
            "prefix": "",
            "shellQuote": false,
            "position": 10004,
            "valueFrom": "${\n    /// Get pipe status ///\n    \n    var  cmd = \";declare -i pipe_statuses=(\\\\${PIPESTATUS[*]});len=\\\\${#pipe_statuses[@]};declare -i tot=0;echo \\\\${pipe_statuses[*]};for (( i=0; i<\\\\${len}; i++ ));do if [ \\\\${pipe_statuses[\\\\$i]} -ne 0 ];then tot=\\\\${pipe_statuses[\\\\$i]}; fi;done;if [ \\\\$tot -ne 0 ]; then >&2 echo Error in piping. Pipe statuses: \\\\${pipe_statuses[*]};fi; if [ \\\\$tot -ne 0 ]; then false;fi\\\"\";\n    return cmd;\n}"
          }
        ],
        "requirements": [
          {
            "class": "ShellCommandRequirement"
          },
          {
            "class": "ResourceRequirement",
            "ramMin": "${\n    var reads_size =0;\n    // Calculate suggested number of CPUs depending of the input reads size\n    if (inputs.input_reads.constructor == Array) {\n        if (inputs.input_reads[1]) reads_size = inputs.input_reads[0].size + inputs.input_reads[1].size;\n        else reads_size = inputs.input_reads[0].size;\n    } else reads_size = inputs.input_reads.size;\n    if (!reads_size) reads_size = 0;\n\n    var GB_1 = 1024 * 1024 * 1024;\n    var  suggested_memory = 0;\n    if (reads_size < GB_1) suggested_memory = 4;\n    else if (reads_size < 10 * GB_1) suggested_memory = 15;\n    else suggested_memory = 58;\n    \n    if (inputs.total_memory) return inputs.total_memory * 1024;\n    else if (inputs.sort_memory) return inputs.sort_memory * 1024;\n    else return suggested_memory * 1024;\n    \n}",
            "coresMin": "${\n    var reads_size = 0\n    // Calculate suggested number of CPUs depending of the input reads size\n    if (inputs.input_reads.constructor == Array) {\n        if (inputs.input_reads[1]) reads_size = inputs.input_reads[0].size + inputs.input_reads[1].size;\n        else reads_size = inputs.input_reads[0].size;\n    } else reads_size = inputs.input_reads.size;\n    \n    if (!reads_size) reads_size = 0;\n    \n    var GB_1 = 1024 * 1024 * 1024;\n    var suggested_cpus = 0;\n    if (reads_size < GB_1) suggested_cpus = 1;\n    else if (reads_size < 10 * GB_1) suggested_cpus = 8;\n    else suggested_cpus = 31;\n    \n    if (inputs.reserved_threads) return inputs.reserved_threads;\n    else if (inputs.threads) return inputs.threads;\n    else if (inputs.sambamba_threads) return inputs.sambamba_threads;\n    else return suggested_cpus;\n    \n}"
          },
          {
            "class": "DockerRequirement",
            "dockerPull": "images.sbgenomics.com/nens/bwa-0-7-15:0"
          },
          {
            "class": "InitialWorkDirRequirement",
            "listing": [
              "$(inputs.reference_index_tar)",
              "$(inputs.input_reads)",
              "$(inputs.fasta_index)"
            ]
          },
          {
            "class": "InlineJavascriptRequirement",
            "expressionLib": [
              "var updateMetadata = function(file, key, value) {\n    file['metadata'][key] = value;\n    return file;\n};\n\n\nvar setMetadata = function(file, metadata) {\n    if (!('metadata' in file)) {\n        file['metadata'] = {}\n    }\n    for (var key in metadata) {\n        file['metadata'][key] = metadata[key];\n    }\n    return file\n};\n\nvar inheritMetadata = function(o1, o2) {\n    var commonMetadata = {};\n    if (!Array.isArray(o2)) {\n        o2 = [o2]\n    }\n    for (var i = 0; i < o2.length; i++) {\n        var example = o2[i]['metadata'];\n        for (var key in example) {\n            if (i == 0)\n                commonMetadata[key] = example[key];\n            else {\n                if (!(commonMetadata[key] == example[key])) {\n                    delete commonMetadata[key]\n                }\n            }\n        }\n    }\n    if (!Array.isArray(o1)) {\n        o1 = setMetadata(o1, commonMetadata)\n    } else {\n        for (var i = 0; i < o1.length; i++) {\n            o1[i] = setMetadata(o1[i], commonMetadata)\n        }\n    }\n    return o1;\n};\n\nvar toArray = function(file) {\n    return [].concat(file);\n};\n\nvar groupBy = function(files, key) {\n    var groupedFiles = [];\n    var tempDict = {};\n    for (var i = 0; i < files.length; i++) {\n        var value = files[i]['metadata'][key];\n        if (value in tempDict)\n            tempDict[value].push(files[i]);\n        else tempDict[value] = [files[i]];\n    }\n    for (var key in tempDict) {\n        groupedFiles.push(tempDict[key]);\n    }\n    return groupedFiles;\n};\n\nvar orderBy = function(files, key, order) {\n    var compareFunction = function(a, b) {\n        if (a['metadata'][key].constructor === Number) {\n            return a['metadata'][key] - b['metadata'][key];\n        } else {\n            var nameA = a['metadata'][key].toUpperCase();\n            var nameB = b['metadata'][key].toUpperCase();\n            if (nameA < nameB) {\n                return -1;\n            }\n            if (nameA > nameB) {\n                return 1;\n            }\n            return 0;\n        }\n    };\n\n    files = files.sort(compareFunction);\n    if (order == undefined || order == \"asc\")\n        return files;\n    else\n        return files.reverse();\n};"
            ]
          }
        ],
        "sbg:categories": [
          "Genomics",
          "Alignment",
          "CWL1.0"
        ],
        "sbg:cmdPreview": "/bin/bash -c \" export REF_CACHE=${PWD} ;  tar -tvf reference.HG38.fasta.gz.tar 1>&2; tar -xf reference.HG38.fasta.gz.tar ;  bwa mem  -R '@RG\\tID:1\\tPL:Illumina\\tSM:dnk_sample' -t 10  reference.HG38.fasta.gz  /path/to/LP6005524-DNA_C01_lane_7.sorted.converted.filtered.pe_2.gz /path/to/LP6005524-DNA_C01_lane_7.sorted.converted.filtered.pe_1.gz  | bamsormadup threads=8 level=1 tmplevel=-1 inputformat=sam outputformat=cram SO=coordinate reference=reference.HG38.fasta.gz indexfilename=LP6005524-DNA_C01_lane_7.sorted.converted.filtered.cram.crai M=LP6005524-DNA_C01_lane_7.sorted.converted.filtered.sormadup_metrics.log > LP6005524-DNA_C01_lane_7.sorted.converted.filtered.cram  ;declare -i pipe_statuses=(\\${PIPESTATUS[*]});len=\\${#pipe_statuses[@]};declare -i tot=0;echo \\${pipe_statuses[*]};for (( i=0; i<\\${len}; i++ ));do if [ \\${pipe_statuses[\\$i]} -ne 0 ];then tot=\\${pipe_statuses[\\$i]}; fi;done;if [ \\$tot -ne 0 ]; then >&2 echo Error in piping. Pipe statuses: \\${pipe_statuses[*]};fi; if [ \\$tot -ne 0 ]; then false;fi\"",
        "sbg:expand_workflow": false,
        "sbg:image_url": null,
        "sbg:license": "BWA: GNU Affero General Public License v3.0, MIT License; Biobambam2: GNU General Public License v3.0",
        "sbg:links": [
          {
            "id": "http://bio-bwa.sourceforge.net/",
            "label": "Homepage"
          },
          {
            "id": "https://github.com/lh3/bwa",
            "label": "Source code"
          },
          {
            "id": "http://bio-bwa.sourceforge.net/bwa.shtml",
            "label": "Wiki"
          },
          {
            "id": "http://sourceforge.net/projects/bio-bwa/",
            "label": "Download"
          },
          {
            "id": "http://arxiv.org/abs/1303.3997",
            "label": "Publication"
          },
          {
            "id": "http://www.ncbi.nlm.nih.gov/pubmed/19451168",
            "label": "Publication BWA Algorithm"
          }
        ],
        "sbg:projectName": "BUILD: Mitochondria Pipeline",
        "sbg:revisionsInfo": [
          {
            "sbg:revision": 0,
            "sbg:modifiedBy": "dave",
            "sbg:modifiedOn": 1622141318,
            "sbg:revisionNotes": "Uploaded using sbpack v2020.10.05. \nSource: \nrepo: https://github.com/cwl-apps/gatk-best-practices.git\nfile: \ncommit: (uncommitted file)"
          },
          {
            "sbg:revision": 1,
            "sbg:modifiedBy": "dave",
            "sbg:modifiedOn": 1622834149,
            "sbg:revisionNotes": "array of bam outputs"
          },
          {
            "sbg:revision": 2,
            "sbg:modifiedBy": "dave",
            "sbg:modifiedOn": 1622834584,
            "sbg:revisionNotes": ""
          },
          {
            "sbg:revision": 3,
            "sbg:modifiedBy": "dave",
            "sbg:modifiedOn": 1622836146,
            "sbg:revisionNotes": ""
          },
          {
            "sbg:revision": 4,
            "sbg:modifiedBy": "dave",
            "sbg:modifiedOn": 1622860795,
            "sbg:revisionNotes": ""
          },
          {
            "sbg:revision": 5,
            "sbg:modifiedBy": "dave",
            "sbg:modifiedOn": 1622860973,
            "sbg:revisionNotes": ""
          },
          {
            "sbg:revision": 6,
            "sbg:modifiedBy": "dave",
            "sbg:modifiedOn": 1622860998,
            "sbg:revisionNotes": ""
          }
        ],
        "sbg:toolAuthor": "Heng Li",
        "sbg:toolkit": "BWA",
        "sbg:toolkitVersion": "0.7.15",
        "sbg:appVersion": [
          "v1.2"
        ],
        "sbg:id": "dave/build-mitochondria-pipeline/bwa-mem-bundle/6",
        "sbg:revision": 6,
        "sbg:revisionNotes": "",
        "sbg:modifiedOn": 1622860998,
        "sbg:modifiedBy": "dave",
        "sbg:createdOn": 1622141318,
        "sbg:createdBy": "dave",
        "sbg:project": "dave/build-mitochondria-pipeline",
        "sbg:sbgMaintained": false,
        "sbg:validationErrors": [],
        "sbg:contributors": [
          "dave"
        ],
        "sbg:latestRevision": 6,
        "sbg:publisher": "sbg",
        "sbg:content_hash": "a52424b13e3925c3a7a68f29cf946dc463d2c6cf6f119a023f7aa97d1fe892c3b"
      },
      "label": "non shifted bwa",
      "sbg:x": 992.677978515625,
      "sbg:y": 398.515625
    },
    {
      "id": "bwa_mem_bundle_1",
      "in": [
        {
          "id": "input_reads",
          "source": [
            "gatk_samtofastq/out_reads"
          ]
        },
        {
          "id": "reference_index_tar",
          "source": "shifted_reference_index_tar"
        }
      ],
      "out": [
        {
          "id": "aligned_reads"
        },
        {
          "id": "dups_metrics"
        }
      ],
      "run": {
        "class": "CommandLineTool",
        "cwlVersion": "v1.2",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "id": "dave/build-mitochondria-pipeline/bwa-mem-bundle/6",
        "baseCommand": [],
        "inputs": [
          {
            "sbg:category": "BWA Algorithm options",
            "sbg:toolDefaultValue": "0.50",
            "id": "drop_chains_fraction",
            "type": "float?",
            "inputBinding": {
              "prefix": "-D",
              "shellQuote": false,
              "position": 4
            },
            "label": "Drop chains fraction",
            "doc": "Drop chains shorter than a given fraction (FLOAT) of the longest overlapping chain."
          },
          {
            "sbg:category": "BWA Input/output options",
            "sbg:toolDefaultValue": "3",
            "id": "verbose_level",
            "type": [
              "null",
              {
                "type": "enum",
                "symbols": [
                  "1",
                  "2",
                  "3",
                  "4"
                ],
                "name": "verbose_level"
              }
            ],
            "inputBinding": {
              "prefix": "-v",
              "shellQuote": false,
              "position": 4
            },
            "label": "Verbose level",
            "doc": "Select verbose level: 1=error, 2=warning, 3=message, 4+=debugging."
          },
          {
            "sbg:category": "Execution",
            "id": "sort_memory",
            "type": "int?",
            "label": "Memory for BAM sorting",
            "doc": "Amount of RAM [Gb] to give to the sorting algorithm (if not provided will be set to one-third of the total memory)."
          },
          {
            "sbg:category": "Execution",
            "sbg:toolDefaultValue": "False",
            "id": "wgs_hg38_mode_threads",
            "type": "int?",
            "label": "Optimize threads for HG38",
            "doc": "Lower the number of threads if HG38 reference genome is used."
          },
          {
            "sbg:category": "BWA Algorithm options",
            "sbg:toolDefaultValue": "100",
            "id": "band_width",
            "type": "int?",
            "inputBinding": {
              "prefix": "-w",
              "shellQuote": false,
              "position": 4
            },
            "label": "Band width",
            "doc": "Band width for banded alignment."
          },
          {
            "sbg:category": "BWA Input/output options",
            "id": "smart_pairing_in_input_fastq",
            "type": "boolean?",
            "inputBinding": {
              "prefix": "-p",
              "shellQuote": false,
              "position": 4
            },
            "label": "Smart pairing in input FASTQ file",
            "doc": "Smart pairing in input FASTQ file (ignoring in2.fq)."
          },
          {
            "sbg:category": "BWA Read Group Options",
            "sbg:toolDefaultValue": "Inferred from metadata",
            "id": "rg_library_id",
            "type": "string?",
            "label": "Library ID",
            "doc": "Specify the identifier for the sequencing library preparation, which will be placed in RG line."
          },
          {
            "sbg:category": "BWA Algorithm options",
            "sbg:toolDefaultValue": "50",
            "id": "mate_rescue_rounds",
            "type": "string?",
            "inputBinding": {
              "prefix": "-m",
              "shellQuote": false,
              "position": 4
            },
            "label": "Mate rescue rounds",
            "doc": "Perform at the most a given number (INT) of rounds of mate rescues for each read."
          },
          {
            "sbg:category": "Configuration",
            "sbg:toolDefaultValue": "1",
            "id": "reserved_threads",
            "type": "int?",
            "label": "Reserved number of threads on the instance",
            "doc": "Reserved number of threads on the instance used by scheduler."
          },
          {
            "sbg:category": "Input files",
            "id": "input_reads",
            "type": "File[]",
            "inputBinding": {
              "shellQuote": false,
              "position": 105,
              "valueFrom": "${\n    /// Set input reads in the correct order depending of the paired end from metadata\n\n    // Set output file name\n    function flatten(files){\n        var a = [];\n        for(var i=0;i<files.length;i++){\n            if(files[i]){\n                if(files[i].constructor == Array) a = a.concat(flatten(files[i]));\n                else a = a.concat(files[i]);}}\n        var b = a.filter(function (el) {return el != null;})\n        return b;}\n    var files1 = [].concat(inputs.input_reads);\n    var in_reads=flatten(files1);\n\n    // Read metadata for input reads\n    var read_metadata = in_reads[0].metadata;\n    if (!read_metadata) read_metadata = [];\n\n    var order = 0; // Consider this as normal order given at input: pe1 pe2\n\n    // Check if paired end 1 corresponds to the first given read\n    if (read_metadata == []) order = 0;\n    else if ('paired_end' in read_metadata) {\n        var pe1 = read_metadata.paired_end;\n        if (pe1 != 1) order = 1; // change order\n    }\n\n    // Return reads in the correct order\n    if (in_reads.length == 1) return in_reads[0].path; // Only one read present\n    else if (in_reads.length == 2) {\n        if (order == 0) return in_reads[0].path + ' ' + in_reads[1].path;\n        else return in_reads[1].path + ' ' + in_reads[0].path;\n    }\n}"
            },
            "label": "Input reads",
            "doc": "Input sequence reads.",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FQ, FQ.GZ"
          },
          {
            "sbg:category": "BWA Scoring options",
            "sbg:toolDefaultValue": "17",
            "id": "unpaired_read_penalty",
            "type": "int?",
            "inputBinding": {
              "prefix": "-U",
              "shellQuote": false,
              "position": 4
            },
            "label": "Unpaired read penalty",
            "doc": "Penalty for an unpaired read pair."
          },
          {
            "sbg:category": "BWA Scoring options",
            "sbg:toolDefaultValue": "[5,5]",
            "id": "clipping_penalty",
            "type": "int[]?",
            "inputBinding": {
              "prefix": "-L",
              "separate": false,
              "itemSeparator": ",",
              "shellQuote": false,
              "position": 4
            },
            "label": "Clipping penalty",
            "doc": "Penalty for 5'- and 3'-end clipping."
          },
          {
            "sbg:category": "BWA Algorithm options",
            "sbg:toolDefaultValue": "1.5",
            "id": "select_seeds",
            "type": "float?",
            "inputBinding": {
              "prefix": "-r",
              "shellQuote": false,
              "position": 4
            },
            "label": "Select seeds",
            "doc": "Look for internal seeds inside a seed longer than {-k} * FLOAT."
          },
          {
            "sbg:category": "BWA Scoring options",
            "sbg:toolDefaultValue": "1",
            "id": "score_for_a_sequence_match",
            "type": "int?",
            "inputBinding": {
              "prefix": "-A",
              "shellQuote": false,
              "position": 4
            },
            "label": "Score for a sequence match",
            "doc": "Score for a sequence match, which scales options -TdBOELU unless overridden."
          },
          {
            "sbg:category": "BWA Algorithm options",
            "sbg:toolDefaultValue": "100",
            "id": "dropoff",
            "type": "int?",
            "inputBinding": {
              "prefix": "-d",
              "shellQuote": false,
              "position": 4
            },
            "label": "Dropoff",
            "doc": "Off-diagonal X-dropoff."
          },
          {
            "id": "num_input_bases_in_each_batch",
            "type": "int?",
            "inputBinding": {
              "prefix": "-K",
              "shellQuote": false,
              "position": 4
            },
            "label": "Number of input bases to process",
            "doc": "Process a given number (INT) of input bases in each batch regardless of nThreads (for reproducibility)."
          },
          {
            "sbg:category": "Execution",
            "sbg:toolDefaultValue": "15",
            "id": "total_memory",
            "type": "int?",
            "label": "Total memory",
            "doc": "Total memory to be used by the tool in GB. It's the sum of BWA and BIOBAMBAM2 processes. For FASTQ files of a total size less than 10GB, we suggest using the default setting of 15GB, for larger files, we suggest using 58GB of memory (and 32CPU cores)."
          },
          {
            "sbg:category": "BWA Scoring options",
            "sbg:toolDefaultValue": "[1,1]",
            "id": "gap_extension_penalties",
            "type": "int[]?",
            "inputBinding": {
              "prefix": "-E",
              "separate": false,
              "itemSeparator": ",",
              "shellQuote": false,
              "position": 4
            },
            "label": "Gap extension",
            "doc": "Gap extension penalty; a gap of size k cost '{-O} + {-E}*k'. \nThis array can't have more than two values."
          },
          {
            "sbg:category": "Biobambam2 parameters",
            "sbg:toolDefaultValue": "MarkDuplicates",
            "id": "deduplication",
            "type": [
              "null",
              {
                "type": "enum",
                "symbols": [
                  "None",
                  "MarkDuplicates",
                  "RemoveDuplicates"
                ],
                "name": "deduplication"
              }
            ],
            "label": "PCR duplicate detection",
            "doc": "Use Biobambam2 for finding duplicates on sequence reads."
          },
          {
            "sbg:category": "BWA Input/output options",
            "id": "ignore_alt_file",
            "type": "boolean?",
            "inputBinding": {
              "prefix": "-j",
              "shellQuote": false,
              "position": 4
            },
            "label": "Ignore ALT file",
            "doc": "Treat ALT contigs as part of the primary assembly (i.e. ignore <idxbase>.alt file)."
          },
          {
            "sbg:category": "Configuration",
            "sbg:toolDefaultValue": "1",
            "id": "rg_id",
            "type": "string?",
            "label": "Read group ID",
            "doc": "Set read group ID."
          },
          {
            "sbg:category": "BWA Input/output options",
            "id": "use_soft_clipping",
            "type": "boolean?",
            "inputBinding": {
              "prefix": "-Y",
              "shellQuote": false,
              "position": 4
            },
            "label": "Use soft clipping",
            "doc": "Use soft clipping for supplementary alignments."
          },
          {
            "sbg:category": "BWA Input/output options",
            "sbg:toolDefaultValue": "[5, 200]",
            "id": "output_in_xa",
            "type": "int[]?",
            "inputBinding": {
              "prefix": "-h",
              "separate": false,
              "itemSeparator": ",",
              "shellQuote": false,
              "position": 4
            },
            "label": "Output in XA",
            "doc": "If there are < number (INT) of hits with a score >80% of the max score, output all in XA. \nThis array should have no more than two values."
          },
          {
            "sbg:category": "BWA Read Group Options",
            "sbg:toolDefaultValue": "Inferred from metadata",
            "id": "rg_platform",
            "type": [
              "null",
              {
                "type": "enum",
                "symbols": [
                  "454",
                  "Helicos",
                  "Illumina",
                  "Solid",
                  "IonTorrent"
                ],
                "name": "rg_platform"
              }
            ],
            "label": "Platform",
            "doc": "Specify the version of the technology that was used for sequencing, which will be placed in RG line."
          },
          {
            "sbg:category": "Execution",
            "sbg:toolDefaultValue": "8",
            "id": "threads",
            "type": "int?",
            "label": "Threads",
            "doc": "The number of threads for BWA and Biobambam2 sort processes (both will use the given number)."
          },
          {
            "sbg:category": "BWA Algorithm options",
            "id": "skip_pairing",
            "type": "boolean?",
            "inputBinding": {
              "prefix": "-P",
              "shellQuote": false,
              "position": 4
            },
            "label": "Skip pairing",
            "doc": "Skip pairing; mate rescue performed unless -S also in use."
          },
          {
            "sbg:category": "BWA Input/output options",
            "id": "insert_string_to_header",
            "type": "string?",
            "inputBinding": {
              "prefix": "-H",
              "shellQuote": false,
              "position": 4
            },
            "label": "Insert string to header",
            "doc": "Insert STR to output header if it starts with \"@\"."
          },
          {
            "sbg:category": "BWA Input/output options",
            "id": "output_header",
            "type": "boolean?",
            "inputBinding": {
              "prefix": "-V",
              "shellQuote": false,
              "position": 4
            },
            "label": "Output header",
            "doc": "Output the reference FASTA header in the XR tag."
          },
          {
            "sbg:category": "BWA Algorithm options",
            "sbg:toolDefaultValue": "20",
            "id": "seed_occurrence_for_the_3rd_round",
            "type": "int?",
            "inputBinding": {
              "prefix": "-y",
              "shellQuote": false,
              "position": 4
            },
            "label": "Seed occurrence",
            "doc": "Seed occurrence for the 3rd round seeding."
          },
          {
            "sbg:category": "BWA Scoring options",
            "id": "read_type",
            "type": [
              "null",
              {
                "type": "enum",
                "symbols": [
                  "pacbio",
                  "ont2d",
                  "intractg"
                ],
                "name": "read_type"
              }
            ],
            "inputBinding": {
              "prefix": "-x",
              "shellQuote": false,
              "position": 4
            },
            "label": "Sequencing technology-specific settings",
            "doc": "Sequencing technology-specific settings; Setting -x changes multiple parameters unless overridden. \npacbio: -k17 -W40 -r10 -A1 -B1 -O1 -E1 -L0  (PacBio reads to ref). \nont2d: -k14 -W20 -r10 -A1 -B1 -O1 -E1 -L0  (Oxford Nanopore 2D-reads to ref).\nintractg: -B9 -O16 -L5  (intra-species contigs to ref)."
          },
          {
            "sbg:category": "Input files",
            "id": "reference_index_tar",
            "type": "File",
            "label": "Reference Index TAR",
            "doc": "Reference fasta file with its BWA index files packed in a TAR archive.",
            "sbg:fileTypes": "TAR"
          },
          {
            "sbg:category": "BWA Input/output options",
            "id": "mark_shorter",
            "type": "boolean?",
            "inputBinding": {
              "prefix": "-M",
              "shellQuote": false,
              "position": 4
            },
            "label": "Mark shorter",
            "doc": "Mark shorter split hits as secondary."
          },
          {
            "sbg:category": "BWA Input/output options",
            "id": "speficy_distribution_parameters",
            "type": "float[]?",
            "inputBinding": {
              "prefix": "-I",
              "separate": false,
              "itemSeparator": " -I",
              "shellQuote": false,
              "position": 4,
              "valueFrom": "${\n    var out = \"\";\n    for (var i = 0; i < [].concat(self).length; i++ ){\n        out += \" -I\" + [].concat(self)[i];\n    }    \n    return out\n}"
            },
            "label": "Specify distribution parameters",
            "doc": "Specify the mean, standard deviation (10% of the mean if absent), max (4 sigma from the mean if absent), and min of the insert size distribution. \nFR orientation only. \nThis array can have maximum of four values, where the first two should be specified as FLOAT and the last two as INT."
          },
          {
            "sbg:category": "BWA Input/output options",
            "sbg:toolDefaultValue": "30",
            "id": "minimum_output_score",
            "type": "int?",
            "inputBinding": {
              "prefix": "-T",
              "shellQuote": false,
              "position": 4
            },
            "label": "Minimum alignment score for a read to be output in SAM/BAM",
            "doc": "Minimum alignment score for a read to be output in SAM/BAM."
          },
          {
            "sbg:category": "Execution",
            "sbg:toolDefaultValue": "Coordinate Sorted BAM",
            "id": "output_format",
            "type": [
              "null",
              {
                "type": "enum",
                "symbols": [
                  "SAM",
                  "BAM",
                  "CRAM",
                  "Queryname Sorted BAM",
                  "Queryname Sorted SAM"
                ],
                "name": "output_format"
              }
            ],
            "label": "Output format",
            "doc": "Coordinate sorted BAM file (option BAM) is the default output."
          },
          {
            "sbg:category": "BWA Algorithm options",
            "id": "skip_mate_rescue",
            "type": "boolean?",
            "inputBinding": {
              "prefix": "-S",
              "shellQuote": false,
              "position": 4
            },
            "label": "Skip mate rescue",
            "doc": "Skip mate rescue."
          },
          {
            "sbg:category": "BWA Algorithm options",
            "sbg:toolDefaultValue": "500",
            "id": "skip_seeds",
            "type": "int?",
            "inputBinding": {
              "prefix": "-c",
              "shellQuote": false,
              "position": 4
            },
            "label": "Skip seeds",
            "doc": "Skip seeds with more than a given number (INT) of occurrences."
          },
          {
            "sbg:category": "Configuration",
            "id": "output_name",
            "type": "string?",
            "label": "Output alignements file name",
            "doc": "Name for the output alignments (SAM, BAM, or CRAM) file."
          },
          {
            "sbg:category": "BWA Algorithm options",
            "sbg:toolDefaultValue": "19",
            "id": "minimum_seed_length",
            "type": "int?",
            "inputBinding": {
              "prefix": "-k",
              "shellQuote": false,
              "position": 4
            },
            "label": "Minimum seed length",
            "doc": "Minimum seed length for BWA MEM."
          },
          {
            "sbg:category": "BWA Scoring options",
            "sbg:toolDefaultValue": "[6,6]",
            "id": "gap_open_penalties",
            "type": "int[]?",
            "inputBinding": {
              "prefix": "-O",
              "separate": false,
              "itemSeparator": ",",
              "shellQuote": false,
              "position": 4
            },
            "label": "Gap open penalties",
            "doc": "Gap open penalties for deletions and insertions. \nThis array can't have more than two values."
          },
          {
            "sbg:category": "BWA Read Group Options",
            "id": "rg_median_fragment_length",
            "type": "string?",
            "label": "Median fragment length",
            "doc": "Specify the median fragment length for RG line."
          },
          {
            "sbg:category": "BWA Scoring options",
            "sbg:toolDefaultValue": "4",
            "id": "mismatch_penalty",
            "type": "int?",
            "inputBinding": {
              "prefix": "-B",
              "shellQuote": false,
              "position": 4
            },
            "label": "Mismatch penalty",
            "doc": "Penalty for a mismatch."
          },
          {
            "sbg:category": "BWA Input/output options",
            "id": "output_alignments",
            "type": "boolean?",
            "inputBinding": {
              "prefix": "-a",
              "shellQuote": false,
              "position": 4
            },
            "label": "Output alignments",
            "doc": "Output all alignments for SE or unpaired PE."
          },
          {
            "sbg:category": "BWA Algorithm options",
            "id": "discard_exact_matches",
            "type": "boolean?",
            "inputBinding": {
              "prefix": "-e",
              "shellQuote": false,
              "position": 4
            },
            "label": "Discard exact matches",
            "doc": "Discard full-length exact matches."
          },
          {
            "sbg:category": "BWA Read Group Options",
            "sbg:toolDefaultValue": "Inferred from metadata",
            "id": "rg_platform_unit_id",
            "type": "string?",
            "label": "Platform unit ID",
            "doc": "Specify the platform unit (lane/slide) for RG line - An identifier for lanes (Illumina), or for slides (SOLiD) in the case that a library was split and ran over multiple lanes on the flow cell or slides."
          },
          {
            "id": "mapQ_of_suplementary",
            "type": "boolean?",
            "inputBinding": {
              "prefix": "-q",
              "shellQuote": false,
              "position": 4
            },
            "label": "Don't modify mapQ",
            "doc": "Don't modify mapQ of supplementary alignments."
          },
          {
            "sbg:category": "BWA Read Group Options",
            "sbg:toolDefaultValue": "Inferred from metadata",
            "id": "rg_sample_id",
            "type": "string?",
            "label": "Sample ID",
            "doc": "Specify the sample ID for RG line - A human readable identifier for a sample or specimen, which could contain some metadata information. A sample or specimen is material taken from a biological entity for testing, diagnosis, propagation, treatment, or research purposes, including but not limited to tissues, body fluids, cells, organs, embryos, body excretory products, etc."
          },
          {
            "sbg:category": "BWA Read Group Options",
            "id": "rg_data_submitting_center",
            "type": "string?",
            "label": "Data submitting center",
            "doc": "Specify the data submitting center for RG line."
          },
          {
            "sbg:category": "BWA Algorithm options",
            "sbg:toolDefaultValue": "0",
            "id": "discard_chain_length",
            "type": "int?",
            "inputBinding": {
              "prefix": "-W",
              "shellQuote": false,
              "position": 4
            },
            "label": "Discard chain length",
            "doc": "Discard a chain if seeded bases are shorter than a given number (INT)."
          },
          {
            "id": "split_alignment_primary",
            "type": "boolean?",
            "inputBinding": {
              "prefix": "-5",
              "shellQuote": false,
              "position": 4
            },
            "label": "Split alignment - smallest coordinate as primary",
            "doc": "for split alignment, take the alignment with the smallest coordinate as primary."
          },
          {
            "sbg:category": "BWA Input/output options",
            "id": "append_comment",
            "type": "boolean?",
            "inputBinding": {
              "prefix": "-C",
              "shellQuote": false,
              "position": 4
            },
            "label": "Append comment",
            "doc": "Append FASTA/FASTQ comment to the output file."
          },
          {
            "sbg:category": "BWA Read Group Options",
            "sbg:toolDefaultValue": "Constructed from per-attribute parameters or inferred from metadata.",
            "id": "read_group_header",
            "type": "string?",
            "label": "Read group header",
            "doc": "Read group header line such as '@RG\\tID:foo\\tSM:bar'.  This value takes precedence over per-attribute parameters."
          },
          {
            "sbg:category": "BWA Read Group Options",
            "id": "ignore_default_rg_id",
            "type": "boolean?",
            "label": "Ignore default RG ID",
            "doc": "Ignore default RG ID ('1')."
          },
          {
            "sbg:category": "Input files",
            "id": "fasta_index",
            "type": "File?",
            "inputBinding": {
              "shellQuote": false,
              "position": 4,
              "valueFrom": "${\n    return \"\";\n}"
            },
            "label": "Fasta Index file for CRAM output",
            "doc": "Fasta index file is required for CRAM output when no PCR Deduplication is selected.",
            "sbg:fileTypes": "FAI"
          }
        ],
        "outputs": [
          {
            "id": "aligned_reads",
            "doc": "Aligned reads.",
            "label": "Aligned SAM/BAM",
            "type": "File?",
            "outputBinding": {
              "glob": "${ \n    return [\"*.sam\", \"*.bam\", \"*.cram\"] \n}",
              "outputEval": "${  \n    /// Set metadata from input parameters, metadata or default value\n\n    function flatten(files){\n        var a = []\n        for(var i=0;i<files.length;i++){\n            if(files[i]){\n                if(files[i].constructor == Array) a = a.concat(flatten(files[i]));\n                else a = a.concat(files[i]);}}\n        var b = a.filter(function (el) {return el != null});\n        return b;\n    }\n    function sharedStart(array){\n        var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n        while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n        return a1.substring(0, i);\n    }\n    /// Key-setting functions\n    // Reference genome \n    var add_metadata_key_reference_genome = function(self, inputs) {\n        var reference_file = inputs.reference_index_tar.basename;\n        var ref_list = reference_file.split('.');\n        var  a = '';\n        a = ref_list.pop();\n        a = ref_list.pop();\n        a = ref_list.pop();\n        a = ref_list.pop(); // strip '.bwa-mem2-2.1-index-archive.tar'\n        return ref_list.join('.');\n    };\n    // Platform \n    var add_metadata_key_platform = function(self, inputs) {\n        /// Set platform from input parameters/input metadata/default value\n        var platform = '';\n        var pl = '';\n        // Find PL from header\n        if (inputs.read_group_header){\n            var header = inputs.read_group_header;\n            header = header.split(\"'\").join(\"\") //remove single quotes\n            var a = header.split('\\\\t');\n            for (var i = 0; i < a.length; i++){ //find PL field\n                if (a[i].includes(\"PL:\")) pl= a[i];\n                else;\n            }}\n        else;\n        \n        if (pl) platform = pl.split(':')[1];\n        else if (inputs.rg_platform) platform = inputs.rg_platform;\n        else if (read_metadata.platform) platform = read_metadata.platform;\n        else platform = 'Illumina';\n        \n        return platform\n    };\n    // Sample ID \n    var add_metadata_key_sample_id = function(self, inputs) {\n        /// Set sample ID from input parameters/input metadata/default value from input reads file names\n        var sample_id = '';\n        var sm = '';\n        // Find SM from header\n        if (inputs.read_group_header){\n            var header = inputs.read_group_header;\n            header = header.split(\"'\").join(\"\") //remove single quotes\n            var a = header.split('\\\\t');\n            for (var i = 0; i < a.length; i++){ //find SM field\n                if (a[i].includes(\"SM:\")) var sm= a[i];\n                else;\n            }}\n        else;\n        \n        if (sm) sample_id = sm.split(':')[1];\n        else if (inputs.rg_sample_id) sample_id = inputs.rg_sample_id;\n        else if (read_metadata.sample_id) sample_id = read_metadata.sample_id;\n        else {\n            var read_names = [];\n            var files1 = [].concat(inputs.input_reads);\n            var files=flatten(files1);\n            \n            for (var i=0;i<files.length;i++) {\n                var file_ext=files[i].nameext;\n                var file_base=files[i].basename;\n                \n                if (file_ext === '.gz' || file_ext === '.GZ')\n                    file_base = file_base.slice(0, -3);\n                    file_ext= '.'+ file_base.split('.').pop();\n                if (file_ext === '.fq' || file_ext === '.FQ')\n                    file_base = file_base.slice(0, -3);\n                if (file_ext === '.fastq' || file_ext === '.FASTQ')\n                    file_base = file_base.slice(0, -6);\n                \n                read_names.push(file_base.replace(/pe1|pe2|pe\\.1|pe\\.2|pe\\_1|pe\\_2|\\_pe1|\\_pe2|\\_pe\\.1|\\_pe\\.2|\\_pe\\_1|\\_pe\\_2|\\.pe1|\\.pe2|\\.pe\\.1|\\.pe\\.2|\\.pe\\_1|\\.pe\\_2/,''));\n              }\n              ////strip out any trailing dashes/dots/underscores...\n              var unique_prefix = sharedStart(read_names).replace( /\\-$|\\_$|\\.$/, '');\n              var tmp_prefix = unique_prefix.replace( /^\\_|\\.pe$|\\.R$|\\_pe$|\\_R$/,'');\n              var final_prefix = tmp_prefix.replace( /^_\\d(\\d)?_/, '' );\n              \n              var fname=final_prefix;\n            sample_id = fname;\n        }\n        return sample_id\n    };\n    \n   \n    var files1 = [].concat(inputs.input_reads);\n    var files=flatten(files1);\n    var read_metadata = files[0].metadata;\n    if (!read_metadata) read_metadata = [];\n    \n    self = inheritMetadata(self, files);\n\n    for (var i = 0; i < self.length; i++) {\n        var out_metadata = {\n            'reference_genome': add_metadata_key_reference_genome(self[i], inputs),\n            'platform': add_metadata_key_platform(self[i], inputs),\n            'sample_id': add_metadata_key_sample_id(self[i], inputs)\n        };\n        self[i] = setMetadata(self[i], out_metadata);\n    }\n\n    return self;\n\n}"
            },
            "secondaryFiles": [
              {
                "pattern": ".bai",
                "required": false
              }
            ],
            "sbg:fileTypes": "SAM, BAM, CRAM"
          },
          {
            "id": "dups_metrics",
            "doc": "Metrics file for biobambam mark duplicates",
            "label": "Sormadup metrics",
            "type": "File?",
            "outputBinding": {
              "glob": "*.sormadup_metrics.log"
            },
            "sbg:fileTypes": "LOG"
          }
        ],
        "doc": "BWA-MEM is an algorithm designed for aligning sequence reads onto a large reference genome. BWA-MEM is implemented as a component of BWA. The algorithm can automatically choose between performing end-to-end and local alignments. BWA-MEM is capable of outputting multiple alignments, and finding chimeric reads. It can be applied to a wide range of read lengths, from 70 bp to several megabases. \n\n*A list of **all inputs and parameters** with corresponding descriptions can be found at the bottom of the page.*\n\n\n## Common Use Cases\nIn order to obtain possibilities for additional fast processing of aligned reads, **Biobambam2 sortmadup** (2.0.87) tool is embedded together into the same package with BWA-MEM (0.7.15).\n\nIn order to obtain possibilities for additional fast processing of aligned reads, **Biobambam2** (2.0.87) is embedded together with the BWA 0.7.15 toolkit into the **BWA-MEM Bundle 0.7.15 CWL1.0**.  Two tools are used (**bamsort** and **bamsormadup**) to allow the selection of three output formats (SAM, BAM, or CRAM), different modes of sorting (Quarryname/Coordinate sorting), and Marking/Removing duplicates that can arise during sample preparation e.g. library construction using PCR. This is done by setting the **Output format** and **PCR duplicate detection** parameters.\n- Additional notes:\n    - The default **Output format** is coordinate sorted BAM (option **BAM**).\n    - SAM and BAM options are query name sorted, while CRAM format is not advisable for data sorted by query name.\n    - Coordinate Sorted BAM file in all options and CRAM Coordinate sorted output with Marked Duplicates come with the accompanying index file. The generated index name will be the same as the output alignments file, with the extension BAM.BAI or CRAM.CRAI. However, when selecting the CRAM Coordinate sorted and CRAM Coordinate sorted output with Removed Duplicates, the generated files will not have the index file generated. This is a result of the usage of different Biobambam2 tools - **bamsort** does not have the ability to write CRAI files (only supports outputting BAI index files), while **bamsormadup** can write CRAI files.\n    - Passing data from BWA-MEM to Biobambam2 tools has been done through the Linux piping which saves processing times (up to an hour of the execution time for whole-genome sample) of reading and writing of aligned reads into the hard drive. \n    - **BWA-MEM Bundle 0.7.15 CWL1** first needs to construct the FM-index  (Full-text index in Minute space) for the reference genome using the **BWA INDEX 0.7.17 CWL1.0** tool. The two BWA versions are compatible.\n\n### Changes Introduced by Seven Bridges\n\n- **Aligned SAM/BAM/CRAM** file will be prefixed using the **Output SAM/BAM/CRAM file name** parameter. In case **Output SAM/BAM/CRAM file name** is not provided, the output prefix will be the same as the **Sample ID** metadata field from the file if the **Sample ID** metadata field exists. Otherwise, the output prefix will be inferred from the **Input reads** file names.\n-  The **Platform** metadata field for the output alignments will be automatically set to \"Illumina\" unless it is present in **Input reads** metadata, or given through **Read group header** or **Platform** input parameters. This will prevent possible errors in downstream analysis using the GATK toolkit.\n- If the **Read group ID** parameter is not defined, by default it will be set to \u20181\u2019. If the tool is scattered within a workflow it will assign the **Read Group ID** according to the order of the scattered folders. This ensures a unique **Read Group ID** when processing multi-read group input data from one sample.\n\n### Common Issues and Important Notes \n \n- For input reads FASTQ files of total size less than 10 GB we suggest using the default setting for parameter **Total memory** of 15GB, for larger files we suggest using 58 GB of memory and 32 CPU cores.\n- When the desired output is a CRAM file without deduplication of the PCR duplicates, it is necessary to provide the FASTA Index file (FAI) as input.\n- Human reference genome version 38 comes with ALT contigs, a collection of diverged alleles present in some humans but not the others. Making effective use of these contigs will help to reduce mapping artifacts, however, to facilitate mapping these ALT contigs to the primary assembly, GRC decided to add to each contig long flanking sequences almost identical to the primary assembly. As a result, a naive mapping against GRCh38+ALT will lead to many mapQ-zero mappings in these flanking regions. Please use post-processing steps to fix these alignments or implement [steps](https://sourceforge.net/p/bio-bwa/mailman/message/32845712/) described by the author of the BWA toolkit.  \n- Inputs **Read group header** and **Insert string to header** need to be given in the correct format - under single-quotes.\n- BWA-MEM is not a splice aware aligner, so it is not the appropriate tool for mapping RNAseq to the genome. For RNAseq reads **Bowtie2 Aligner** and **STAR** are recommended tools. \n- Input paired reads need to have the identical read names - if not, the tool will throw a ``[mem_sam_pe] paired reads have different names`` error.\n- This wrapper was tested and is fully compatible with cwltool v3.0.\n\n### Performance Benchmarking\n\nBelow is a table describing the runtimes and task costs on on-demand instances for a set of samples with different file sizes :\n\n| Input reads       | Size [GB] | Output format | Instance (AWS)           | Duration  | Cost   | Threads |\n|-------------------|-----------|---------------|--------------------------|-----------|--------|---------|\n| HG001-NA12878-30x | 2 x 23.8  | SAM           | c5.9xlarge (36CPU, 72GB) | 5h 12min  | $7.82  | 36      |\n| HG001-NA12878-30x | 2 x 23.8  | BAM           | c5.9xlarge (36CPU, 72GB) | 5h 16min  | $8.06  | 36      |\n| HG002-NA24385-50x | 2 x 66.4  | SAM           | c5.9xlarge (36CPU, 72GB) | 8h 33min  | $13.08 | 36      |\n\n\n*Cost can be significantly reduced by using **spot instances**. Visit the [Knowledge Center](https://docs.sevenbridges.com/docs/about-spot-instances) for more details.*",
        "label": "BWA MEM Bundle 0.7.15 CWL1.0",
        "arguments": [
          {
            "prefix": "",
            "shellQuote": false,
            "position": -1,
            "valueFrom": "${\n    /// Check number of input FASTQ files ///\n    \n    function flatten(files){\n    var a = []\n    for(var i=0;i<files.length;i++){\n        if(files[i]){\n            if(files[i].constructor == Array) a = a.concat(flatten(files[i]));\n            else a = a.concat(files[i])}}\n        var b = a.filter(function (el) {return el != null})\n        return b\n    }\n    \n    var files1 = [].concat(inputs.input_reads);\n    var in_reads=flatten(files1);\n    \n    if ( in_reads.length > 2 ) return 'ERROR: Number of input FASTQ files needs to be one (if single-end/interleaved file) or two (if paired-end files)';\n    else return '';\n}"
          },
          {
            "prefix": "",
            "shellQuote": false,
            "position": 0,
            "valueFrom": "${\n    var cmd = \"/bin/bash -c \\\"\";\n    return cmd + \" export REF_CACHE=${PWD} && \";\n}"
          },
          {
            "prefix": "",
            "shellQuote": false,
            "position": 1,
            "valueFrom": "${\n    /// Unpack Reference TAR archive ///\n    \n    var in_index=[].concat(inputs.reference_index_tar)[0];\n    var reference_file = in_index.basename;\n    return 'tar -tvf ' + reference_file + ' 1>&2 && tar -xf ' + reference_file + ' && ';\n    \n}"
          },
          {
            "prefix": "",
            "shellQuote": false,
            "position": 2,
            "valueFrom": "bwa mem"
          },
          {
            "prefix": "",
            "shellQuote": false,
            "position": 5,
            "valueFrom": "${\n    /// Set RG header ///\n\n    function add_param(key, val) {\n        if (!val) return;\n        param_list.push(key + ':' + val);}\n        \n    function flatten(files){\n        var a = [];\n        for(var i=0;i<files.length;i++){\n            if(files[i]){\n                if(files[i].constructor == Array) a = a.concat(flatten(files[i]));\n                else a = a.concat(files[i]);}}\n        var b = a.filter(function (el) {return el != null;});\n        return b;}\n        \n    function sharedStart(array){\n        var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n        while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n        return a1.substring(0, i);}\n\n    \n    /// If it exists - return input read group header from input parameter\n    if (inputs.read_group_header) return '-R ' + inputs.read_group_header;\n\n    // Flatten input reads\n    var in_reads1 = [].concat(inputs.input_reads);\n    var in_reads = flatten(in_reads1)\n    var input_1=in_reads[0];\n\n    var param_list = [];\n    //Read metadata for input reads\n    var read_metadata = input_1.metadata;\n    if (!read_metadata) read_metadata = [];\n\n    // Set CN\n    if (inputs.rg_data_submitting_center) add_param('CN', inputs.rg_data_submitting_center);\n    else if ('data_submitting_center' in read_metadata) add_param('CN', read_metadata.data_submitting_center);\n    else;\n\n    // Set LB\n    if (inputs.rg_library_id) add_param('LB', inputs.rg_library_id);\n    else if ('library_id' in read_metadata) add_param('LB', read_metadata.library_id);\n    else;\n\n    // Set PI\n    if (inputs.rg_median_fragment_length) add_param('PI', inputs.rg_median_fragment_length);\n    else;\n\n    // Set PL (default Illumina)\n    var rg_platform = '';\n    if (inputs.rg_platform) add_param('PL', inputs.rg_platform);\n    else if ('platform' in read_metadata) {\n        if (read_metadata.platform == 'HiSeq X Ten') rg_platform = 'Illumina';\n        else rg_platform = read_metadata.platform;\n        add_param('PL', rg_platform);}\n    else add_param('PL', 'Illumina');\n\n    // Set PU\n    if (inputs.rg_platform_unit_id) add_param('PU', inputs.rg_platform_unit_id);\n    else if ('platform_unit_id' in read_metadata) add_param('PU', read_metadata.platform_unit_id);\n    else;\n    \n    // Set RG_ID\n    var folder = input_1.path.split('/').slice(-2,-1).toString();\n    var suffix = \"_s\";\n    \n    if (inputs.rg_id) add_param('ID', inputs.rg_id);\n    else if (folder.indexOf(suffix, folder.length - suffix.length) !== -1){/// Set unique RG_ID when in scatter mode\n        var rg = folder.split(\"_\").slice(-2)[0];\n        if (parseInt(rg)) add_param('ID', rg);\n        else add_param('ID', 1);}\n    else  add_param('ID', 1);\n\n    // Set SM from input/metadata/filename\n    if (inputs.rg_sample_id) add_param('SM', inputs.rg_sample_id);\n    else if ('sample_id' in read_metadata) add_param('SM', read_metadata.sample_id);\n    else {\n        var read_names = [];\n        for (var i=0;i<in_reads.length;i++) {\n            var file_ext=in_reads[i].nameext;\n            var file_base=in_reads[i].basename;\n            \n            if (file_ext === '.gz' || file_ext === '.GZ')\n                file_base = file_base.slice(0, -3);\n                file_ext= '.'+ file_base.split('.').pop();\n            if (file_ext === '.fq' || file_ext === '.FQ')\n                file_base = file_base.slice(0, -3);\n            if (file_ext === '.fastq' || file_ext === '.FASTQ')\n                file_base = file_base.slice(0, -6);\n            \n            read_names.push(file_base.replace(/pe1|pe2|pe\\.1|pe\\.2|pe\\_1|pe\\_2|\\_pe1|\\_pe2|\\_pe\\.1|\\_pe\\.2|\\_pe\\_1|\\_pe\\_2|\\.pe1|\\.pe2|\\.pe\\.1|\\.pe\\.2|\\.pe\\_1|\\.pe\\_2/,''));}\n          \n        ////strip out any trailing dashes/dots/underscores...\n        var unique_prefix = sharedStart(read_names).replace( /\\-$|\\_$|\\.$/, '');\n        var tmp_prefix = unique_prefix.replace( /^\\_|\\.pe$|\\.R$|\\_pe$|\\_R$/,'');\n        var final_prefix = tmp_prefix.replace( /^_\\d(\\d)?_/, '' );\n      \n        var sample_id=final_prefix;\n        add_param('SM', sample_id);\n    };\n    \n    if (!inputs.ignore_default_rg_id) {\n      return \"-R '@RG\\\\t\" + param_list.join('\\\\t') + \"'\";\n    } else {\n      return '';\n    }\n\n}"
          },
          {
            "prefix": "-t",
            "shellQuote": false,
            "position": 6,
            "valueFrom": "${\n    /// Set BWA2 threads ///\n\n    var  MAX_THREADS = 36;\n    var  suggested_threads = 8;\n    var threads  = 0;\n  \n    if (inputs.threads) threads = inputs.threads;\n    else if (inputs.wgs_hg38_mode_threads) {\n        var ref_name = inputs.reference_index_tar.basename;\n        if (ref_name.search('38') >= 0) threads = inputs.wgs_hg38_mode_threads;\n        else threads = MAX_THREADS;\n    } else threads = suggested_threads;\n    \n    return threads;\n}"
          },
          {
            "prefix": "",
            "shellQuote": false,
            "position": 14,
            "valueFrom": "${\n    /// Extract common prefix for Index files ///\n    \n    var reference_tar = [].concat(inputs.reference_index_tar)[0];\n    \n    var prefix = \"$(tar -tf \" + reference_tar.basename + \" --wildcards '*.bwt' | rev | cut -c 5- | rev)\";\n    return prefix;\n\n}"
          },
          {
            "prefix": "",
            "separate": false,
            "shellQuote": false,
            "position": 116,
            "valueFrom": "${\n    ///  BIOBAMBAM2  ///\n      \n     // Get shared start and flatten input reads\n    function sharedStart(array){\n        var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n        while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n        return a1.substring(0, i);\n    }\n    function flatten(files){\n        var a = [];\n        for(var i=0;i<files.length;i++){\n            if(files[i]){\n                if(files[i].constructor == Array) a = a.concat(flatten(files[i]));\n                else a = a.concat(files[i]);}}\n        var b = a.filter(function (el) {return el != null;});\n        return b;}\n   \n    var input_reads = [].concat(inputs.input_reads);\n    var files=flatten(input_reads);\n\n    // Set output file name\n    var fname = '';\n    \n    /// from given prefix\n    if (inputs.output_name) fname = inputs.output_name;\n    /// from sample_id metadata\n    else if (files[0].metadata && files[0].metadata['sample_id']) fname=files[0].metadata['sample_id'];\n    /// from common prefix, and strip out any unnecessary characters\n    else {\n        var read_names = [];\n        for (var i=0;i<files.length;i++) {\n            var file_ext=files[i].nameext;\n            var file_base=files[i].basename;\n            \n            if (file_ext === '.gz' || file_ext === '.GZ')\n                file_base = file_base.slice(0, -3);\n                file_ext= '.'+ file_base.split('.').pop();\n            if (file_ext === '.fq' || file_ext === '.FQ')\n                file_base = file_base.slice(0, -3);\n            if (file_ext === '.fastq' || file_ext === '.FASTQ')\n                file_base = file_base.slice(0, -6);\n            \n            read_names.push(file_base.replace(/pe1|pe2|pe\\.1|pe\\.2|pe\\_1|pe\\_2|\\_pe1|\\_pe2|\\_pe\\.1|\\_pe\\.2|\\_pe\\_1|\\_pe\\_2|\\.pe1|\\.pe2|\\.pe\\.1|\\.pe\\.2|\\.pe\\_1|\\.pe\\_2/,''));\n              \n          }\n          ////strip out any trailing dashes/dots/underscores...\n          var unique_prefix = sharedStart(read_names).replace( /\\-$|\\_$|\\.$/, '');\n          var tmp_prefix = unique_prefix.replace( /^\\_|\\.pe$|\\.R$|\\_pe$|\\_R$/,'');\n          var final_prefix = tmp_prefix.replace( /^_\\d(\\d)?_/, '' );\n          \n          fname=final_prefix;}\n\n\n    // Read number of threads if defined\n    var threads = 0;\n    var MAX_THREADS = 0;\n    var ref_name = '';\n    if (inputs.threads) threads = inputs.threads;\n    else if (inputs.wgs_hg38_mode_threads) {\n        MAX_THREADS = 36;\n        ref_name = inputs.reference_index_tar.basename;\n        if (ref_name.search('38') >= 0) threads = inputs.wgs_hg38_mode_threads;\n        else threads = MAX_THREADS;\n        } \n    else threads = 8;\n\n    var tool = '';\n    var dedup = '';\n    if (inputs.deduplication == \"MarkDuplicates\") {\n        tool = 'bamsormadup';\n        dedup = ' markduplicates=1';\n    } else {\n        if (inputs.output_format == 'CRAM') tool = 'bamsort index=0';\n        else tool = 'bamsort index=1';\n        if (inputs.deduplication == \"RemoveDuplicates\") dedup = ' rmdup=1';\n        else dedup = '';\n    }\n    var sort_path = tool + dedup;\n\n    var indexfilename = '';\n    var out_format = '';\n    var extension  = '';\n    // Coordinate Sorted BAM is default\n    if (inputs.output_format == 'CRAM') {\n        out_format = ' outputformat=cram SO=coordinate';\n        ref_name = inputs.reference_index_tar.basename.split('.tar')[0];\n        out_format += ' reference=' + ref_name;\n        if (sort_path != 'bamsort index=0') indexfilename = ' indexfilename=' + fname + '.cram.crai';\n        extension = '.cram';\n    } else if (inputs.output_format == 'SAM') {\n        out_format = ' outputformat=sam SO=coordinate';\n        extension = '.sam';\n    } else if (inputs.output_format == 'Queryname Sorted BAM') {\n        out_format = ' outputformat=bam SO=queryname';\n        extension = '.bam';\n    } else if (inputs.output_format == 'Queryname Sorted SAM') {\n        out_format = ' outputformat=sam SO=queryname';\n        extension = '.sam';\n    } else {\n        out_format = ' outputformat=bam SO=coordinate';\n        indexfilename = ' indexfilename=' + fname + '.bam.bai';\n        extension = '.bam';\n    }\n    var cmd = \" | \" + sort_path + \" threads=\" + threads + \" level=1 tmplevel=-1 inputformat=sam\";\n    cmd += out_format;\n    cmd += indexfilename;\n    // capture metrics file\n    cmd += \" M=\" + fname + \".sormadup_metrics.log\";\n\n    if (inputs.output_format == 'SAM') cmd = '';\n    \n    return cmd + ' > ' + fname + extension;\n    \n}"
          },
          {
            "prefix": "",
            "shellQuote": false,
            "position": 10004,
            "valueFrom": "${\n    /// Get pipe status ///\n    \n    var  cmd = \";declare -i pipe_statuses=(\\\\${PIPESTATUS[*]});len=\\\\${#pipe_statuses[@]};declare -i tot=0;echo \\\\${pipe_statuses[*]};for (( i=0; i<\\\\${len}; i++ ));do if [ \\\\${pipe_statuses[\\\\$i]} -ne 0 ];then tot=\\\\${pipe_statuses[\\\\$i]}; fi;done;if [ \\\\$tot -ne 0 ]; then >&2 echo Error in piping. Pipe statuses: \\\\${pipe_statuses[*]};fi; if [ \\\\$tot -ne 0 ]; then false;fi\\\"\";\n    return cmd;\n}"
          }
        ],
        "requirements": [
          {
            "class": "ShellCommandRequirement"
          },
          {
            "class": "ResourceRequirement",
            "ramMin": "${\n    var reads_size =0;\n    // Calculate suggested number of CPUs depending of the input reads size\n    if (inputs.input_reads.constructor == Array) {\n        if (inputs.input_reads[1]) reads_size = inputs.input_reads[0].size + inputs.input_reads[1].size;\n        else reads_size = inputs.input_reads[0].size;\n    } else reads_size = inputs.input_reads.size;\n    if (!reads_size) reads_size = 0;\n\n    var GB_1 = 1024 * 1024 * 1024;\n    var  suggested_memory = 0;\n    if (reads_size < GB_1) suggested_memory = 4;\n    else if (reads_size < 10 * GB_1) suggested_memory = 15;\n    else suggested_memory = 58;\n    \n    if (inputs.total_memory) return inputs.total_memory * 1024;\n    else if (inputs.sort_memory) return inputs.sort_memory * 1024;\n    else return suggested_memory * 1024;\n    \n}",
            "coresMin": "${\n    var reads_size = 0\n    // Calculate suggested number of CPUs depending of the input reads size\n    if (inputs.input_reads.constructor == Array) {\n        if (inputs.input_reads[1]) reads_size = inputs.input_reads[0].size + inputs.input_reads[1].size;\n        else reads_size = inputs.input_reads[0].size;\n    } else reads_size = inputs.input_reads.size;\n    \n    if (!reads_size) reads_size = 0;\n    \n    var GB_1 = 1024 * 1024 * 1024;\n    var suggested_cpus = 0;\n    if (reads_size < GB_1) suggested_cpus = 1;\n    else if (reads_size < 10 * GB_1) suggested_cpus = 8;\n    else suggested_cpus = 31;\n    \n    if (inputs.reserved_threads) return inputs.reserved_threads;\n    else if (inputs.threads) return inputs.threads;\n    else if (inputs.sambamba_threads) return inputs.sambamba_threads;\n    else return suggested_cpus;\n    \n}"
          },
          {
            "class": "DockerRequirement",
            "dockerPull": "images.sbgenomics.com/nens/bwa-0-7-15:0"
          },
          {
            "class": "InitialWorkDirRequirement",
            "listing": [
              "$(inputs.reference_index_tar)",
              "$(inputs.input_reads)",
              "$(inputs.fasta_index)"
            ]
          },
          {
            "class": "InlineJavascriptRequirement",
            "expressionLib": [
              "var updateMetadata = function(file, key, value) {\n    file['metadata'][key] = value;\n    return file;\n};\n\n\nvar setMetadata = function(file, metadata) {\n    if (!('metadata' in file)) {\n        file['metadata'] = {}\n    }\n    for (var key in metadata) {\n        file['metadata'][key] = metadata[key];\n    }\n    return file\n};\n\nvar inheritMetadata = function(o1, o2) {\n    var commonMetadata = {};\n    if (!Array.isArray(o2)) {\n        o2 = [o2]\n    }\n    for (var i = 0; i < o2.length; i++) {\n        var example = o2[i]['metadata'];\n        for (var key in example) {\n            if (i == 0)\n                commonMetadata[key] = example[key];\n            else {\n                if (!(commonMetadata[key] == example[key])) {\n                    delete commonMetadata[key]\n                }\n            }\n        }\n    }\n    if (!Array.isArray(o1)) {\n        o1 = setMetadata(o1, commonMetadata)\n    } else {\n        for (var i = 0; i < o1.length; i++) {\n            o1[i] = setMetadata(o1[i], commonMetadata)\n        }\n    }\n    return o1;\n};\n\nvar toArray = function(file) {\n    return [].concat(file);\n};\n\nvar groupBy = function(files, key) {\n    var groupedFiles = [];\n    var tempDict = {};\n    for (var i = 0; i < files.length; i++) {\n        var value = files[i]['metadata'][key];\n        if (value in tempDict)\n            tempDict[value].push(files[i]);\n        else tempDict[value] = [files[i]];\n    }\n    for (var key in tempDict) {\n        groupedFiles.push(tempDict[key]);\n    }\n    return groupedFiles;\n};\n\nvar orderBy = function(files, key, order) {\n    var compareFunction = function(a, b) {\n        if (a['metadata'][key].constructor === Number) {\n            return a['metadata'][key] - b['metadata'][key];\n        } else {\n            var nameA = a['metadata'][key].toUpperCase();\n            var nameB = b['metadata'][key].toUpperCase();\n            if (nameA < nameB) {\n                return -1;\n            }\n            if (nameA > nameB) {\n                return 1;\n            }\n            return 0;\n        }\n    };\n\n    files = files.sort(compareFunction);\n    if (order == undefined || order == \"asc\")\n        return files;\n    else\n        return files.reverse();\n};"
            ]
          }
        ],
        "sbg:categories": [
          "Genomics",
          "Alignment",
          "CWL1.0"
        ],
        "sbg:cmdPreview": "/bin/bash -c \" export REF_CACHE=${PWD} ;  tar -tvf reference.HG38.fasta.gz.tar 1>&2; tar -xf reference.HG38.fasta.gz.tar ;  bwa mem  -R '@RG\\tID:1\\tPL:Illumina\\tSM:dnk_sample' -t 10  reference.HG38.fasta.gz  /path/to/LP6005524-DNA_C01_lane_7.sorted.converted.filtered.pe_2.gz /path/to/LP6005524-DNA_C01_lane_7.sorted.converted.filtered.pe_1.gz  | bamsormadup threads=8 level=1 tmplevel=-1 inputformat=sam outputformat=cram SO=coordinate reference=reference.HG38.fasta.gz indexfilename=LP6005524-DNA_C01_lane_7.sorted.converted.filtered.cram.crai M=LP6005524-DNA_C01_lane_7.sorted.converted.filtered.sormadup_metrics.log > LP6005524-DNA_C01_lane_7.sorted.converted.filtered.cram  ;declare -i pipe_statuses=(\\${PIPESTATUS[*]});len=\\${#pipe_statuses[@]};declare -i tot=0;echo \\${pipe_statuses[*]};for (( i=0; i<\\${len}; i++ ));do if [ \\${pipe_statuses[\\$i]} -ne 0 ];then tot=\\${pipe_statuses[\\$i]}; fi;done;if [ \\$tot -ne 0 ]; then >&2 echo Error in piping. Pipe statuses: \\${pipe_statuses[*]};fi; if [ \\$tot -ne 0 ]; then false;fi\"",
        "sbg:expand_workflow": false,
        "sbg:image_url": null,
        "sbg:license": "BWA: GNU Affero General Public License v3.0, MIT License; Biobambam2: GNU General Public License v3.0",
        "sbg:links": [
          {
            "id": "http://bio-bwa.sourceforge.net/",
            "label": "Homepage"
          },
          {
            "id": "https://github.com/lh3/bwa",
            "label": "Source code"
          },
          {
            "id": "http://bio-bwa.sourceforge.net/bwa.shtml",
            "label": "Wiki"
          },
          {
            "id": "http://sourceforge.net/projects/bio-bwa/",
            "label": "Download"
          },
          {
            "id": "http://arxiv.org/abs/1303.3997",
            "label": "Publication"
          },
          {
            "id": "http://www.ncbi.nlm.nih.gov/pubmed/19451168",
            "label": "Publication BWA Algorithm"
          }
        ],
        "sbg:projectName": "BUILD: Mitochondria Pipeline",
        "sbg:revisionsInfo": [
          {
            "sbg:revision": 0,
            "sbg:modifiedBy": "dave",
            "sbg:modifiedOn": 1622141318,
            "sbg:revisionNotes": "Uploaded using sbpack v2020.10.05. \nSource: \nrepo: https://github.com/cwl-apps/gatk-best-practices.git\nfile: \ncommit: (uncommitted file)"
          },
          {
            "sbg:revision": 1,
            "sbg:modifiedBy": "dave",
            "sbg:modifiedOn": 1622834149,
            "sbg:revisionNotes": "array of bam outputs"
          },
          {
            "sbg:revision": 2,
            "sbg:modifiedBy": "dave",
            "sbg:modifiedOn": 1622834584,
            "sbg:revisionNotes": ""
          },
          {
            "sbg:revision": 3,
            "sbg:modifiedBy": "dave",
            "sbg:modifiedOn": 1622836146,
            "sbg:revisionNotes": ""
          },
          {
            "sbg:revision": 4,
            "sbg:modifiedBy": "dave",
            "sbg:modifiedOn": 1622860795,
            "sbg:revisionNotes": ""
          },
          {
            "sbg:revision": 5,
            "sbg:modifiedBy": "dave",
            "sbg:modifiedOn": 1622860973,
            "sbg:revisionNotes": ""
          },
          {
            "sbg:revision": 6,
            "sbg:modifiedBy": "dave",
            "sbg:modifiedOn": 1622860998,
            "sbg:revisionNotes": ""
          }
        ],
        "sbg:toolAuthor": "Heng Li",
        "sbg:toolkit": "BWA",
        "sbg:toolkitVersion": "0.7.15",
        "sbg:appVersion": [
          "v1.2"
        ],
        "sbg:id": "dave/build-mitochondria-pipeline/bwa-mem-bundle/6",
        "sbg:revision": 6,
        "sbg:revisionNotes": "",
        "sbg:modifiedOn": 1622860998,
        "sbg:modifiedBy": "dave",
        "sbg:createdOn": 1622141318,
        "sbg:createdBy": "dave",
        "sbg:project": "dave/build-mitochondria-pipeline",
        "sbg:sbgMaintained": false,
        "sbg:validationErrors": [],
        "sbg:contributors": [
          "dave"
        ],
        "sbg:latestRevision": 6,
        "sbg:publisher": "sbg",
        "sbg:content_hash": "a52424b13e3925c3a7a68f29cf946dc463d2c6cf6f119a023f7aa97d1fe892c3b"
      },
      "label": "Shifted bwa",
      "sbg:x": 992.677978515625,
      "sbg:y": 277.34375
    },
    {
      "id": "gatk_mutect2_non_shifted_mt",
      "in": [
        {
          "id": "in_alignments",
          "source": "bwa_mem_bundle/aligned_reads",
          "pickValue": "first_non_null"
        },
        {
          "id": "in_reference_and_index",
          "source": "in_reference_and_index_1"
        },
        {
          "id": "annotation",
          "default": [
            "StrandBiasBySample"
          ]
        },
        {
          "id": "annotation_group",
          "default": []
        },
        {
          "id": "annotations_to_exclude",
          "default": []
        },
        {
          "id": "mitochondria_mode",
          "default": true
        },
        {
          "id": "read_filter",
          "default": [
            "MateOnSameContigOrNoMappedMateReadFilter",
            "MateUnmappedAndUnmappedReadFilter"
          ]
        },
        {
          "id": "max_mnp_distance",
          "default": 0
        }
      ],
      "out": [
        {
          "id": "out_variants"
        },
        {
          "id": "out_alignments"
        },
        {
          "id": "f1r2_counts"
        },
        {
          "id": "out_stats"
        }
      ],
      "run": {
        "class": "CommandLineTool",
        "cwlVersion": "v1.2",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "id": "dave/build-mitochondria-pipeline/gatk-mutect2/5",
        "baseCommand": [
          "/opt/gatk"
        ],
        "inputs": [
          {
            "sbg:altPrefix": "-I",
            "sbg:category": "Required Arguments",
            "id": "in_alignments",
            "type": "File",
            "inputBinding": {
              "prefix": "--input",
              "shellQuote": false,
              "position": 3
            },
            "label": "Input",
            "doc": "BAM/SAM/CRAM file containing reads this argument must be specified at least once.",
            "sbg:fileTypes": "BAM",
            "secondaryFiles": [
              {
                "pattern": ".bai"
              }
            ]
          },
          {
            "sbg:altPrefix": "-O",
            "sbg:category": "Required Arguments",
            "id": "output_filename",
            "type": "string?",
            "label": "Output File Name",
            "doc": "File to which variants should be written."
          },
          {
            "sbg:altPrefix": "-R",
            "sbg:category": "Required Arguments",
            "id": "in_reference_and_index",
            "type": "File",
            "inputBinding": {
              "prefix": "--reference",
              "shellQuote": false,
              "position": 4
            },
            "label": "Reference FASTA and index",
            "doc": "Reference FASTA or FA sequence file and associated index and dict.",
            "sbg:fileTypes": "FASTA, FA",
            "secondaryFiles": [
              {
                "pattern": ".fai",
                "required": true
              },
              {
                "pattern": "^.dict",
                "required": true
              }
            ]
          },
          {
            "sbg:category": "Optional Tool Arguments",
            "sbg:toolDefaultValue": "null",
            "id": "activity_profile_out",
            "type": "string?",
            "inputBinding": {
              "prefix": "--activity-profile-out",
              "shellQuote": false,
              "position": 4
            },
            "label": "Activity profile out",
            "doc": "Output the raw activity profile results in igv format."
          },
          {
            "sbg:altPrefix": "-add-output-sam-program-record",
            "sbg:category": "Optional Common Arguments",
            "sbg:toolDefaultValue": "true",
            "id": "add_output_sam_program_record",
            "type": [
              "null",
              {
                "type": "enum",
                "symbols": [
                  "true",
                  "false"
                ],
                "name": "add_output_sam_program_record"
              }
            ],
            "inputBinding": {
              "prefix": "--add-output-sam-program-record",
              "shellQuote": false,
              "position": 4
            },
            "label": "Add output sam program record",
            "doc": "If true, adds a pg tag to created sam/bam/cram files."
          },
          {
            "sbg:altPrefix": "-add-output-vcf-command-line",
            "sbg:category": "Optional Common Arguments",
            "sbg:toolDefaultValue": "true",
            "id": "add_output_vcf_command_line",
            "type": [
              "null",
              {
                "type": "enum",
                "symbols": [
                  "true",
                  "false"
                ],
                "name": "add_output_vcf_command_line"
              }
            ],
            "inputBinding": {
              "prefix": "--add-output-vcf-command-line",
              "shellQuote": false,
              "position": 4
            },
            "label": "Add output vcf command line",
            "doc": "If true, adds a command line header line to created vcf files."
          },
          {
            "sbg:altPrefix": "-default-af",
            "sbg:category": "Optional Tool Arguments",
            "sbg:toolDefaultValue": "-1",
            "id": "af_of_alleles_not_in_resource",
            "type": "float?",
            "inputBinding": {
              "prefix": "--af-of-alleles-not-in-resource",
              "shellQuote": false,
              "position": 4
            },
            "label": "Af of alleles not in resource",
            "doc": "Population allele fraction assigned to alleles not found in germline resource. Please see docs/mutect/mutect2.pdf fora derivation of the default value. 0.\nPopulation allele fraction assigned to alleles not found in germline resource."
          },
          {
            "sbg:category": "Optional Tool Arguments",
            "sbg:toolDefaultValue": "null",
            "id": "alleles",
            "type": "File?",
            "inputBinding": {
              "prefix": "--alleles",
              "shellQuote": false,
              "position": 4
            },
            "label": "Alleles",
            "doc": "The set of alleles for which to force genotyping regardless of evidence.",
            "sbg:fileTypes": "VCF, VCF.GZ",
            "secondaryFiles": [
              {
                "pattern": "${\n    if (self.nameext == \".vcf\")\n    {\n        return self.basename + \".idx\";\n    }\n    else\n    {\n        return self.basename + \".tbi\";\n    }\n}"
              }
            ]
          },
          {
            "sbg:altPrefix": "-A",
            "sbg:category": "Optional Tool Arguments",
            "sbg:toolDefaultValue": "null",
            "id": "annotation",
            "type": [
              "null",
              {
                "type": "array",
                "items": {
                  "type": "enum",
                  "name": "annotation",
                  "symbols": [
                    "AlleleFraction",
                    "AS_BaseQualityRankSumTest",
                    "AS_FisherStrand",
                    "AS_InbreedingCoeff",
                    "AS_MappingQualityRankSumTest",
                    "AS_QualByDepth",
                    "AS_ReadPosRankSumTest",
                    "AS_RMSMappingQuality",
                    "AS_StrandOddsRatio",
                    "BaseQuality",
                    "BaseQualityRankSumTest",
                    "ChromosomeCounts",
                    "ClippingRankSumTest",
                    "CountNs",
                    "Coverage",
                    "DepthPerAlleleBySample",
                    "DepthPerSampleHC",
                    "ExcessHet",
                    "FisherStrand",
                    "FragmentLength",
                    "GenotypeSummaries",
                    "InbreedingCoeff",
                    "LikelihoodRankSumTest",
                    "MappingQuality",
                    "MappingQualityRankSumTest",
                    "MappingQualityZero",
                    "OrientationBiasReadCounts",
                    "OriginalAlignment",
                    "PossibleDeNovo",
                    "QualByDepth",
                    "ReadPosition",
                    "ReadPosRankSumTest",
                    "ReferenceBases",
                    "RMSMappingQuality",
                    "SampleList",
                    "StrandBiasBySample",
                    "StrandOddsRatio",
                    "TandemRepeat",
                    "UniqueAltReadCount"
                  ]
                }
              }
            ],
            "inputBinding": {
              "prefix": "",
              "itemSeparator": " ",
              "shellQuote": false,
              "position": 4,
              "valueFrom": "${\n    var output = \"\";\n    for (var i=0; i<inputs.annotation.length; i++)\n    {\n        output = output + \"--annotation \" + inputs.annotation[i] + \" \";\n    }\n    return output;\n}"
            },
            "label": "Annotation",
            "doc": "One or more specific annotations to add to variant calls."
          },
          {
            "sbg:altPrefix": "-G",
            "sbg:category": "Optional Tool Arguments",
            "sbg:toolDefaultValue": "null",
            "id": "annotation_group",
            "type": [
              "null",
              {
                "type": "array",
                "items": {
                  "type": "enum",
                  "name": "annotation_group",
                  "symbols": [
                    "AS_StandardAnnotation",
                    "ReducibleAnnotation",
                    "StandardAnnotation",
                    "StandardHCAnnotation",
                    "StandardMutectAnnotation"
                  ]
                }
              }
            ],
            "inputBinding": {
              "prefix": "",
              "shellQuote": false,
              "position": 4,
              "valueFrom": "${\n    var output = \"\";\n    for (var i=0; i<inputs.annotation_group.length; i++)\n    {\n        output = output + \"--annotation-group \" + inputs.annotation_group[i] + \" \";\n    }\n    return output;\n}"
            },
            "label": "Annotation group",
            "doc": "One or more groups of annotations to apply to variant calls."
          },
          {
            "sbg:altPrefix": "-AX",
            "sbg:category": "Optional Tool Arguments",
            "sbg:toolDefaultValue": "null",
            "id": "annotations_to_exclude",
            "type": [
              "null",
              {
                "type": "array",
                "items": {
                  "type": "enum",
                  "name": "annotations_to_exclude",
                  "symbols": [
                    "BaseQuality",
                    "Coverage",
                    "DepthPerAlleleBySample",
                    "DepthPerSampleHC",
                    "FragmentLength",
                    "MappingQuality",
                    "OrientationBiasReadCounts",
                    "ReadPosition",
                    "StrandBiasBySample",
                    "TandemRepeat"
                  ]
                }
              }
            ],
            "inputBinding": {
              "prefix": "",
              "shellQuote": false,
              "position": 4,
              "valueFrom": "${\n    var output = \"\";\n    for (var i=0; i<inputs.annotations_to_exclude.length; i++)\n    {\n        output = output + \"--annotations-to-exclude \" + inputs.annotations_to_exclude[i] + \" \";\n    }\n    return output;\n}"
            },
            "label": "Annotations to exclude",
            "doc": "One or more specific annotations to exclude from variant calls."
          },
          {
            "sbg:category": "Optional Tool Arguments",
            "sbg:toolDefaultValue": "null",
            "id": "arguments_file",
            "type": "File[]?",
            "inputBinding": {
              "prefix": "",
              "shellQuote": false,
              "position": 4,
              "valueFrom": "${\n    var output = \"\";\n    for (var i=0; i<inputs.arguments_file.length; i++)\n    {\n        output = output + \"--arguments_file \" + inputs.arguments_file[i].path + \" \";\n    }\n    return output;\n}"
            },
            "label": "Arguments file",
            "doc": "Read one or more arguments files and add them to the command line."
          },
          {
            "sbg:category": "Optional Tool Arguments",
            "sbg:toolDefaultValue": "null",
            "id": "assembly_region_out",
            "type": "string?",
            "inputBinding": {
              "prefix": "--assembly-region-out",
              "shellQuote": false,
              "position": 4
            },
            "label": "Assembly region out",
            "doc": "Output the assembly region to this igv formatted file."
          },
          {
            "sbg:category": "Optional Tool Arguments",
            "sbg:toolDefaultValue": "18",
            "id": "base_quality_score_threshold",
            "type": "int?",
            "inputBinding": {
              "prefix": "--base-quality-score-threshold",
              "shellQuote": false,
              "position": 4
            },
            "label": "Base quality score threshold",
            "doc": "Base qualities below this threshold will be reduced to the minimum (6)."
          },
          {
            "sbg:category": "Optional Tool Arguments",
            "sbg:toolDefaultValue": "10",
            "id": "callable_depth",
            "type": "int?",
            "inputBinding": {
              "prefix": "--callable-depth",
              "shellQuote": false,
              "position": 4
            },
            "label": "Callable depth",
            "doc": "Minimum depth to be considered callable for mutect stats. Does not affect genotyping."
          },
          {
            "sbg:altPrefix": "-CIPB",
            "sbg:category": "Optional Tool Arguments",
            "sbg:toolDefaultValue": "-1",
            "id": "cloud_index_prefetch_buffer",
            "type": "int?",
            "inputBinding": {
              "prefix": "--cloud-index-prefetch-buffer",
              "shellQuote": false,
              "position": 4
            },
            "label": "Cloud index prefetch buffer",
            "doc": "Size of the cloud-only prefetch buffer (in mb; 0 to disable). Defaults to cloudprefetchbuffer if unset."
          },
          {
            "sbg:altPrefix": "-CPB",
            "sbg:category": "Optional Tool Arguments",
            "sbg:toolDefaultValue": "40",
            "id": "cloud_prefetch_buffer",
            "type": "int?",
            "inputBinding": {
              "prefix": "--cloud-prefetch-buffer",
              "shellQuote": false,
              "position": 4
            },
            "label": "Cloud prefetch buffer",
            "doc": "Size of the cloud-only prefetch buffer (in mb; 0 to disable)."
          },
          {
            "sbg:altPrefix": "-OBI",
            "sbg:category": "Optional Common Arguments",
            "sbg:toolDefaultValue": "true",
            "id": "create_output_bam_index",
            "type": "boolean?",
            "inputBinding": {
              "prefix": "--create-output-bam-index",
              "shellQuote": false,
              "position": 4
            },
            "label": "Create output bam index",
            "doc": "If true, create a bam/cram index when writing a coordinate-sorted bam/cram file."
          },
          {
            "sbg:altPrefix": "-OBM",
            "sbg:category": "Optional Common Arguments",
            "sbg:toolDefaultValue": "false",
            "id": "create_output_bam_md5",
            "type": "boolean?",
            "inputBinding": {
              "prefix": "--create-output-bam-md5",
              "shellQuote": false,
              "position": 4
            },
            "label": "Create output bam md5",
            "doc": "If true, create a md5 digest for any BAM/SAM/CRAM file created."
          },
          {
            "sbg:altPrefix": "-OVI",
            "sbg:category": "Optional Common Arguments",
            "sbg:toolDefaultValue": "true",
            "id": "create_output_variant_index",
            "type": "boolean?",
            "inputBinding": {
              "prefix": "--create-output-variant-index",
              "shellQuote": false,
              "position": 4
            },
            "label": "Create output variant index",
            "doc": "If true, create a vcf index when writing a coordinate-sorted vcf file."
          },
          {
            "sbg:altPrefix": "-OVM",
            "sbg:category": "Optional Common Arguments",
            "sbg:toolDefaultValue": "false",
            "id": "create_output_variant_md5",
            "type": "boolean?",
            "inputBinding": {
              "prefix": "--create-output-variant-md5",
              "shellQuote": false,
              "position": 4
            },
            "label": "Create output variant md5",
            "doc": "If true, create a a md5 digest any vcf file created."
          },
          {
            "sbg:altPrefix": "-DBIC",
            "sbg:category": "Optional Tool Arguments",
            "sbg:toolDefaultValue": "false",
            "id": "disable_bam_index_caching",
            "type": "boolean?",
            "inputBinding": {
              "prefix": "--disable-bam-index-caching",
              "shellQuote": false,
              "position": 4
            },
            "label": "Disable bam index caching",
            "doc": "If true, don't cache bam indexes, this will reduce memory requirements but may harm performance if many intervals are specified. Caching is automatically disabled if there are no intervals specified."
          },
          {
            "sbg:altPrefix": "-DF",
            "sbg:category": "Optional Common Arguments",
            "sbg:toolDefaultValue": "null",
            "id": "disable_read_filter",
            "type": [
              "null",
              {
                "type": "array",
                "items": {
                  "type": "enum",
                  "name": "disable_read_filter",
                  "symbols": [
                    "GoodCigarReadFilter",
                    "MappedReadFilter",
                    "MappingQualityAvailableReadFilter",
                    "MappingQualityNotZeroReadFilter",
                    "MappingQualityReadFilter",
                    "NonChimericOriginalAlignmentReadFilter",
                    "NonZeroReferenceLengthAlignmentReadFilter",
                    "NotDuplicateReadFilter",
                    "NotSecondaryAlignmentReadFilter",
                    "PassesVendorQualityCheckReadFilter",
                    "ReadLengthReadFilter",
                    "WellformedReadFilter"
                  ]
                }
              }
            ],
            "inputBinding": {
              "prefix": "",
              "shellQuote": false,
              "position": 4,
              "valueFrom": "${\n    var output = \"\";\n    for (var i=0; i<inputs.disable_read_filter.length; i++)\n    {\n        output = output + \"--disable-read-filter \" + inputs.disable_read_filter[i] + \" \";\n    }\n    return output;\n}"
            },
            "label": "Disable read filter",
            "doc": "Read filters to be disabled before analysis."
          },
          {
            "sbg:altPrefix": "-disable-sequence-dictionary-validation",
            "sbg:category": "Optional Tool Arguments",
            "sbg:toolDefaultValue": "false",
            "id": "disable_sequence_dictionary_validation",
            "type": "boolean?",
            "inputBinding": {
              "prefix": "--disable-sequence-dictionary-validation",
              "shellQuote": false,
              "position": 4
            },
            "label": "Disable sequence dictionary validation",
            "doc": "If specified, do not check the sequence dictionaries from our inputs for compatibility. Use at your own risk!"
          },
          {
            "sbg:altPrefix": "-stride",
            "sbg:category": "Optional Tool Arguments",
            "sbg:toolDefaultValue": "1",
            "id": "downsampling_stride",
            "type": "int?",
            "inputBinding": {
              "prefix": "--downsampling-stride",
              "shellQuote": false,
              "position": 4
            },
            "label": "Downsampling stride",
            "doc": "Downsample a pool of reads starting within a range of one or more bases."
          },
          {
            "sbg:altPrefix": "-XL",
            "sbg:category": "Optional Common Arguments",
            "sbg:toolDefaultValue": "null",
            "id": "exclude_intervals",
            "type": "string[]?",
            "inputBinding": {
              "prefix": "",
              "shellQuote": false,
              "position": 4,
              "valueFrom": "${\n    var output = \"\";\n    for (var i=0; i<inputs.exclude_intervals.length; i++)\n    {\n        output = output + \"--exclude-intervals \" + inputs.exclude_intervals[i] + \" \";\n    }\n    return output;\n}"
            },
            "label": "Exclude intervals",
            "doc": "Or more genomic intervals to exclude from processing."
          },
          {
            "sbg:category": "Optional Tool Arguments",
            "sbg:toolDefaultValue": "200",
            "id": "f1r2_max_depth",
            "type": "int?",
            "inputBinding": {
              "prefix": "--f1r2-max-depth",
              "shellQuote": false,
              "position": 4
            },
            "label": "F1r2 max depth",
            "doc": "Sites with depth higher than this value will be grouped."
          },
          {
            "sbg:category": "Optional Tool Arguments",
            "sbg:toolDefaultValue": "50",
            "id": "f1r2_median_mq",
            "type": "int?",
            "inputBinding": {
              "prefix": "--f1r2-median-mq",
              "shellQuote": false,
              "position": 4
            },
            "label": "F1r2 median mq",
            "doc": "Skip sites with median mapping quality below this value."
          },
          {
            "sbg:category": "Optional Tool Arguments",
            "sbg:toolDefaultValue": "20",
            "id": "f1r2_min_bq",
            "type": "int?",
            "inputBinding": {
              "prefix": "--f1r2-min-bq",
              "shellQuote": false,
              "position": 4
            },
            "label": "F1r2 min bq",
            "doc": "Exclude bases below this quality from pileup."
          },
          {
            "sbg:category": "Optional Tool Arguments",
            "sbg:toolDefaultValue": "null",
            "id": "f1r2_tar_gz",
            "type": "string?",
            "label": "F1r2 filename",
            "doc": "If specified, collect f1r2 counts and output files into this tar.gz file."
          },
          {
            "sbg:altPrefix": "-founder-id",
            "sbg:category": "Optional Tool Arguments",
            "sbg:toolDefaultValue": "null",
            "id": "founder_id",
            "type": "string[]?",
            "inputBinding": {
              "prefix": "",
              "shellQuote": false,
              "position": 4,
              "valueFrom": "${\n    var output = \"\";\n    for (var i=0; i<inputs.founder_id.length; i++)\n    {\n        output = output + \"--founder-id \" + inputs.founder_id[i] + \" \";\n    }\n    return output;\n}"
            },
            "label": "Founder id",
            "doc": "Samples representing the population \"founders\"."
          },
          {
            "sbg:category": "Optional Common Arguments",
            "sbg:toolDefaultValue": "null",
            "id": "gatk_config_file",
            "type": "File?",
            "inputBinding": {
              "prefix": "--gatk-config-file",
              "shellQuote": false,
              "position": 4
            },
            "label": "Gatk config file",
            "doc": "A configuration file to use with the gatk."
          },
          {
            "sbg:altPrefix": "-gcs-retries",
            "sbg:category": "Optional Tool Arguments",
            "sbg:toolDefaultValue": "20",
            "id": "gcs_max_retries",
            "type": "int?",
            "inputBinding": {
              "prefix": "--gcs-max-retries",
              "shellQuote": false,
              "position": 4
            },
            "label": "Gcs max retries",
            "doc": "If the gcs bucket channel errors out, how many times it will attempt to re-initiate the connection."
          },
          {
            "sbg:category": "Optional Tool Arguments",
            "id": "gcs_project_for_requester_pays",
            "type": "string?",
            "inputBinding": {
              "prefix": "--gcs-project-for-requester-pays",
              "shellQuote": false,
              "position": 4
            },
            "label": "Gcs project for requester pays",
            "doc": "Project to bill when accessing \"requester pays\" buckets. If unset, these buckets cannot be accessed. Default value: ."
          },
          {
            "sbg:category": "Optional Tool Arguments",
            "sbg:toolDefaultValue": "false",
            "id": "genotype_germline_sites",
            "type": "boolean?",
            "inputBinding": {
              "prefix": "--genotype-germline-sites",
              "shellQuote": false,
              "position": 4
            },
            "label": "Genotype germline sites",
            "doc": "(experimental) call all apparent germline site even though they will ultimately be filtered."
          },
          {
            "sbg:category": "Optional Tool Arguments",
            "sbg:toolDefaultValue": "false",
            "id": "genotype_pon_sites",
            "type": "boolean?",
            "inputBinding": {
              "prefix": "--genotype-pon-sites",
              "shellQuote": false,
              "position": 4
            },
            "label": "Genotype pon sites",
            "doc": "Call sites in the pon even though they will ultimately be filtered."
          },
          {
            "sbg:category": "Optional Tool Arguments",
            "sbg:toolDefaultValue": "null",
            "id": "germline_resource",
            "type": "File?",
            "inputBinding": {
              "prefix": "--germline-resource",
              "shellQuote": false,
              "position": 4
            },
            "label": "Germline resource",
            "doc": "Population vcf of germline sequencing containing allele fractions. (typically gNOMAD)",
            "sbg:fileTypes": "VCF, VCF.GZ",
            "secondaryFiles": [
              {
                "pattern": "${\n    if (self.nameext == \".vcf\")\n    {\n        return self.basename + \".idx\";\n    }\n    else\n    {\n        return self.basename + \".tbi\";\n    }\n}"
              }
            ]
          },
          {
            "sbg:altPrefix": "-graph",
            "sbg:category": "Optional Tool Arguments",
            "sbg:toolDefaultValue": "null",
            "id": "graph_output",
            "type": "string?",
            "inputBinding": {
              "prefix": "--graph-output",
              "shellQuote": false,
              "position": 4
            },
            "label": "Graph output",
            "doc": "Write debug assembly graph information to this file."
          },
          {
            "sbg:category": "Optional Tool Arguments",
            "sbg:toolDefaultValue": "false",
            "id": "ignore_itr_artifacts",
            "type": "boolean?",
            "inputBinding": {
              "prefix": "--ignore-itr-artifacts",
              "shellQuote": false,
              "position": 4
            },
            "label": "Ignore itr artifacts",
            "doc": "Off read transformer that clips artifacts associated with end repair insertions near inverted tandem repeats."
          },
          {
            "sbg:altPrefix": "-init-lod",
            "sbg:category": "Optional Tool Arguments",
            "sbg:toolDefaultValue": "2.0",
            "id": "initial_tumor_lod",
            "type": "float?",
            "inputBinding": {
              "prefix": "--initial-tumor-lod",
              "shellQuote": false,
              "position": 4
            },
            "label": "Initial tumor lod",
            "doc": "Log 10 odds threshold to consider pileup active. 0."
          },
          {
            "sbg:altPrefix": "-ixp",
            "sbg:category": "Optional Common Arguments",
            "sbg:toolDefaultValue": "0",
            "id": "interval_exclusion_padding",
            "type": "int?",
            "inputBinding": {
              "prefix": "--interval-exclusion-padding",
              "shellQuote": false,
              "position": 4
            },
            "label": "Interval exclusion padding",
            "doc": "Amount of padding (in bp) to add to each interval you are excluding."
          },
          {
            "sbg:altPrefix": "-imr",
            "sbg:category": "Optional Tool Arguments",
            "sbg:toolDefaultValue": "ALL",
            "id": "interval_merging_rule",
            "type": [
              "null",
              {
                "type": "enum",
                "symbols": [
                  "ALL",
                  "OVERLAPPING_ONLY"
                ],
                "name": "interval_merging_rule"
              }
            ],
            "inputBinding": {
              "prefix": "--interval-merging-rule",
              "shellQuote": false,
              "position": 4
            },
            "label": "Interval merging rule",
            "doc": "Interval merging rule for abutting intervals."
          },
          {
            "sbg:altPrefix": "-ip",
            "sbg:category": "Optional Common Arguments",
            "sbg:toolDefaultValue": "0",
            "id": "interval_padding",
            "type": "int?",
            "inputBinding": {
              "prefix": "--interval-padding",
              "shellQuote": false,
              "position": 4
            },
            "label": "Interval padding",
            "doc": "Of padding (in bp) to add to each interval you are including."
          },
          {
            "sbg:altPrefix": "-isr",
            "sbg:category": "Optional Common Arguments",
            "sbg:toolDefaultValue": "UNION",
            "id": "interval_set_rule",
            "type": [
              "null",
              {
                "type": "enum",
                "symbols": [
                  "UNION",
                  "INTERSECTION"
                ],
                "name": "interval_set_rule"
              }
            ],
            "inputBinding": {
              "prefix": "--interval-set-rule",
              "shellQuote": false,
              "position": 4
            },
            "label": "Interval set rule",
            "doc": "Set merging approach to use for combining interval inputs."
          },
          {
            "sbg:altPrefix": "-L",
            "sbg:category": "Optional Tool Arguments",
            "sbg:toolDefaultValue": "null",
            "id": "intervals",
            "type": "string[]?",
            "inputBinding": {
              "prefix": "",
              "shellQuote": false,
              "position": 4,
              "valueFrom": "${\n    var output = \"\";\n    for (var i=0; i<inputs.intervals.length; i++){\n        output += \" --intervals \" + inputs.intervals[i];\n    }\n    return output;\n}"
            },
            "label": "Intervals",
            "doc": "One or more genomic intervals over which to operate."
          },
          {
            "sbg:altPrefix": "-LE",
            "sbg:category": "Optional Common Arguments",
            "sbg:toolDefaultValue": "false",
            "id": "lenient",
            "type": "boolean?",
            "inputBinding": {
              "prefix": "--lenient",
              "shellQuote": false,
              "position": 4
            },
            "label": "Lenient",
            "doc": "Lenient processing of vcf files."
          },
          {
            "sbg:altPrefix": "-max-af",
            "sbg:category": "Optional Tool Arguments",
            "sbg:toolDefaultValue": "0.01",
            "id": "max_population_af",
            "type": "float?",
            "inputBinding": {
              "prefix": "--max-population-af",
              "shellQuote": false,
              "position": 4
            },
            "label": "Max population af",
            "doc": "Maximum population allele frequency in tumor-only mode. 01."
          },
          {
            "sbg:category": "Optional Tool Arguments",
            "sbg:toolDefaultValue": "50",
            "id": "max_reads_per_alignment_start",
            "type": "int?",
            "inputBinding": {
              "prefix": "--max-reads-per-alignment-start",
              "shellQuote": false,
              "position": 4
            },
            "label": "Max reads per alignment start",
            "doc": "Maximum number of reads to retain per alignment start position. Reads above this threshold will be downsampled. Set to 0 to disable."
          },
          {
            "sbg:altPrefix": "-mbq",
            "sbg:category": "Optional Tool Arguments",
            "sbg:toolDefaultValue": "10",
            "id": "min_base_quality_score",
            "type": "string?",
            "inputBinding": {
              "prefix": "--min-base-quality-score",
              "shellQuote": false,
              "position": 4
            },
            "label": "Min base quality score",
            "doc": "Minimum base quality required to consider a base for calling."
          },
          {
            "sbg:category": "Optional Tool Arguments",
            "sbg:toolDefaultValue": "false",
            "id": "mitochondria_mode",
            "type": "boolean?",
            "inputBinding": {
              "prefix": "--mitochondria-mode",
              "shellQuote": false,
              "position": 4
            },
            "label": "Mitochondria mode",
            "doc": "Mitochondria mode sets emission and initial lods to 0."
          },
          {
            "sbg:category": "Optional Tool Arguments",
            "sbg:toolDefaultValue": "4",
            "id": "native_pair_hmm_threads",
            "type": "int?",
            "inputBinding": {
              "prefix": "--native-pair-hmm-threads",
              "shellQuote": false,
              "position": 4
            },
            "label": "Native pair hmm threads",
            "doc": "How many threads should a native pairhmm implementation use."
          },
          {
            "sbg:category": "Optional Tool Arguments",
            "sbg:toolDefaultValue": "false",
            "id": "native_pair_hmm_use_double_precision",
            "type": "boolean?",
            "inputBinding": {
              "prefix": "--native-pair-hmm-use-double-precision",
              "shellQuote": false,
              "position": 4
            },
            "label": "Native pair hmm use double precision",
            "doc": "Use double precision in the native pairhmm. This is slower but matches the java implementation better."
          },
          {
            "sbg:category": "Optional Tool Arguments",
            "sbg:toolDefaultValue": "2.2",
            "id": "normal_lod",
            "type": "float?",
            "inputBinding": {
              "prefix": "--normal-lod",
              "shellQuote": false,
              "position": 4
            },
            "label": "Normal lod",
            "doc": "Log 10 odds threshold for calling normal variant non-germline. 2."
          },
          {
            "sbg:altPrefix": "-normal",
            "sbg:category": "Optional Tool Arguments",
            "sbg:toolDefaultValue": "null",
            "id": "normal_sample",
            "type": [
              "null",
              {
                "type": "array",
                "items": [
                  "string",
                  "null"
                ]
              }
            ],
            "inputBinding": {
              "shellQuote": false,
              "position": 4,
              "valueFrom": "${\n    var output = \"\";\n    var normal_samples = [].concat(self);\n    for (var i=0; i<normal_samples.length; i++)\n    {\n        if (normal_samples[i])\n        {\n            output = output + '--normal-sample \"' \n                    + normal_samples[i] + '\" ';   \n        }\n    }\n    return output;\n}"
            },
            "label": "Normal sample",
            "doc": "Sample name of normal(s), if any. May be url-encoded as output by getsamplename with -encode argument."
          },
          {
            "sbg:altPrefix": "-pon",
            "sbg:category": "Optional Tool Arguments",
            "sbg:toolDefaultValue": "null",
            "id": "panel_of_normals",
            "type": "File?",
            "inputBinding": {
              "prefix": "--panel-of-normals",
              "shellQuote": false,
              "position": 4
            },
            "label": "Panel of normals",
            "doc": "Vcf file of sites observed in normal.",
            "sbg:fileTypes": "VCF, VCF.GZ",
            "secondaryFiles": [
              {
                "pattern": "${\n    if (self.nameext == \".vcf\")\n    {\n        return self.basename + \".idx\";\n    }\n    else\n    {\n        return self.basename + \".tbi\";\n    }\n}"
              }
            ]
          },
          {
            "sbg:category": "Optional Tool Arguments",
            "sbg:toolDefaultValue": "40",
            "id": "pcr_indel_qual",
            "type": "int?",
            "inputBinding": {
              "prefix": "--pcr-indel-qual",
              "shellQuote": false,
              "position": 4
            },
            "label": "Pcr indel qual",
            "doc": "Phred-scaled pcr snv qual for overlapping fragments."
          },
          {
            "sbg:category": "Optional Tool Arguments",
            "sbg:toolDefaultValue": "40",
            "id": "pcr_snv_qual",
            "type": "int?",
            "inputBinding": {
              "prefix": "--pcr-snv-qual",
              "shellQuote": false,
              "position": 4
            },
            "label": "Pcr snv qual",
            "doc": "Phred-scaled pcr snv qual for overlapping fragments."
          },
          {
            "sbg:altPrefix": "-ped",
            "sbg:category": "Optional Tool Arguments",
            "sbg:toolDefaultValue": "null",
            "id": "pedigree",
            "type": "File?",
            "inputBinding": {
              "prefix": "--pedigree",
              "shellQuote": false,
              "position": 4
            },
            "label": "Pedigree",
            "doc": "Pedigree file for determining the population \"founders\"."
          },
          {
            "sbg:altPrefix": "-RF",
            "sbg:category": "Optional Common Arguments",
            "sbg:toolDefaultValue": "null",
            "id": "read_filter",
            "type": [
              "null",
              {
                "type": "array",
                "items": {
                  "type": "enum",
                  "name": "read_filter",
                  "symbols": [
                    "AlignmentAgreesWithHeaderReadFilter",
                    "AllowAllReadsReadFilter",
                    "AmbiguousBaseReadFilter",
                    "CigarContainsNoNOperator",
                    "FirstOfPairReadFilter",
                    "FragmentLengthReadFilter",
                    "GoodCigarReadFilter",
                    "HasReadGroupReadFilter",
                    "IntervalOverlapReadFilter",
                    "LibraryReadFilter",
                    "MappedReadFilter",
                    "MappingQualityAvailableReadFilter",
                    "MappingQualityNotZeroReadFilter",
                    "MappingQualityReadFilter",
                    "MatchingBasesAndQualsReadFilter",
                    "MateDifferentStrandReadFilter",
                    "MateOnSameContigOrNoMappedMateReadFilter",
                    "MateUnmappedAndUnmappedReadFilter",
                    "MetricsReadFilter",
                    "NonChimericOriginalAlignmentReadFilter",
                    "NonZeroFragmentLengthReadFilter",
                    "NonZeroReferenceLengthAlignmentReadFilter",
                    "NotDuplicateReadFilter",
                    "NotOpticalDuplicateReadFilter",
                    "NotSecondaryAlignmentReadFilter",
                    "NotSupplementaryAlignmentReadFilter",
                    "OverclippedReadFilter",
                    "PairedReadFilter",
                    "PassesVendorQualityCheckReadFilter",
                    "PlatformReadFilter",
                    "PlatformUnitReadFilter",
                    "PrimaryLineReadFilter",
                    "ProperlyPairedReadFilter",
                    "ReadGroupBlackListReadFilter",
                    "ReadGroupReadFilter",
                    "ReadLengthEqualsCigarLengthReadFilter",
                    "ReadLengthReadFilter",
                    "ReadNameReadFilter",
                    "ReadStrandFilter",
                    "SampleReadFilter",
                    "SecondOfPairReadFilter",
                    "SeqIsStoredReadFilter",
                    "ValidAlignmentEndReadFilter",
                    "ValidAlignmentStartReadFilter",
                    "WellformedReadFilter"
                  ]
                }
              }
            ],
            "inputBinding": {
              "prefix": "",
              "shellQuote": false,
              "position": 4,
              "valueFrom": "${\n    var output = \"\";\n    for (var i=0; i<inputs.read_filter.length; i++)\n    {\n        output = output + \"--read-filter \" + inputs.read_filter[i] + \" \";\n    }\n    return output;\n}"
            },
            "label": "Read filter",
            "doc": "Read filters to be applied before analysis."
          },
          {
            "sbg:altPrefix": "-read-index",
            "sbg:category": "Optional Common Arguments",
            "sbg:toolDefaultValue": "null",
            "id": "read_index",
            "type": "File[]?",
            "inputBinding": {
              "prefix": "--read-index",
              "shellQuote": false,
              "position": 4,
              "valueFrom": "${\n    var output = \"\";\n    for (var i=0; i<inputs.read_index.length; i++)\n    {\n        output = output + \"--read-index \" + inputs.read_index[i].path + \" \";\n    }\n    return output;\n}"
            },
            "label": "Read index",
            "doc": "Indices to use for the read inputs. If specified, an index must be provided for every read input and in the same order as the read inputs. If this argument is not specified, the path to the index for each input will be inferred automatically."
          },
          {
            "sbg:altPrefix": "-VS",
            "sbg:category": "Optional Common Arguments",
            "sbg:toolDefaultValue": "SILENT",
            "id": "read_validation_stringency",
            "type": [
              "null",
              {
                "type": "enum",
                "symbols": [
                  "STRICT",
                  "LENIENT",
                  "SILENT"
                ],
                "name": "read_validation_stringency"
              }
            ],
            "inputBinding": {
              "prefix": "--read-validation-stringency",
              "shellQuote": false,
              "position": 4
            },
            "label": "Read validation stringency",
            "doc": "Validation stringency for all sam/bam/cram/sra files read by this program. The default stringency value silent can improve performance when processing a bam file in which variable-length data (read, qualities, tags) do not otherwise need to be decoded."
          },
          {
            "sbg:altPrefix": "-seconds-between-progress-updates",
            "sbg:category": "Optional Common Arguments",
            "sbg:toolDefaultValue": "10.0",
            "id": "seconds_between_progress_updates",
            "type": "float?",
            "inputBinding": {
              "prefix": "--seconds-between-progress-updates",
              "shellQuote": false,
              "position": 4
            },
            "label": "Seconds between progress updates",
            "doc": "Output traversal statistics every time this many seconds elapse 0."
          },
          {
            "sbg:altPrefix": "-sequence-dictionary",
            "sbg:category": "Optional Common Arguments",
            "sbg:toolDefaultValue": "null",
            "id": "sequence_dictionary",
            "type": "File?",
            "inputBinding": {
              "prefix": "--sequence-dictionary",
              "shellQuote": false,
              "position": 4,
              "valueFrom": "${\n    if (self){\n        self = [].concat(self)[0];\n        if (self.nameext != \".dict\" && self.secondaryFiles && self.secondaryFiles[0]){\n            for (var i = 0; i < self.secondaryFiles.length; i ++){\n                if (self.secondaryFiles[i].nameext == '.dict'){\n                    return self.secondaryFiles[i].path;\n                }\n            }\n        }\n        return self.path;\n    } else {\n        return null;\n    }\n}"
            },
            "label": "Sequence dictionary",
            "doc": "Use the given sequence dictionary as the master/canonical sequence dictionary. Must be a .dict file.",
            "sbg:fileTypes": "DICT"
          },
          {
            "sbg:category": "Optional Tool Arguments",
            "sbg:toolDefaultValue": "false",
            "id": "sites_only_vcf_output",
            "type": "boolean?",
            "inputBinding": {
              "prefix": "--sites-only-vcf-output",
              "shellQuote": false,
              "position": 4
            },
            "label": "Sites only vcf output",
            "doc": "If true, don't emit genotype fields when writing vcf file output."
          },
          {
            "sbg:altPrefix": "-emit-lod",
            "sbg:category": "Optional Tool Arguments",
            "sbg:toolDefaultValue": "3,0",
            "id": "tumor_lod_to_emit",
            "type": "float?",
            "inputBinding": {
              "prefix": "--tumor-lod-to-emit",
              "shellQuote": false,
              "position": 4
            },
            "label": "Tumor lod to emit",
            "doc": "Log 10 odds threshold to emit variant to vcf. 0."
          },
          {
            "sbg:altPrefix": "-tumor",
            "sbg:category": "Deprecated Arguments",
            "sbg:toolDefaultValue": "null",
            "id": "tumor_sample",
            "type": "string?",
            "inputBinding": {
              "prefix": "--tumor-sample",
              "shellQuote": false,
              "position": 4,
              "valueFrom": "${\n    return '\"' + self + '\"';\n}"
            },
            "label": "Tumor sample",
            "doc": "Bam sample name of tumor. May be url-encoded as output by getsamplename with -encode argument."
          },
          {
            "sbg:altPrefix": "-jdk-deflater",
            "sbg:category": "Optional Common Arguments",
            "sbg:toolDefaultValue": "false",
            "id": "use_jdk_deflater",
            "type": "boolean?",
            "inputBinding": {
              "prefix": "--use-jdk-deflater",
              "shellQuote": false,
              "position": 4
            },
            "label": "Use jdk deflater",
            "doc": "Whether to use the jdkdeflater (as opposed to inteldeflater)."
          },
          {
            "sbg:altPrefix": "-jdk-inflater",
            "sbg:category": "Optional Common Arguments",
            "sbg:toolDefaultValue": "false",
            "id": "use_jdk_inflater",
            "type": "boolean?",
            "inputBinding": {
              "prefix": "--use-jdk-inflater",
              "shellQuote": false,
              "position": 4
            },
            "label": "Use jdk inflater",
            "doc": "Whether to use the jdkinflater (as opposed to intelinflater)."
          },
          {
            "sbg:altPrefix": "-verbosity",
            "sbg:category": "Optional Common Arguments",
            "sbg:toolDefaultValue": "INFO",
            "id": "verbosity",
            "type": [
              "null",
              {
                "type": "enum",
                "symbols": [
                  "ERROR",
                  "WARNING",
                  "INFO",
                  "DEBUG"
                ],
                "name": "verbosity"
              }
            ],
            "inputBinding": {
              "prefix": "--verbosity",
              "shellQuote": false,
              "position": 4
            },
            "label": "Verbosity",
            "doc": "Control verbosity of logging."
          },
          {
            "sbg:category": "Advanced Arguments",
            "sbg:toolDefaultValue": "0",
            "id": "active_probability_threshold",
            "type": "float?",
            "inputBinding": {
              "prefix": "--active-probability-threshold",
              "shellQuote": false,
              "position": 4
            },
            "label": "Active probability threshold",
            "doc": "Minimum probability for a locus to be considered active. 002."
          },
          {
            "sbg:category": "Advanced Arguments",
            "sbg:toolDefaultValue": "0",
            "id": "adaptive_pruning_initial_error_rate",
            "type": "float?",
            "inputBinding": {
              "prefix": "--adaptive-pruning-initial-error-rate",
              "shellQuote": false,
              "position": 4
            },
            "label": "Adaptive pruning initial error rate",
            "doc": "Initial base error rate estimate for adaptive pruning 001."
          },
          {
            "sbg:category": "Advanced Arguments",
            "sbg:toolDefaultValue": "false",
            "id": "allow_non_unique_kmers_in_ref",
            "type": "boolean?",
            "inputBinding": {
              "prefix": "--allow-non-unique-kmers-in-ref",
              "shellQuote": false,
              "position": 4
            },
            "label": "Allow non unique kmers in ref",
            "doc": "Allow graphs that have non-unique kmers in the reference."
          },
          {
            "sbg:category": "Advanced Arguments",
            "sbg:toolDefaultValue": "100",
            "id": "assembly_region_padding",
            "type": "int?",
            "inputBinding": {
              "prefix": "--assembly-region-padding",
              "shellQuote": false,
              "position": 4
            },
            "label": "Assembly region padding",
            "doc": "Number of additional bases of context to include around each assembly region."
          },
          {
            "sbg:category": "Advanced Arguments",
            "sbg:toolDefaultValue": "CALLED_HAPLOTYPES",
            "id": "bam_writer_type",
            "type": [
              "null",
              {
                "type": "enum",
                "symbols": [
                  "ALL_POSSIBLE_HAPLOTYPES",
                  "CALLED_HAPLOTYPES"
                ],
                "name": "bam_writer_type"
              }
            ],
            "inputBinding": {
              "prefix": "--bam-writer-type",
              "shellQuote": false,
              "position": 4
            },
            "label": "Bam writer type",
            "doc": "Which haplotypes should be written to the bam."
          },
          {
            "sbg:altPrefix": "-debug",
            "sbg:category": "Advanced Arguments",
            "sbg:toolDefaultValue": "false",
            "id": "debug_assembly",
            "type": "boolean?",
            "inputBinding": {
              "prefix": "--debug-assembly",
              "shellQuote": false,
              "position": 4
            },
            "label": "Debug assembly",
            "doc": "Print out verbose debug information about each assembly region."
          },
          {
            "sbg:category": "Advanced Arguments",
            "sbg:toolDefaultValue": "false",
            "id": "disable_adaptive_pruning",
            "type": "boolean?",
            "inputBinding": {
              "prefix": "--disable-adaptive-pruning",
              "shellQuote": false,
              "position": 4
            },
            "label": "Disable adaptive pruning",
            "doc": "Disable the adaptive algorithm for pruning paths in the graph."
          },
          {
            "sbg:altPrefix": "-disable-tool-default-annotations",
            "sbg:category": "Advanced Arguments",
            "sbg:toolDefaultValue": "false",
            "id": "disable_tool_default_annotations",
            "type": "boolean?",
            "inputBinding": {
              "prefix": "--disable-tool-default-annotations",
              "shellQuote": false,
              "position": 4
            },
            "label": "Disable tool default annotations",
            "doc": "Disable all tool default annotations."
          },
          {
            "sbg:altPrefix": "-disable-tool-default-read-filters",
            "sbg:category": "Optional Common Arguments",
            "sbg:toolDefaultValue": "false",
            "id": "disable_tool_default_read_filters",
            "type": "boolean?",
            "inputBinding": {
              "prefix": "--disable-tool-default-read-filters",
              "shellQuote": false,
              "position": 4
            },
            "label": "Disable tool default read filters",
            "doc": "Disable all tool default read filters (warning: many tools will not function correctly without their default read filters on)."
          },
          {
            "sbg:category": "Advanced Arguments",
            "sbg:toolDefaultValue": "false",
            "id": "dont_increase_kmer_sizes_for_cycles",
            "type": "boolean?",
            "inputBinding": {
              "prefix": "--dont-increase-kmer-sizes-for-cycles",
              "shellQuote": false,
              "position": 4
            },
            "label": "Dont increase kmer sizes for cycles",
            "doc": "Disable iterating over kmer sizes when graph cycles are detected."
          },
          {
            "sbg:category": "Advanced Arguments",
            "id": "dont_trim_active_regions",
            "type": "boolean?",
            "inputBinding": {
              "prefix": "--dont-trim-active-regions",
              "shellQuote": false,
              "position": 4
            },
            "label": "Dont trim active regions",
            "doc": "If specified, we will not trim down the active region from the full region (active."
          },
          {
            "sbg:category": "Advanced Arguments",
            "sbg:toolDefaultValue": "false",
            "id": "dont_use_soft_clipped_bases",
            "type": "boolean?",
            "inputBinding": {
              "prefix": "--dont-use-soft-clipped-bases",
              "shellQuote": false,
              "position": 4
            },
            "label": "Dont use soft clipped bases",
            "doc": "Do not analyze soft clipped bases in the reads."
          },
          {
            "sbg:altPrefix": "-ERC",
            "sbg:category": "Advanced Arguments",
            "sbg:toolDefaultValue": "NONE",
            "id": "emit_ref_confidence",
            "type": [
              "null",
              {
                "type": "enum",
                "symbols": [
                  "NONE",
                  "BP_RESOLUTION",
                  "GVCF"
                ],
                "name": "emit_ref_confidence"
              }
            ],
            "inputBinding": {
              "prefix": "--emit-ref-confidence",
              "shellQuote": false,
              "position": 4
            },
            "label": "Emit ref confidence",
            "doc": "(beta feature) mode for emitting reference confidence scores."
          },
          {
            "sbg:category": "Advanced Arguments",
            "sbg:toolDefaultValue": "false",
            "id": "enable_all_annotations",
            "type": "boolean?",
            "inputBinding": {
              "prefix": "--enable-all-annotations",
              "shellQuote": false,
              "position": 4
            },
            "label": "Enable all annotations",
            "doc": "Use all possible annotations (not for the faint of heart)."
          },
          {
            "sbg:category": "Advanced Arguments",
            "sbg:toolDefaultValue": "false",
            "id": "force_active",
            "type": "boolean?",
            "inputBinding": {
              "prefix": "--force-active",
              "shellQuote": false,
              "position": 4
            },
            "label": "Force active",
            "doc": "If provided, all regions will be marked as active."
          },
          {
            "sbg:altPrefix": "--genotype-filtered-alleles",
            "sbg:category": "Advanced Arguments",
            "sbg:toolDefaultValue": "false",
            "id": "force_call_filtered_alleles",
            "type": "boolean?",
            "inputBinding": {
              "prefix": "--force-call-filtered-alleles",
              "shellQuote": false,
              "position": 4
            },
            "label": "Genotype filtered alleles",
            "doc": "Whether to force genotype even filtered alleles."
          },
          {
            "sbg:altPrefix": "-LODB",
            "sbg:category": "Advanced Arguments",
            "sbg:toolDefaultValue": "[-2.5, -2.0, -1.5, -1.0, -0.5, 0.0, 0.5, 1.0]",
            "id": "gvcf_lod_band",
            "type": "float[]?",
            "inputBinding": {
              "prefix": "",
              "shellQuote": false,
              "position": 4,
              "valueFrom": "${\n    var output = \"\";\n    for (var i=0; i<inputs.gvcf_lod_band.length; i++)\n    {\n        output = output + \"--gvcf-lod-band \" + inputs.gvcf_lod_band[i] + \" \";\n    }\n    return output;\n}"
            },
            "label": "Gvcf lod band",
            "doc": "Exclusive upper bounds for reference confidence lod bands (must be specified in increasing order) default value:."
          },
          {
            "sbg:category": "Advanced Arguments",
            "sbg:toolDefaultValue": "[10, 25]",
            "id": "kmer_size",
            "type": "int[]?",
            "inputBinding": {
              "prefix": "",
              "shellQuote": false,
              "position": 4,
              "valueFrom": "${\n    var output = \"\";\n    for (var i=0; i<inputs.kmer_size.length; i++)\n    {\n        output = output + \"--kmer-size \" + inputs.kmer_size[i] + \" \";\n    }\n    return output;\n}"
            },
            "label": "Kmer size",
            "doc": "Kmer size to use in the read threading assembler default value:."
          },
          {
            "sbg:category": "Advanced Arguments",
            "sbg:toolDefaultValue": "300",
            "id": "max_assembly_region_size",
            "type": "int?",
            "inputBinding": {
              "prefix": "--max-assembly-region-size",
              "shellQuote": false,
              "position": 4
            },
            "label": "Max assembly region size",
            "doc": "Maximum size of an assembly region."
          },
          {
            "sbg:altPrefix": "-mnp-dist",
            "sbg:category": "Advanced Arguments",
            "sbg:toolDefaultValue": "1",
            "id": "max_mnp_distance",
            "type": "int?",
            "inputBinding": {
              "prefix": "--max-mnp-distance",
              "shellQuote": false,
              "position": 4
            },
            "label": "Max mnp distance",
            "doc": "Two or more phased substitutions separated by this distance or less are merged into mnps."
          },
          {
            "sbg:category": "Advanced Arguments",
            "sbg:toolDefaultValue": "128",
            "id": "max_num_haplotypes_in_population",
            "type": "int?",
            "inputBinding": {
              "prefix": "--max-num-haplotypes-in-population",
              "shellQuote": false,
              "position": 4
            },
            "label": "Max num haplotypes in population",
            "doc": "Maximum number of haplotypes to consider for your population."
          },
          {
            "sbg:category": "Advanced Arguments",
            "sbg:toolDefaultValue": "50",
            "id": "max_prob_propagation_distance",
            "type": "int?",
            "inputBinding": {
              "prefix": "--max-prob-propagation-distance",
              "shellQuote": false,
              "position": 4
            },
            "label": "Max prob propagation distance",
            "doc": "Upper limit on how many bases away probability mass can be moved around when calculating the boundaries between active and inactive assembly regions."
          },
          {
            "sbg:category": "Advanced Arguments",
            "sbg:toolDefaultValue": "0",
            "id": "max_suspicious_reads_per_alignment_start",
            "type": "int?",
            "inputBinding": {
              "prefix": "--max-suspicious-reads-per-alignment-start",
              "shellQuote": false,
              "position": 4
            },
            "label": "Max suspicious reads per alignment start",
            "doc": "Maximum number of suspicious reads (mediocre mapping quality or too many substitutions) allowed in a downsampling stride. Set to 0 to disable."
          },
          {
            "sbg:category": "Advanced Arguments",
            "sbg:toolDefaultValue": "100",
            "id": "max_unpruned_variants",
            "type": "int?",
            "inputBinding": {
              "prefix": "--max-unpruned-variants",
              "shellQuote": false,
              "position": 4
            },
            "label": "Max unpruned variants",
            "doc": "Maximum number of variants in graph the adaptive pruner will allow."
          },
          {
            "sbg:category": "Advanced Arguments",
            "sbg:toolDefaultValue": "50",
            "id": "min_assembly_region_size",
            "type": "int?",
            "inputBinding": {
              "prefix": "--min-assembly-region-size",
              "shellQuote": false,
              "position": 4
            },
            "label": "Min assembly region size",
            "doc": "Minimum size of an assembly region."
          },
          {
            "sbg:category": "Advanced Arguments",
            "sbg:toolDefaultValue": "4",
            "id": "min_dangling_branch_length",
            "type": "int?",
            "inputBinding": {
              "prefix": "--min-dangling-branch-length",
              "shellQuote": false,
              "position": 4
            },
            "label": "Min dangling branch length",
            "doc": "Minimum length of a dangling branch to attempt recovery."
          },
          {
            "sbg:category": "Advanced Arguments",
            "sbg:toolDefaultValue": "2",
            "id": "min_pruning",
            "type": "int?",
            "inputBinding": {
              "prefix": "--min-pruning",
              "shellQuote": false,
              "position": 4
            },
            "label": "Min pruning",
            "doc": "Minimum support to not prune paths in the graph."
          },
          {
            "sbg:altPrefix": "-min-AF",
            "sbg:category": "Advanced Arguments",
            "sbg:toolDefaultValue": "0",
            "id": "minimum_allele_fraction",
            "type": "float?",
            "inputBinding": {
              "prefix": "--minimum-allele-fraction",
              "shellQuote": false,
              "position": 4
            },
            "label": "Minimum allele fraction",
            "doc": "Lower bound of variant allele fractions to consider when calculating variant lod 0."
          },
          {
            "sbg:category": "Advanced Arguments",
            "sbg:toolDefaultValue": "1",
            "id": "num_pruning_samples",
            "type": "int?",
            "inputBinding": {
              "prefix": "--num-pruning-samples",
              "shellQuote": false,
              "position": 4
            },
            "label": "Num pruning samples",
            "doc": "Number of samples that must pass the minpruning threshold."
          },
          {
            "sbg:category": "Advanced Arguments",
            "sbg:toolDefaultValue": "10",
            "id": "pair_hmm_gap_continuation_penalty",
            "type": "int?",
            "inputBinding": {
              "prefix": "--pair-hmm-gap-continuation-penalty",
              "shellQuote": false,
              "position": 4
            },
            "label": "Pair hmm gap continuation penalty",
            "doc": "Flat gap continuation penalty for use in the pair hmm."
          },
          {
            "sbg:altPrefix": "-pairHMM",
            "sbg:category": "Advanced Arguments",
            "sbg:toolDefaultValue": "FASTEST_AVAILABLE",
            "id": "pair_hmm_implementation",
            "type": [
              "null",
              {
                "type": "enum",
                "symbols": [
                  "EXACT",
                  "ORIGINAL",
                  "LOGLESS_CACHING",
                  "AVX_LOGLESS_CACHING",
                  "AVX_LOGLESS_CACHING_OMP",
                  "EXPERIMENTAL_FPGA_LOGLESS_CACHING",
                  "FASTEST_AVAILABLE"
                ],
                "name": "pair_hmm_implementation"
              }
            ],
            "inputBinding": {
              "prefix": "--pair-hmm-implementation",
              "shellQuote": false,
              "position": 4
            },
            "label": "Pair hmm implementation",
            "doc": "The pairhmm implementation to use for genotype likelihood calculations."
          },
          {
            "sbg:category": "Advanced Arguments",
            "sbg:toolDefaultValue": "CONSERVATIVE",
            "id": "pcr_indel_model",
            "type": [
              "null",
              {
                "type": "enum",
                "symbols": [
                  "NONE",
                  "HOSTILE",
                  "AGGRESSIVE",
                  "CONSERVATIVE"
                ],
                "name": "pcr_indel_model"
              }
            ],
            "inputBinding": {
              "prefix": "--pcr-indel-model",
              "shellQuote": false,
              "position": 4
            },
            "label": "Pcr indel model",
            "doc": "The pcr indel model to use."
          },
          {
            "sbg:category": "Advanced Arguments",
            "sbg:toolDefaultValue": "45",
            "id": "phred_scaled_global_read_mismapping_rate",
            "type": "int?",
            "inputBinding": {
              "prefix": "--phred-scaled-global-read-mismapping-rate",
              "shellQuote": false,
              "position": 4
            },
            "label": "Phred scaled global read mismapping rate",
            "doc": "The global assumed mismapping rate for reads."
          },
          {
            "sbg:category": "Advanced Arguments",
            "sbg:toolDefaultValue": "2.302585092994046",
            "id": "pruning_lod_threshold",
            "type": "float?",
            "inputBinding": {
              "prefix": "--pruning-lod-threshold",
              "shellQuote": false,
              "position": 4
            },
            "label": "Pruning lod threshold",
            "doc": "Ln likelihood ratio threshold for adaptive pruning algorithm"
          },
          {
            "sbg:category": "Advanced Arguments",
            "sbg:toolDefaultValue": "false",
            "id": "recover_all_dangling_branches",
            "type": "boolean?",
            "inputBinding": {
              "prefix": "--recover-all-dangling-branches",
              "shellQuote": false,
              "position": 4
            },
            "label": "Recover all dangling branches",
            "doc": "Recover all dangling branches."
          },
          {
            "sbg:altPrefix": "-showHidden",
            "sbg:category": "Advanced Arguments",
            "sbg:toolDefaultValue": "false",
            "id": "showhidden",
            "type": "boolean?",
            "inputBinding": {
              "prefix": "--showHidden",
              "shellQuote": false,
              "position": 4
            },
            "label": "Showhidden",
            "doc": "Display hidden arguments."
          },
          {
            "sbg:category": "Advanced Arguments",
            "sbg:toolDefaultValue": "JAVA",
            "id": "smith_waterman",
            "type": [
              "null",
              {
                "type": "enum",
                "symbols": [
                  "FASTEST_AVAILABLE",
                  "AVX_ENABLED",
                  "JAVA"
                ],
                "name": "smith_waterman"
              }
            ],
            "inputBinding": {
              "prefix": "--smith-waterman",
              "shellQuote": false,
              "position": 4
            },
            "label": "Smith waterman",
            "doc": "Which smith-waterman implementation to use, generally fastest_available is the right choice."
          },
          {
            "sbg:category": "Advanced Arguments",
            "sbg:toolDefaultValue": "null",
            "id": "ambig_filter_bases",
            "type": "int?",
            "inputBinding": {
              "prefix": "--ambig-filter-bases",
              "shellQuote": false,
              "position": 4
            },
            "label": "Ambig filter bases",
            "doc": "Threshold number of ambiguous bases. If null, uses threshold fraction; otherwise, overrides threshold fraction. Cannot be used in conjuction with argument(s) maxambiguousbasefraction. Valid only if \"ambiguousbasereadfilter\" is specified."
          },
          {
            "sbg:category": "Advanced Arguments",
            "sbg:toolDefaultValue": "0",
            "id": "ambig_filter_frac",
            "type": "float?",
            "inputBinding": {
              "prefix": "--ambig-filter-frac",
              "shellQuote": false,
              "position": 4
            },
            "label": "Ambig filter frac",
            "doc": "Threshold fraction of ambiguous bases 05. Cannot be used in conjuction with argument(s) maxambiguousbases. Valid only if \"ambiguousbasereadfilter\" is specified."
          },
          {
            "sbg:category": "Advanced Arguments",
            "sbg:toolDefaultValue": "1000000",
            "id": "max_fragment_length",
            "type": "int?",
            "inputBinding": {
              "prefix": "--max-fragment-length",
              "shellQuote": false,
              "position": 4
            },
            "label": "Max fragment length",
            "doc": "Maximum length of fragment (insert size). Valid only if \"fragmentlengthreadfilter\" is specified."
          },
          {
            "sbg:category": "Advanced Arguments",
            "sbg:toolDefaultValue": "0",
            "id": "min_fragment_length",
            "type": "int?",
            "inputBinding": {
              "prefix": "--min-fragment-length",
              "shellQuote": false,
              "position": 4
            },
            "label": "Min fragment length",
            "doc": "Minimum length of fragment (insert size). Valid only if \"fragmentlengthreadfilter\" is specified."
          },
          {
            "sbg:category": "Advanced Arguments",
            "id": "keep_intervals",
            "type": "string?",
            "inputBinding": {
              "prefix": "--keep-intervals",
              "shellQuote": false,
              "position": 4
            },
            "label": "Keep intervals",
            "doc": "One or more genomic intervals to keep this argument must be specified at least once. Valid only if \"intervaloverlapreadfilter\" is specified."
          },
          {
            "sbg:altPrefix": "-library",
            "sbg:category": "Advanced Arguments",
            "id": "library",
            "type": "string?",
            "inputBinding": {
              "prefix": "--library",
              "shellQuote": false,
              "position": 4
            },
            "label": "Library",
            "doc": "Name of the library to keep this argument must be specified at least once. Valid only if \"libraryreadfilter\" is specified."
          },
          {
            "sbg:category": "Advanced Arguments",
            "sbg:toolDefaultValue": "null",
            "id": "maximum_mapping_quality",
            "type": "int?",
            "inputBinding": {
              "prefix": "--maximum-mapping-quality",
              "shellQuote": false,
              "position": 4
            },
            "label": "Maximum mapping quality",
            "doc": "Maximum mapping quality to keep (inclusive). Valid only if \"mappingqualityreadfilter\" is specified."
          },
          {
            "sbg:category": "Advanced Arguments",
            "sbg:toolDefaultValue": "20",
            "id": "minimum_mapping_quality",
            "type": "int?",
            "inputBinding": {
              "prefix": "--minimum-mapping-quality",
              "shellQuote": false,
              "position": 4
            },
            "label": "Minimum mapping quality",
            "doc": "Minimum mapping quality to keep (inclusive). Valid only if \"mappingqualityreadfilter\" is specified."
          },
          {
            "sbg:category": "Advanced Arguments",
            "sbg:toolDefaultValue": "false",
            "id": "dont_require_soft_clips_both_ends",
            "type": "boolean?",
            "inputBinding": {
              "prefix": "--dont-require-soft-clips-both-ends",
              "shellQuote": false,
              "position": 4
            },
            "label": "Dont require soft clips both ends",
            "doc": "Allow a read to be filtered out based on having only 1 soft-clipped block. By default, both ends must have a soft-clipped block, setting this flag requires only 1 soft-clipped block. Valid only if \"overclippedreadfilter\" is specified."
          },
          {
            "sbg:category": "Advanced Arguments",
            "sbg:toolDefaultValue": "30",
            "id": "filter_too_short",
            "type": "int?",
            "inputBinding": {
              "prefix": "--filter-too-short",
              "shellQuote": false,
              "position": 4
            },
            "label": "Filter too short",
            "doc": "Minimum number of aligned bases. Valid only if \"overclippedreadfilter\" is specified."
          },
          {
            "sbg:category": "Advanced Arguments",
            "id": "platform_filter_name",
            "type": "string?",
            "inputBinding": {
              "prefix": "--platform-filter-name",
              "shellQuote": false,
              "position": 4,
              "valueFrom": "${\n    return '\"' + self + '\"';\n}"
            },
            "label": "Platform filter name",
            "doc": "Platform attribute (pl) to match this argument must be specified at least once. Valid only if \"platformreadfilter\" is specified."
          },
          {
            "sbg:category": "Advanced Arguments",
            "id": "black_listed_lanes",
            "type": "string?",
            "inputBinding": {
              "prefix": "--black-listed-lanes",
              "shellQuote": false,
              "position": 4
            },
            "label": "Black listed lanes",
            "doc": "Platform unit (pu) to filter out this argument must be specified at least once. Valid only if \"platformunitreadfilter\" is specified."
          },
          {
            "sbg:category": "Advanced Arguments",
            "id": "read_group_black_list",
            "type": "string?",
            "inputBinding": {
              "prefix": "--read-group-black-list",
              "shellQuote": false,
              "position": 4
            },
            "label": "Read group black list",
            "doc": "Name of the read group to filter out this argument must be specified at least once. Valid only if \"readgroupblacklistreadfilter\" is specified."
          },
          {
            "sbg:category": "Advanced Arguments",
            "id": "keep_read_group",
            "type": "string?",
            "inputBinding": {
              "prefix": "--keep-read-group",
              "shellQuote": false,
              "position": 4
            },
            "label": "Keep read group",
            "doc": "The name of the read group to keep. Valid only if \"readgroupreadfilter\" is specified."
          },
          {
            "sbg:category": "Advanced Arguments",
            "sbg:toolDefaultValue": "2147483647",
            "id": "max_read_length",
            "type": "int?",
            "inputBinding": {
              "prefix": "--max-read-length",
              "shellQuote": false,
              "position": 4
            },
            "label": "Max read length",
            "doc": "Keep only reads with length at most equal to the specified value. Valid only if \"readlengthreadfilter\" is specified."
          },
          {
            "sbg:category": "Advanced Arguments",
            "sbg:toolDefaultValue": "30",
            "id": "min_read_length",
            "type": "int?",
            "inputBinding": {
              "prefix": "--min-read-length",
              "shellQuote": false,
              "position": 4
            },
            "label": "Min read length",
            "doc": "Keep only reads with length at least equal to the specified value. Valid only if \"readlengthreadfilter\" is specified."
          },
          {
            "sbg:category": "Advanced Arguments",
            "id": "read_name",
            "type": "string?",
            "inputBinding": {
              "prefix": "--read-name",
              "shellQuote": false,
              "position": 4,
              "valueFrom": "${\n    return '\"' + self + '\"';\n}"
            },
            "label": "Read name",
            "doc": "Keep only reads with this read name. Valid only if \"readnamereadfilter\" is specified."
          },
          {
            "sbg:category": "Advanced Arguments",
            "id": "keep_reverse_strand_only",
            "type": "boolean?",
            "inputBinding": {
              "prefix": "--keep-reverse-strand-only",
              "shellQuote": false,
              "position": 4
            },
            "label": "Keep reverse strand only",
            "doc": "Keep only reads on the reverse strand. Valid only if \"readstrandfilter\" is specified."
          },
          {
            "sbg:altPrefix": "-sample",
            "sbg:category": "Advanced Arguments",
            "id": "sample",
            "type": "string?",
            "inputBinding": {
              "prefix": "--sample",
              "shellQuote": false,
              "position": 4,
              "valueFrom": "${\n    return '\"' + self + '\"';\n}"
            },
            "label": "Sample",
            "doc": "The name of the sample(s) to keep, filtering out all others this argument must be specified at least once. Valid only if \"samplereadfilter\" is specified."
          },
          {
            "sbg:category": "Execution",
            "sbg:toolDefaultValue": "1",
            "id": "cpu_per_job",
            "type": "int?",
            "label": "CPU per job",
            "doc": "Number of CPUs per job"
          },
          {
            "sbg:altPrefix": "-L",
            "sbg:category": "Optional Tool Arguments",
            "id": "in_interval_files",
            "type": "File[]?",
            "inputBinding": {
              "shellQuote": false,
              "position": 4,
              "valueFrom": "${\n    var output = \"\";\n    var interval_files = [].concat(self);\n    for (var i=0; i < interval_files.length; i++)\n        output += \" --intervals \" + interval_files[i].path;\n    return output;\n}"
            },
            "label": "Interval Files",
            "doc": "One or more genomic intervals, given in form of a file, over which to operate.",
            "sbg:fileTypes": "LIST, BED, INTERVALS, VCF, INTERVAL_LIST"
          },
          {
            "sbg:category": "Optional Arguments",
            "id": "exclude_interval_files",
            "type": "File[]?",
            "inputBinding": {
              "shellQuote": false,
              "position": 4,
              "valueFrom": "${\n    var output = \"\";\n    for (var i=0; i<self.length; i++)\n        output += \" -XL \" + self[i].path;\n    return output;\n}"
            },
            "label": "Exclude intervals",
            "doc": "Or more genomic intervals, in form of a file, to exclude from processing.",
            "sbg:fileTypes": "LIST, INTERVALS, VCF, BED, INTERVAL_LIST"
          },
          {
            "sbg:category": "Advanced Arguments",
            "sbg:toolDefaultValue": "null",
            "id": "make_bamout",
            "type": "boolean?",
            "label": "Make BAM output",
            "doc": "File to which assembled haplotypes should be written"
          },
          {
            "sbg:category": "Advanced Arguments",
            "id": "make_f1r2",
            "type": "boolean?",
            "label": "Make f1r2 file",
            "doc": "Make f1r2 output file."
          },
          {
            "sbg:category": "Advanced Arguments",
            "id": "compress",
            "type": "boolean?",
            "label": "Compress output",
            "doc": "Compres output VCF."
          },
          {
            "sbg:category": "Execution",
            "sbg:toolDefaultValue": "3500",
            "id": "mem_per_job",
            "type": "int?",
            "label": "Memory Per Job",
            "doc": "Memory Per Job (in MB)"
          },
          {
            "sbg:category": "Execution",
            "sbg:toolDefaultValue": "500",
            "id": "mem_overhead_per_job",
            "type": "int?",
            "label": "Memory overhead per job",
            "doc": "Memory overhead per job (in MB)."
          },
          {
            "sbg:altPrefix": "-bamout",
            "sbg:category": "Advanced Arguments",
            "sbg:toolDefaultValue": "null",
            "id": "output_bam_filename",
            "type": "string?",
            "label": "Output BAM filename",
            "doc": "Filename of the output BAM file."
          },
          {
            "sbg:category": "Additional inputs",
            "sbg:toolDefaultValue": "False",
            "id": "append_interval_to_name",
            "type": "boolean?",
            "label": "Append interval to name",
            "doc": "Appends first 4 characters of the intervals name to the output name. This option should be used if Mutect is scattered by input intervals."
          },
          {
            "sbg:category": "Optional Tool Arguments",
            "sbg:toolDefaultValue": "None",
            "id": "mutect2_extra_arguments",
            "type": "string[]?",
            "inputBinding": {
              "shellQuote": false,
              "position": 4,
              "valueFrom": "${\n    if (self.length > 0){\n        return self.join(\" \");\n} else {\n        return null;\n    }\n}"
            },
            "label": "Extra Arguments",
            "doc": "This will be inserted directly into the command line of the tool (Use with care!)."
          }
        ],
        "outputs": [
          {
            "id": "out_variants",
            "doc": "Output variants in VCF or VCF.GZ format.",
            "label": "Output variants",
            "type": "File?",
            "outputBinding": {
              "glob": "${\n    return [\"*.vcf.gz\", \"*.vcf\"]\n}",
              "outputEval": "${\n    function removeNull(array){\n        var output = [];\n        for (var i = 0; i<array.length; i++){\n            if (array[i] != null){\n                output.push(array[i]);\n            }\n        }\n        return output;\n    }\n    \n    var setMetadata = function(file, metadata) {\n        if (!('metadata' in file)) {\n            file['metadata'] = {}\n        }\n        for (var key in metadata) {\n            file['metadata'][key] = metadata[key];\n        }\n        return file\n    };\n    \n    var inheritMetadata = function(o1, o2) {\n        var commonMetadata = {};\n        if (!o2) {\n            return o1;\n        };\n        if (!Array.isArray(o2)) {\n            o2 = [o2]\n        }\n        for (var i = 0; i < o2.length; i++) {\n            var example = o2[i]['metadata'];\n            for (var key in example) {\n                if (i == 0)\n                    commonMetadata[key] = example[key];\n                else {\n                    if (!(commonMetadata[key] == example[key])) {\n                        delete commonMetadata[key]\n                    }\n                }\n            }\n            for (var key in commonMetadata) {\n                if (!(key in example)) {\n                    delete commonMetadata[key]\n                }\n            }\n        }\n        if (!Array.isArray(o1)) {\n            o1 = setMetadata(o1, commonMetadata)\n        } else {\n            for (var i = 0; i < o1.length; i++) {\n                o1[i] = setMetadata(o1[i], commonMetadata)\n            }\n        }\n        return o1;\n    };\n    \n    self = inheritMetadata(self, removeNull([].concat(inputs.in_alignments)));\n    return self;\n}"
            },
            "secondaryFiles": [
              {
                "pattern": "${\n    return [self.basename + \".idx\", self.nameroot + \".idx\"]\n}"
              },
              {
                "pattern": "${\n    return [self.basename + \".tbi\", self.nameroot + \".tbi\"]\n}"
              }
            ],
            "sbg:fileTypes": "VCF, VCF.GZ"
          },
          {
            "id": "out_alignments",
            "doc": "Output alignments in BAM format",
            "label": "Output alignments",
            "type": "File?",
            "outputBinding": {
              "glob": "*.bam",
              "outputEval": "${\n    function removeNull(array){\n        var output = [];\n        for (var i = 0; i<array.length; i++){\n            if (array[i] != null){\n                output.push(array[i]);\n            }\n        }\n        return output;\n    }\n    \n    var setMetadata = function(file, metadata) {\n        if (!('metadata' in file)) {\n            file['metadata'] = {}\n        }\n        for (var key in metadata) {\n            file['metadata'][key] = metadata[key];\n        }\n        return file\n    };\n    \n    var inheritMetadata = function(o1, o2) {\n        var commonMetadata = {};\n        if (!o2) {\n            return o1;\n        };\n        if (!Array.isArray(o2)) {\n            o2 = [o2]\n        }\n        for (var i = 0; i < o2.length; i++) {\n            var example = o2[i]['metadata'];\n            for (var key in example) {\n                if (i == 0)\n                    commonMetadata[key] = example[key];\n                else {\n                    if (!(commonMetadata[key] == example[key])) {\n                        delete commonMetadata[key]\n                    }\n                }\n            }\n            for (var key in commonMetadata) {\n                if (!(key in example)) {\n                    delete commonMetadata[key]\n                }\n            }\n        }\n        if (!Array.isArray(o1)) {\n            o1 = setMetadata(o1, commonMetadata)\n        } else {\n            for (var i = 0; i < o1.length; i++) {\n                o1[i] = setMetadata(o1[i], commonMetadata)\n            }\n        }\n        return o1;\n    };\n    \n    self = inheritMetadata(self, removeNull([].concat(inputs.in_alignments)));\n    return self;\n}"
            },
            "secondaryFiles": [
              {
                "pattern": ".bai"
              },
              {
                "pattern": "^.bai"
              }
            ],
            "sbg:fileTypes": "BAM"
          },
          {
            "id": "f1r2_counts",
            "doc": "Output f1r2 counts in TAR.GZ format",
            "label": "Output f1r2 counts",
            "type": "File?",
            "outputBinding": {
              "glob": "*.tar.gz",
              "outputEval": "${\n    function removeNull(array){\n        var output = [];\n        for (var i = 0; i<array.length; i++){\n            if (array[i] != null){\n                output.push(array[i]);\n            }\n        }\n        return output;\n    }\n    \n    var setMetadata = function(file, metadata) {\n        if (!('metadata' in file)) {\n            file['metadata'] = {}\n        }\n        for (var key in metadata) {\n            file['metadata'][key] = metadata[key];\n        }\n        return file\n    };\n    \n    var inheritMetadata = function(o1, o2) {\n        var commonMetadata = {};\n        if (!o2) {\n            return o1;\n        };\n        if (!Array.isArray(o2)) {\n            o2 = [o2]\n        }\n        for (var i = 0; i < o2.length; i++) {\n            var example = o2[i]['metadata'];\n            for (var key in example) {\n                if (i == 0)\n                    commonMetadata[key] = example[key];\n                else {\n                    if (!(commonMetadata[key] == example[key])) {\n                        delete commonMetadata[key]\n                    }\n                }\n            }\n            for (var key in commonMetadata) {\n                if (!(key in example)) {\n                    delete commonMetadata[key]\n                }\n            }\n        }\n        if (!Array.isArray(o1)) {\n            o1 = setMetadata(o1, commonMetadata)\n        } else {\n            for (var i = 0; i < o1.length; i++) {\n                o1[i] = setMetadata(o1[i], commonMetadata)\n            }\n        }\n        return o1;\n    };\n    \n    self = inheritMetadata(self, removeNull([].concat(inputs.in_alignments)));\n    return self;\n}"
            },
            "sbg:fileTypes": "TAR.GZ"
          },
          {
            "id": "out_stats",
            "doc": "Output stat file.",
            "label": "Output stats",
            "type": "File?",
            "outputBinding": {
              "glob": "${\n    return [\"*.vcf.gz.stats\", \"*.vcf.stats\"]\n}",
              "outputEval": "${\n    function removeNull(array){\n        var output = [];\n        for (var i = 0; i<array.length; i++){\n            if (array[i] != null){\n                output.push(array[i]);\n            }\n        }\n        return output;\n    }\n    \n    var setMetadata = function(file, metadata) {\n        if (!('metadata' in file)) {\n            file['metadata'] = {}\n        }\n        for (var key in metadata) {\n            file['metadata'][key] = metadata[key];\n        }\n        return file\n    };\n    \n    var inheritMetadata = function(o1, o2) {\n        var commonMetadata = {};\n        if (!o2) {\n            return o1;\n        };\n        if (!Array.isArray(o2)) {\n            o2 = [o2]\n        }\n        for (var i = 0; i < o2.length; i++) {\n            var example = o2[i]['metadata'];\n            for (var key in example) {\n                if (i == 0)\n                    commonMetadata[key] = example[key];\n                else {\n                    if (!(commonMetadata[key] == example[key])) {\n                        delete commonMetadata[key]\n                    }\n                }\n            }\n            for (var key in commonMetadata) {\n                if (!(key in example)) {\n                    delete commonMetadata[key]\n                }\n            }\n        }\n        if (!Array.isArray(o1)) {\n            o1 = setMetadata(o1, commonMetadata)\n        } else {\n            for (var i = 0; i < o1.length; i++) {\n                o1[i] = setMetadata(o1[i], commonMetadata)\n            }\n        }\n        return o1;\n    };\n    \n    self = inheritMetadata(self, removeNull([].concat(inputs.in_alignments)));\n    return self;\n}"
            },
            "sbg:fileTypes": "STATS, VCF.GZ.STATS, VCF.STATS"
          }
        ],
        "doc": "**Mutect2** is used to call somatic SNVs and indels via local assembly of haplotypes.\n\n###Common Use Cases\nExample commands show how to run Mutect2 for typical scenarios. The three modes are (i) tumor-normal mode where a tumor sample is matched with a normal sample in analysis, (ii) tumor-only mode where a single sample's alignment data undergoes analysis, and (iii) mitochondrial mode where sensitive calling at high depths is desirable.\n\n- As of v4.1, there is no longer a need to specify the tumor sample name with -tumor. You need only specify the normal sample name with -normal, if you include a normal.\n\n- Starting with v4.0.4.0, GATK recommends the default setting of --af-of-alleles-not-in-resource, which the tool dynamically adjusts for different modes. tumor-only calling sets the default to 5e-8, tumor-normal calling sets it to 1e-6 and mitochondrial mode sets it to 4e-3. For previous versions, the default was 0.001, the average heterozygosity of humans. For other organisms, change --af-of-alleles-not-in-resource to 1/(ploidy*samples in resource).\n\n**Tumor with matched normal**\nGiven a matched normal, Mutect2 is designed to call somatic variants only. The tool includes logic to skip emitting variants that are clearly present in the germline based on provided evidence, e.g. in the matched normal. This is done at an early stage to avoid spending computational resources on germline events. If the variant's germline status is borderline, then Mutect2 will emit the variant to the callset for subsequent filtering by FilterMutectCalls and review.\n\n```\ngatk Mutect2 \\\n     -R reference.fa \\\n     -I tumor.bam \\\n     -I normal.bam \\\n     -normal normal_sample_name \\\n     --germline-resource af-only-gnomad.vcf.gz \\\n     --panel-of-normals pon.vcf.gz \\\n     -O somatic.vcf.gz\n```\n\nMutect2 also generates a stats file names [output vcf].stats. That is, in the above example the stats file would be named somatic.vcf.gz.stats and would be in the same folder as somatic.vcf.gz. As of GATK 4.1.1 this file is a required input to FilterMutectCalls.\n- As of v4.1 Mutect2 supports joint calling of multiple tumor and normal samples from the same individual. The only difference is that -I and -normal must be specified for the extra samples.\n```\n gatk Mutect2 \\\n     -R reference.fa \\\n     -I tumor1.bam \\\n     -I tumor2.bam \\\n     -I normal1.bam \\\n     -I normal2.bam \\\n     -normal normal1_sample_name \\\n     -normal normal2_sample_name \\\n     --germline-resource af-only-gnomad.vcf.gz \\\n     --panel-of-normals pon.vcf.gz \\\n     -O somatic.vcf.gz\n```\n**Tumor-only mode**\nThis mode runs on a single type of sample, e.g. the tumor or the normal. To create a PoN, call on each normal sample in this mode, then use CreateSomaticPanelOfNormals to generate the PoN.\n```\n  gatk Mutect2 \\\n       -R reference.fa \\\n       -I sample.bam \\\n       -O single_sample.vcf.gz\n```\nTo call mutations on a tumor sample, call in this mode using a PoN and germline resource. After FilterMutectCalls filtering, consider additional filtering by functional significance with Funcotator.\n```\n  gatk Mutect2 \\\n       -R reference.fa \\\n       -I sample.bam \\\n       --germline-resource af-only-gnomad.vcf.gz \\\n       --panel-of-normals pon.vcf.gz \\\n       -O single_sample.vcf.gz\n```\n**Mitochondrial mode**\nMutect2 automatically sets parameters appropriately for calling on mitochondria with the --mitochondria flag. Specifically, the mode sets \u2013-initial-tumor-lod to 0, \u2013-tumor-lod-to-emit to 0, --af-of-alleles-not-in-resource to 4e-3, and the advanced parameter --pruning-lod-threshold to -4.\n```\ngatk Mutect2 \\\n     -R reference.fa \\\n     -L chrM \\\n     --mitochondria \\\n     --median-autosomal-coverage 30 \\\n     -I mitochondria.bam \\\n     -O mitochondria.vcf.gz\n```\nSetting the advanced option --median-autosomal-coverage argument (default 0) activates a recommended filter against likely erroneously mapped NuMTs (nuclear mitochondrial DNA segments). For the value, provide the median coverage expected in autosomal regions with coverage. The mode accepts only a single sample, which can be provided in multiple files.\n\n**Force-calling mode**\nThis mode force-calls all alleles in force-call-alleles.vcf in addition to any other variants Mutect2 discovers.\n```\ngatk Mutect2 \\\n     -R reference.fa \\\n     -I sample.bam \\\n     -alleles force-call-alleles.vcf\n     -O single_sample.vcf.gz\n```\nIf the sample is suspected to exhibit orientation bias artifacts (such as in the case of FFPE tumor samples) one should also collect F1R2 metrics by adding an --f1r2-tar-gz argument as shown below. This file contains information that can then be passed to LearnReadOrientationModel, which generate an artifact prior table for each tumor sample for FilterMutectCalls to use.\n\n```\n gatk Mutect2 \\\n     -R reference.fa \\\n     -I sample.bam \\\n     --f1r2-tar-gz f1r2.tar.gz \\\n     -O single_sample.vcf.gz\n```\n\n###Changes Introduced by Seven Bridges\n- **Output filename** (`--output`)  parameter, if not provided explicitly, will be generated automatically based on other inputs. Namely, if **Tumor sample** and **Normal sample** are provided, they will be used to generate the output name; if not provided input file names will be used.\n- String array argument **Extra Arguments** has been added for ease of use in certain workflows.\n\n###Common Issues and Important Notes\nNone\n###Performance Benchmarking",
        "label": "GATK Mutect2 CWL1.0",
        "arguments": [
          {
            "prefix": "--java-options",
            "shellQuote": false,
            "position": 2,
            "valueFrom": "${\n    if (inputs.mem_per_job) {\n        return '\\\"-Xmx'.concat(inputs.mem_per_job, 'M') + '\\\"'\n    }\n    return '\\\"-Xmx7500M\\\"'\n}"
          },
          {
            "shellQuote": false,
            "position": 3,
            "valueFrom": "Mutect2"
          },
          {
            "prefix": "--output",
            "shellQuote": false,
            "position": 5,
            "valueFrom": "${\n    function extractSampleId(file) {\n        if (file.hasOwnProperty('metadata') && file.metadata && file.metadata['sample_id']){\n            return file.metadata['sample_id'];\n        } else {\n            return file.basename.split(\".\").slice(0)[0];\n        }\n    }\n    \n    function isTumor(file){\n        if (file.hasOwnProperty('metadata') && file.metadata && file.metadata['sample_type']){\n            return file.metadata['sample_type'].indexOf('Tumor') != -1;\n        } else {\n            return false;\n        }\n    }\n    \n    function removeEmpty(list){\n        list = [].concat(list);\n        var new_list = [];\n        for (var i=0; i < list.length; i++){\n            if (list[i] != \"\"){\n                new_list.push(list[i]);\n            }\n        }\n        return new_list;\n    }\n    \n    var added_suffix = \"\";\n    if (inputs.append_interval_to_name){\n        var intervals = [].concat(inputs.in_interval_files);\n        if (intervals.length > 0){\n            added_suffix = intervals[0].nameroot;\n            if (added_suffix.length >= 4){\n                added_suffix = added_suffix.substring(0, 4);\n            } else {\n                added_suffix = \"\";\n            }\n        }\n    }\n    \n    if (added_suffix.length > 0){\n        added_suffix = \"_\" + added_suffix;\n    }\n    \n    var suffix = added_suffix + \".somatic.vcf\";\n    if (inputs.compress){\n        suffix += \".gz\";\n    }\n    \n    var output = \"mutect2\";\n    \n    if (inputs.output_filename){\n        output = inputs.output_filename;\n    } else {\n        var tumor_id = \"\";\n        var normal_id = \"\";\n        var output_files = [].concat(inputs.in_alignments);\n        \n        if (inputs.tumor_sample){\n            tumor_id = removeEmpty(inputs.tumor_sample)[0];\n        }\n        \n        if (inputs.normal_sample){\n            normal_id = removeEmpty(inputs.normal_sample)[0];\n        }\n        \n        if (!tumor_id || !normal_id){\n            var normal_names = [];\n            var tumor_names = [];\n            \n            if (inputs.normal_sample){\n                normal_names = removeEmpty(inputs.normal_sample);\n            }\n            if (!normal_names[0]){\n                for (var i=0; i < output_files.length; i++){\n                    if (output_files[i]){\n                        var id = extractSampleId(output_files[i]);\n                        if (!isTumor(output_files[i]) && id){\n                            normal_names.push(id);\n                        }\n                    }\n                }\n            }\n            \n            if (inputs.tumor_sample){\n                tumor_names = removeEmpty(inputs.tumor_sample);\n            }\n            if (!tumor_names[0]){\n                for (var i=0; i < output_files.length; i++){\n                    if (output_files[i]){\n                        var id = extractSampleId(output_files[i]);\n                        if (isTumor(output_files[i]) && id){\n                            tumor_names.push(id);\n                        }\n                    }\n                }\n            }\n            \n            if (tumor_names.length == 1){\n                tumor_id = tumor_names[0];\n            }\n            \n            if (normal_names.length == 1){\n                normal_id = normal_names[0];\n            }\n            \n            if (!tumor_id || tumor_names.length>1 || normal_names.length>1){\n                tumor_id = 'mutect2';\n                normal_id = '';\n            }\n        }\n        if (normal_id){\n            output = tumor_id + \"-\" + normal_id\n        } else {\n            output = tumor_id;\n        }\n    }\n    var name = output + suffix;\n    while (name.indexOf(\" \") > -1){\n        name = name.replace(\" \", \"_\")\n    }\n    return name;\n}"
          },
          {
            "prefix": "--f1r2-tar-gz",
            "shellQuote": false,
            "position": 5,
            "valueFrom": "${\n    function extractSampleId(file) {\n        if (file.metadata && file.metadata['sample_id']){\n            return file.metadata['sample_id'];\n        } else {\n            return file.basename.split(\".\").slice(0)[0];\n        }\n    }\n    \n    function isTumor(file){\n        if (output_files[i].metadata && output_files[i].metadata['sample_type']){\n            return output_files[i].metadata['sample_type'].indexOf('Tumor') != -1;\n        } else {\n            return false;\n        }\n    }\n    \n    function removeEmpty(list){\n        list = [].concat(list);\n        var new_list = [];\n        for (var i=0; i < list.length; i++){\n            if (list[i] != \"\"){\n                new_list.push(list[i]);\n            }\n        }\n        return new_list;\n    }\n    \n    // If make_f1_r2 is true, create outoput name and prefix\n    if (inputs.make_f1r2){\n        var added_suffix = \"\";\n        if (inputs.in_interval_files.length > 0){\n            added_suffix = inputs.in_interval_files[0].nameroot;\n            if (added_suffix.length >= 4){\n                added_suffix = added_suffix.substring(0, 4);\n            } else {\n                added_suffix = \"\";\n            }\n        }\n        \n        if (added_suffix.length > 0){\n            added_suffix = \"_\" + added_suffix;\n        }\n        var suffix = added_suffix + \".tar.gz\";\n        var output = \"f1r2\";\n        \n        if (inputs.f1r2_tar_gz){\n            output = inputs.f1r2_tar_gz;\n        } else if (inputs.output_filename){\n            output = inputs.output_filename;\n        } else {\n            var tumor_id = \"\";\n            var normal_id = \"\";\n            var output_files = [].concat(inputs.in_alignments);\n            \n            if (inputs.tumor_sample){\n                tumor_id = removeEmpty(inputs.tumor_sample)[0];\n            }\n            \n            if (inputs.normal_sample){\n                normal_id = removeEmpty(inputs.normal_sample)[0];\n            }\n            \n            if (!tumor_id || !normal_id){\n                var normal_names = [];\n                var tumor_names = [];\n                \n                if (inputs.normal_sample){\n                    normal_names = removeEmpty(inputs.normal_sample);\n                }\n                \n                if (inputs.tumor_sample){\n                    tumor_names = removeEmpty(inputs.tumor_sample);\n                }\n                if (!normal_names[0]){\n                    for (var i=0; i < output_files.length; i++){\n                        var id = extractSampleId(output_files[i]);\n                        if (!isTumor(output_files[i]) && id){\n                            normal_names.push(id);\n                        }\n                    }\n                }\n                \n                if (!tumor_names[0]){\n                    for (var i=0; i < output_files.length; i++){\n                        var id = extractSampleId(output_files[i]);\n                        if (isTumor(output_files[i]) && id){\n                            tumor_names.push(id);\n                        }\n                    }\n                }\n                \n                if (tumor_names.length == 1){\n                    tumor_id = tumor_names[0];\n                }\n                \n                if (normal_names.length == 1){\n                    normal_id = normal_names[0];\n                }\n                \n                if (!tumor_id || tumor_names.length>1 || normal_names.length>1){\n                    tumor_id = 'f1r2';\n                    normal_id = '';\n                }\n            }\n            if (normal_id){\n                output = tumor_id + \"-\" + normal_id\n            } else {\n                output = tumor_id;\n            }\n        }\n        var name = output + suffix;\n        while (name.indexOf(\" \") > -1){\n            name = name.replace(\" \", \"_\")\n        }\n        return name;\n    } else {\n        return null;\n    }\n}"
          },
          {
            "prefix": "--bam-output",
            "shellQuote": false,
            "position": 5,
            "valueFrom": "${\n    function extractSampleId(file) {\n        if (file.metadata && file.metadata['sample_id']){\n            return file.metadata['sample_id'];\n        } else {\n            return file.basename.split(\".\").slice(0)[0];\n        }\n    }\n    \n    function isTumor(file){\n        if (output_files[i].metadata && output_files[i].metadata['sample_type']){\n            return output_files[i].metadata['sample_type'].indexOf('Tumor') != -1;\n        } else {\n            return false;\n        }\n    }\n    \n    function removeEmpty(list){\n        list = [].concat(list);\n        var new_list = [];\n        for (var i=0; i < list.length; i++){\n            if (list[i] != \"\"){\n                new_list.push(list[i]);\n            }\n        }\n        return new_list;\n    }\n    \n    if (inputs.make_bamout){\n        var suffix = '.bam'\n        \n        var output = \"mutect2\";\n        \n        if (inputs.output_bam_filename){\n            output = inputs.output_bam_filename;\n        } else {\n            var tumor_id = \"\";\n            var normal_id = \"\";\n            var output_files = [].concat(inputs.in_alignments);\n            \n            if (inputs.tumor_sample){\n                tumor_id = removeEmpty(inputs.tumor_sample)[0];\n            }\n            \n            if (inputs.normal_sample){\n                normal_id = removeEmpty(inputs.normal_sample)[0];\n            }\n            \n            if (!tumor_id || !normal_id){\n                var normal_names = [];\n                var tumor_names = [];\n                \n                if (inputs.normal_sample){\n                    normal_names = removeEmpty(inputs.normal_sample);\n                }\n                \n                if (inputs.tumor_sample){\n                    tumor_names = removeEmpty(inputs.tumor_sample);\n                }\n                if (!normal_names[0]){\n                    for (var i=0; i < output_files.length; i++){\n                        var id = extractSampleId(output_files[i]);\n                        if (!isTumor(output_files[i]) && id){\n                            normal_names.push(id);\n                        }\n                    }\n                }\n                \n                if (!tumor_names[0]){\n                    for (var i=0; i < output_files.length; i++){\n                        var id = extractSampleId(output_files[i]);\n                        if (isTumor(output_files[i]) && id){\n                            tumor_names.push(id);\n                        }\n                    }\n                }\n                \n                if (tumor_names.length == 1){\n                    tumor_id = tumor_names[0];\n                }\n                \n                if (normal_names.length == 1){\n                    normal_id = normal_names[0];\n                }\n                \n                if (!tumor_id || tumor_names.length>1 || normal_names.length>1){\n                    tumor_id = 'mutect2';\n                    normal_id = '';\n                }\n            }\n            if (normal_id){\n                output = tumor_id + \"-\" + normal_id\n            } else {\n                output = tumor_id;\n            }\n        }\n        var name = output + suffix;\n        while (name.indexOf(\" \") > -1){\n            name = name.replace(\" \", \"_\")\n        }\n        return name;\n    } else {\n        return null;\n    }\n}"
          }
        ],
        "requirements": [
          {
            "class": "ShellCommandRequirement"
          },
          {
            "class": "ResourceRequirement",
            "ramMin": "${\n    var memory = 7500;\n    if (inputs.mem_per_job){\n        memory = inputs.mem_per_job;\n    }\n    var overhead = 500;\n    if (inputs.mem_overhead_per_job || inputs.mem_overhead_per_job == 0){\n        overhead = inputs.mem_overhead_per_job;\n    }\n    return memory + overhead;\n}",
            "coresMin": "${\n    var cpus = 1;\n    if (inputs.cpu_per_job){\n        cpus = inputs.cpu_per_job;\n    }\n    return cpus;\n}"
          },
          {
            "class": "DockerRequirement",
            "dockerPull": "images.sbgenomics.com/pavle.marinkovic/gatk_4-1-9-0:0"
          },
          {
            "class": "InitialWorkDirRequirement",
            "listing": []
          },
          {
            "class": "InlineJavascriptRequirement"
          }
        ],
        "sbg:categories": [
          "GATK-4",
          "CWL1.0"
        ],
        "sbg:image_url": null,
        "sbg:license": "Open source BSD (3-clause) license",
        "sbg:links": [
          {
            "id": "https://software.broadinstitute.org/gatk/",
            "label": "Homepage"
          },
          {
            "id": "https://github.com/broadinstitute/gatk/",
            "label": "Source"
          },
          {
            "id": "https://github.com/broadinstitute/gatk/releases/download/4.1.6.0/gatk-4.1.6.0.zip",
            "label": "Download"
          },
          {
            "id": "https://www.ncbi.nlm.nih.gov/pubmed?term=20644199",
            "label": "Publication"
          },
          {
            "id": "https://software.broadinstitute.org/gatk/documentation/tooldocs/4.1.6.0/org_broadinstitute_hellbender_tools_walkers_mutect_Mutect2.php",
            "label": "Documentation"
          }
        ],
        "sbg:projectName": "BUILD: Mitochondria Pipeline",
        "sbg:revisionsInfo": [
          {
            "sbg:revision": 0,
            "sbg:modifiedBy": "dave",
            "sbg:modifiedOn": 1622646232,
            "sbg:revisionNotes": "Uploaded using sbpack v2020.10.05. \nSource: gatk_mutect2_cwl1_0.cwl"
          },
          {
            "sbg:revision": 1,
            "sbg:modifiedBy": "dave",
            "sbg:modifiedOn": 1622834532,
            "sbg:revisionNotes": "single input file bam"
          },
          {
            "sbg:revision": 2,
            "sbg:modifiedBy": "dave",
            "sbg:modifiedOn": 1622834908,
            "sbg:revisionNotes": ""
          },
          {
            "sbg:revision": 3,
            "sbg:modifiedBy": "dave",
            "sbg:modifiedOn": 1622835842,
            "sbg:revisionNotes": "added .fai secondary file"
          },
          {
            "sbg:revision": 4,
            "sbg:modifiedBy": "dave",
            "sbg:modifiedOn": 1622855767,
            "sbg:revisionNotes": "^.dict"
          },
          {
            "sbg:revision": 5,
            "sbg:modifiedBy": "dave",
            "sbg:modifiedOn": 1622862857,
            "sbg:revisionNotes": ""
          }
        ],
        "sbg:toolAuthor": "Broad Institute",
        "sbg:toolkit": "GATK",
        "sbg:toolkitVersion": "4.1.9.0",
        "sbg:wrapperAuthor": "Pavle Marinkovic",
        "sbg:appVersion": [
          "v1.2"
        ],
        "sbg:id": "dave/build-mitochondria-pipeline/gatk-mutect2/5",
        "sbg:revision": 5,
        "sbg:revisionNotes": "",
        "sbg:modifiedOn": 1622862857,
        "sbg:modifiedBy": "dave",
        "sbg:createdOn": 1622646232,
        "sbg:createdBy": "dave",
        "sbg:project": "dave/build-mitochondria-pipeline",
        "sbg:sbgMaintained": false,
        "sbg:validationErrors": [],
        "sbg:contributors": [
          "dave"
        ],
        "sbg:latestRevision": 5,
        "sbg:publisher": "sbg",
        "sbg:content_hash": "acace08f44a80755f97843e88640bde484aaa476b26c41ac00ec1ff7cf2407fc2"
      },
      "label": "non shifted gatk",
      "sbg:x": 1311.981689453125,
      "sbg:y": 440.64208984375
    },
    {
      "id": "gatk_mutect2_shifted_mt",
      "in": [
        {
          "id": "in_alignments",
          "source": "bwa_mem_bundle_1/aligned_reads",
          "pickValue": "first_non_null"
        },
        {
          "id": "in_reference_and_index",
          "source": "in_reference_and_index"
        },
        {
          "id": "annotation",
          "default": [
            "StrandBiasBySample"
          ]
        },
        {
          "id": "read_filter",
          "default": [
            "MateOnSameContigOrNoMappedMateReadFilter",
            "MateUnmappedAndUnmappedReadFilter"
          ]
        },
        {
          "id": "max_mnp_distance",
          "default": 0
        }
      ],
      "out": [
        {
          "id": "out_variants"
        },
        {
          "id": "out_alignments"
        },
        {
          "id": "f1r2_counts"
        },
        {
          "id": "out_stats"
        }
      ],
      "run": {
        "class": "CommandLineTool",
        "cwlVersion": "v1.2",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "id": "dave/build-mitochondria-pipeline/gatk-mutect2/5",
        "baseCommand": [
          "/opt/gatk"
        ],
        "inputs": [
          {
            "sbg:altPrefix": "-I",
            "sbg:category": "Required Arguments",
            "id": "in_alignments",
            "type": "File",
            "inputBinding": {
              "prefix": "--input",
              "shellQuote": false,
              "position": 3
            },
            "label": "Input",
            "doc": "BAM/SAM/CRAM file containing reads this argument must be specified at least once.",
            "sbg:fileTypes": "BAM",
            "secondaryFiles": [
              {
                "pattern": ".bai"
              }
            ]
          },
          {
            "sbg:altPrefix": "-O",
            "sbg:category": "Required Arguments",
            "id": "output_filename",
            "type": "string?",
            "label": "Output File Name",
            "doc": "File to which variants should be written."
          },
          {
            "sbg:altPrefix": "-R",
            "sbg:category": "Required Arguments",
            "id": "in_reference_and_index",
            "type": "File",
            "inputBinding": {
              "prefix": "--reference",
              "shellQuote": false,
              "position": 4
            },
            "label": "Reference FASTA and index",
            "doc": "Reference FASTA or FA sequence file and associated index and dict.",
            "sbg:fileTypes": "FASTA, FA",
            "secondaryFiles": [
              {
                "pattern": ".fai",
                "required": true
              },
              {
                "pattern": "^.dict",
                "required": true
              }
            ]
          },
          {
            "sbg:category": "Optional Tool Arguments",
            "sbg:toolDefaultValue": "null",
            "id": "activity_profile_out",
            "type": "string?",
            "inputBinding": {
              "prefix": "--activity-profile-out",
              "shellQuote": false,
              "position": 4
            },
            "label": "Activity profile out",
            "doc": "Output the raw activity profile results in igv format."
          },
          {
            "sbg:altPrefix": "-add-output-sam-program-record",
            "sbg:category": "Optional Common Arguments",
            "sbg:toolDefaultValue": "true",
            "id": "add_output_sam_program_record",
            "type": [
              "null",
              {
                "type": "enum",
                "symbols": [
                  "true",
                  "false"
                ],
                "name": "add_output_sam_program_record"
              }
            ],
            "inputBinding": {
              "prefix": "--add-output-sam-program-record",
              "shellQuote": false,
              "position": 4
            },
            "label": "Add output sam program record",
            "doc": "If true, adds a pg tag to created sam/bam/cram files."
          },
          {
            "sbg:altPrefix": "-add-output-vcf-command-line",
            "sbg:category": "Optional Common Arguments",
            "sbg:toolDefaultValue": "true",
            "id": "add_output_vcf_command_line",
            "type": [
              "null",
              {
                "type": "enum",
                "symbols": [
                  "true",
                  "false"
                ],
                "name": "add_output_vcf_command_line"
              }
            ],
            "inputBinding": {
              "prefix": "--add-output-vcf-command-line",
              "shellQuote": false,
              "position": 4
            },
            "label": "Add output vcf command line",
            "doc": "If true, adds a command line header line to created vcf files."
          },
          {
            "sbg:altPrefix": "-default-af",
            "sbg:category": "Optional Tool Arguments",
            "sbg:toolDefaultValue": "-1",
            "id": "af_of_alleles_not_in_resource",
            "type": "float?",
            "inputBinding": {
              "prefix": "--af-of-alleles-not-in-resource",
              "shellQuote": false,
              "position": 4
            },
            "label": "Af of alleles not in resource",
            "doc": "Population allele fraction assigned to alleles not found in germline resource. Please see docs/mutect/mutect2.pdf fora derivation of the default value. 0.\nPopulation allele fraction assigned to alleles not found in germline resource."
          },
          {
            "sbg:category": "Optional Tool Arguments",
            "sbg:toolDefaultValue": "null",
            "id": "alleles",
            "type": "File?",
            "inputBinding": {
              "prefix": "--alleles",
              "shellQuote": false,
              "position": 4
            },
            "label": "Alleles",
            "doc": "The set of alleles for which to force genotyping regardless of evidence.",
            "sbg:fileTypes": "VCF, VCF.GZ",
            "secondaryFiles": [
              {
                "pattern": "${\n    if (self.nameext == \".vcf\")\n    {\n        return self.basename + \".idx\";\n    }\n    else\n    {\n        return self.basename + \".tbi\";\n    }\n}"
              }
            ]
          },
          {
            "sbg:altPrefix": "-A",
            "sbg:category": "Optional Tool Arguments",
            "sbg:toolDefaultValue": "null",
            "id": "annotation",
            "type": [
              "null",
              {
                "type": "array",
                "items": {
                  "type": "enum",
                  "name": "annotation",
                  "symbols": [
                    "AlleleFraction",
                    "AS_BaseQualityRankSumTest",
                    "AS_FisherStrand",
                    "AS_InbreedingCoeff",
                    "AS_MappingQualityRankSumTest",
                    "AS_QualByDepth",
                    "AS_ReadPosRankSumTest",
                    "AS_RMSMappingQuality",
                    "AS_StrandOddsRatio",
                    "BaseQuality",
                    "BaseQualityRankSumTest",
                    "ChromosomeCounts",
                    "ClippingRankSumTest",
                    "CountNs",
                    "Coverage",
                    "DepthPerAlleleBySample",
                    "DepthPerSampleHC",
                    "ExcessHet",
                    "FisherStrand",
                    "FragmentLength",
                    "GenotypeSummaries",
                    "InbreedingCoeff",
                    "LikelihoodRankSumTest",
                    "MappingQuality",
                    "MappingQualityRankSumTest",
                    "MappingQualityZero",
                    "OrientationBiasReadCounts",
                    "OriginalAlignment",
                    "PossibleDeNovo",
                    "QualByDepth",
                    "ReadPosition",
                    "ReadPosRankSumTest",
                    "ReferenceBases",
                    "RMSMappingQuality",
                    "SampleList",
                    "StrandBiasBySample",
                    "StrandOddsRatio",
                    "TandemRepeat",
                    "UniqueAltReadCount"
                  ]
                }
              }
            ],
            "inputBinding": {
              "prefix": "",
              "itemSeparator": " ",
              "shellQuote": false,
              "position": 4,
              "valueFrom": "${\n    var output = \"\";\n    for (var i=0; i<inputs.annotation.length; i++)\n    {\n        output = output + \"--annotation \" + inputs.annotation[i] + \" \";\n    }\n    return output;\n}"
            },
            "label": "Annotation",
            "doc": "One or more specific annotations to add to variant calls."
          },
          {
            "sbg:altPrefix": "-G",
            "sbg:category": "Optional Tool Arguments",
            "sbg:toolDefaultValue": "null",
            "id": "annotation_group",
            "type": [
              "null",
              {
                "type": "array",
                "items": {
                  "type": "enum",
                  "name": "annotation_group",
                  "symbols": [
                    "AS_StandardAnnotation",
                    "ReducibleAnnotation",
                    "StandardAnnotation",
                    "StandardHCAnnotation",
                    "StandardMutectAnnotation"
                  ]
                }
              }
            ],
            "inputBinding": {
              "prefix": "",
              "shellQuote": false,
              "position": 4,
              "valueFrom": "${\n    var output = \"\";\n    for (var i=0; i<inputs.annotation_group.length; i++)\n    {\n        output = output + \"--annotation-group \" + inputs.annotation_group[i] + \" \";\n    }\n    return output;\n}"
            },
            "label": "Annotation group",
            "doc": "One or more groups of annotations to apply to variant calls."
          },
          {
            "sbg:altPrefix": "-AX",
            "sbg:category": "Optional Tool Arguments",
            "sbg:toolDefaultValue": "null",
            "id": "annotations_to_exclude",
            "type": [
              "null",
              {
                "type": "array",
                "items": {
                  "type": "enum",
                  "name": "annotations_to_exclude",
                  "symbols": [
                    "BaseQuality",
                    "Coverage",
                    "DepthPerAlleleBySample",
                    "DepthPerSampleHC",
                    "FragmentLength",
                    "MappingQuality",
                    "OrientationBiasReadCounts",
                    "ReadPosition",
                    "StrandBiasBySample",
                    "TandemRepeat"
                  ]
                }
              }
            ],
            "inputBinding": {
              "prefix": "",
              "shellQuote": false,
              "position": 4,
              "valueFrom": "${\n    var output = \"\";\n    for (var i=0; i<inputs.annotations_to_exclude.length; i++)\n    {\n        output = output + \"--annotations-to-exclude \" + inputs.annotations_to_exclude[i] + \" \";\n    }\n    return output;\n}"
            },
            "label": "Annotations to exclude",
            "doc": "One or more specific annotations to exclude from variant calls."
          },
          {
            "sbg:category": "Optional Tool Arguments",
            "sbg:toolDefaultValue": "null",
            "id": "arguments_file",
            "type": "File[]?",
            "inputBinding": {
              "prefix": "",
              "shellQuote": false,
              "position": 4,
              "valueFrom": "${\n    var output = \"\";\n    for (var i=0; i<inputs.arguments_file.length; i++)\n    {\n        output = output + \"--arguments_file \" + inputs.arguments_file[i].path + \" \";\n    }\n    return output;\n}"
            },
            "label": "Arguments file",
            "doc": "Read one or more arguments files and add them to the command line."
          },
          {
            "sbg:category": "Optional Tool Arguments",
            "sbg:toolDefaultValue": "null",
            "id": "assembly_region_out",
            "type": "string?",
            "inputBinding": {
              "prefix": "--assembly-region-out",
              "shellQuote": false,
              "position": 4
            },
            "label": "Assembly region out",
            "doc": "Output the assembly region to this igv formatted file."
          },
          {
            "sbg:category": "Optional Tool Arguments",
            "sbg:toolDefaultValue": "18",
            "id": "base_quality_score_threshold",
            "type": "int?",
            "inputBinding": {
              "prefix": "--base-quality-score-threshold",
              "shellQuote": false,
              "position": 4
            },
            "label": "Base quality score threshold",
            "doc": "Base qualities below this threshold will be reduced to the minimum (6)."
          },
          {
            "sbg:category": "Optional Tool Arguments",
            "sbg:toolDefaultValue": "10",
            "id": "callable_depth",
            "type": "int?",
            "inputBinding": {
              "prefix": "--callable-depth",
              "shellQuote": false,
              "position": 4
            },
            "label": "Callable depth",
            "doc": "Minimum depth to be considered callable for mutect stats. Does not affect genotyping."
          },
          {
            "sbg:altPrefix": "-CIPB",
            "sbg:category": "Optional Tool Arguments",
            "sbg:toolDefaultValue": "-1",
            "id": "cloud_index_prefetch_buffer",
            "type": "int?",
            "inputBinding": {
              "prefix": "--cloud-index-prefetch-buffer",
              "shellQuote": false,
              "position": 4
            },
            "label": "Cloud index prefetch buffer",
            "doc": "Size of the cloud-only prefetch buffer (in mb; 0 to disable). Defaults to cloudprefetchbuffer if unset."
          },
          {
            "sbg:altPrefix": "-CPB",
            "sbg:category": "Optional Tool Arguments",
            "sbg:toolDefaultValue": "40",
            "id": "cloud_prefetch_buffer",
            "type": "int?",
            "inputBinding": {
              "prefix": "--cloud-prefetch-buffer",
              "shellQuote": false,
              "position": 4
            },
            "label": "Cloud prefetch buffer",
            "doc": "Size of the cloud-only prefetch buffer (in mb; 0 to disable)."
          },
          {
            "sbg:altPrefix": "-OBI",
            "sbg:category": "Optional Common Arguments",
            "sbg:toolDefaultValue": "true",
            "id": "create_output_bam_index",
            "type": "boolean?",
            "inputBinding": {
              "prefix": "--create-output-bam-index",
              "shellQuote": false,
              "position": 4
            },
            "label": "Create output bam index",
            "doc": "If true, create a bam/cram index when writing a coordinate-sorted bam/cram file."
          },
          {
            "sbg:altPrefix": "-OBM",
            "sbg:category": "Optional Common Arguments",
            "sbg:toolDefaultValue": "false",
            "id": "create_output_bam_md5",
            "type": "boolean?",
            "inputBinding": {
              "prefix": "--create-output-bam-md5",
              "shellQuote": false,
              "position": 4
            },
            "label": "Create output bam md5",
            "doc": "If true, create a md5 digest for any BAM/SAM/CRAM file created."
          },
          {
            "sbg:altPrefix": "-OVI",
            "sbg:category": "Optional Common Arguments",
            "sbg:toolDefaultValue": "true",
            "id": "create_output_variant_index",
            "type": "boolean?",
            "inputBinding": {
              "prefix": "--create-output-variant-index",
              "shellQuote": false,
              "position": 4
            },
            "label": "Create output variant index",
            "doc": "If true, create a vcf index when writing a coordinate-sorted vcf file."
          },
          {
            "sbg:altPrefix": "-OVM",
            "sbg:category": "Optional Common Arguments",
            "sbg:toolDefaultValue": "false",
            "id": "create_output_variant_md5",
            "type": "boolean?",
            "inputBinding": {
              "prefix": "--create-output-variant-md5",
              "shellQuote": false,
              "position": 4
            },
            "label": "Create output variant md5",
            "doc": "If true, create a a md5 digest any vcf file created."
          },
          {
            "sbg:altPrefix": "-DBIC",
            "sbg:category": "Optional Tool Arguments",
            "sbg:toolDefaultValue": "false",
            "id": "disable_bam_index_caching",
            "type": "boolean?",
            "inputBinding": {
              "prefix": "--disable-bam-index-caching",
              "shellQuote": false,
              "position": 4
            },
            "label": "Disable bam index caching",
            "doc": "If true, don't cache bam indexes, this will reduce memory requirements but may harm performance if many intervals are specified. Caching is automatically disabled if there are no intervals specified."
          },
          {
            "sbg:altPrefix": "-DF",
            "sbg:category": "Optional Common Arguments",
            "sbg:toolDefaultValue": "null",
            "id": "disable_read_filter",
            "type": [
              "null",
              {
                "type": "array",
                "items": {
                  "type": "enum",
                  "name": "disable_read_filter",
                  "symbols": [
                    "GoodCigarReadFilter",
                    "MappedReadFilter",
                    "MappingQualityAvailableReadFilter",
                    "MappingQualityNotZeroReadFilter",
                    "MappingQualityReadFilter",
                    "NonChimericOriginalAlignmentReadFilter",
                    "NonZeroReferenceLengthAlignmentReadFilter",
                    "NotDuplicateReadFilter",
                    "NotSecondaryAlignmentReadFilter",
                    "PassesVendorQualityCheckReadFilter",
                    "ReadLengthReadFilter",
                    "WellformedReadFilter"
                  ]
                }
              }
            ],
            "inputBinding": {
              "prefix": "",
              "shellQuote": false,
              "position": 4,
              "valueFrom": "${\n    var output = \"\";\n    for (var i=0; i<inputs.disable_read_filter.length; i++)\n    {\n        output = output + \"--disable-read-filter \" + inputs.disable_read_filter[i] + \" \";\n    }\n    return output;\n}"
            },
            "label": "Disable read filter",
            "doc": "Read filters to be disabled before analysis."
          },
          {
            "sbg:altPrefix": "-disable-sequence-dictionary-validation",
            "sbg:category": "Optional Tool Arguments",
            "sbg:toolDefaultValue": "false",
            "id": "disable_sequence_dictionary_validation",
            "type": "boolean?",
            "inputBinding": {
              "prefix": "--disable-sequence-dictionary-validation",
              "shellQuote": false,
              "position": 4
            },
            "label": "Disable sequence dictionary validation",
            "doc": "If specified, do not check the sequence dictionaries from our inputs for compatibility. Use at your own risk!"
          },
          {
            "sbg:altPrefix": "-stride",
            "sbg:category": "Optional Tool Arguments",
            "sbg:toolDefaultValue": "1",
            "id": "downsampling_stride",
            "type": "int?",
            "inputBinding": {
              "prefix": "--downsampling-stride",
              "shellQuote": false,
              "position": 4
            },
            "label": "Downsampling stride",
            "doc": "Downsample a pool of reads starting within a range of one or more bases."
          },
          {
            "sbg:altPrefix": "-XL",
            "sbg:category": "Optional Common Arguments",
            "sbg:toolDefaultValue": "null",
            "id": "exclude_intervals",
            "type": "string[]?",
            "inputBinding": {
              "prefix": "",
              "shellQuote": false,
              "position": 4,
              "valueFrom": "${\n    var output = \"\";\n    for (var i=0; i<inputs.exclude_intervals.length; i++)\n    {\n        output = output + \"--exclude-intervals \" + inputs.exclude_intervals[i] + \" \";\n    }\n    return output;\n}"
            },
            "label": "Exclude intervals",
            "doc": "Or more genomic intervals to exclude from processing."
          },
          {
            "sbg:category": "Optional Tool Arguments",
            "sbg:toolDefaultValue": "200",
            "id": "f1r2_max_depth",
            "type": "int?",
            "inputBinding": {
              "prefix": "--f1r2-max-depth",
              "shellQuote": false,
              "position": 4
            },
            "label": "F1r2 max depth",
            "doc": "Sites with depth higher than this value will be grouped."
          },
          {
            "sbg:category": "Optional Tool Arguments",
            "sbg:toolDefaultValue": "50",
            "id": "f1r2_median_mq",
            "type": "int?",
            "inputBinding": {
              "prefix": "--f1r2-median-mq",
              "shellQuote": false,
              "position": 4
            },
            "label": "F1r2 median mq",
            "doc": "Skip sites with median mapping quality below this value."
          },
          {
            "sbg:category": "Optional Tool Arguments",
            "sbg:toolDefaultValue": "20",
            "id": "f1r2_min_bq",
            "type": "int?",
            "inputBinding": {
              "prefix": "--f1r2-min-bq",
              "shellQuote": false,
              "position": 4
            },
            "label": "F1r2 min bq",
            "doc": "Exclude bases below this quality from pileup."
          },
          {
            "sbg:category": "Optional Tool Arguments",
            "sbg:toolDefaultValue": "null",
            "id": "f1r2_tar_gz",
            "type": "string?",
            "label": "F1r2 filename",
            "doc": "If specified, collect f1r2 counts and output files into this tar.gz file."
          },
          {
            "sbg:altPrefix": "-founder-id",
            "sbg:category": "Optional Tool Arguments",
            "sbg:toolDefaultValue": "null",
            "id": "founder_id",
            "type": "string[]?",
            "inputBinding": {
              "prefix": "",
              "shellQuote": false,
              "position": 4,
              "valueFrom": "${\n    var output = \"\";\n    for (var i=0; i<inputs.founder_id.length; i++)\n    {\n        output = output + \"--founder-id \" + inputs.founder_id[i] + \" \";\n    }\n    return output;\n}"
            },
            "label": "Founder id",
            "doc": "Samples representing the population \"founders\"."
          },
          {
            "sbg:category": "Optional Common Arguments",
            "sbg:toolDefaultValue": "null",
            "id": "gatk_config_file",
            "type": "File?",
            "inputBinding": {
              "prefix": "--gatk-config-file",
              "shellQuote": false,
              "position": 4
            },
            "label": "Gatk config file",
            "doc": "A configuration file to use with the gatk."
          },
          {
            "sbg:altPrefix": "-gcs-retries",
            "sbg:category": "Optional Tool Arguments",
            "sbg:toolDefaultValue": "20",
            "id": "gcs_max_retries",
            "type": "int?",
            "inputBinding": {
              "prefix": "--gcs-max-retries",
              "shellQuote": false,
              "position": 4
            },
            "label": "Gcs max retries",
            "doc": "If the gcs bucket channel errors out, how many times it will attempt to re-initiate the connection."
          },
          {
            "sbg:category": "Optional Tool Arguments",
            "id": "gcs_project_for_requester_pays",
            "type": "string?",
            "inputBinding": {
              "prefix": "--gcs-project-for-requester-pays",
              "shellQuote": false,
              "position": 4
            },
            "label": "Gcs project for requester pays",
            "doc": "Project to bill when accessing \"requester pays\" buckets. If unset, these buckets cannot be accessed. Default value: ."
          },
          {
            "sbg:category": "Optional Tool Arguments",
            "sbg:toolDefaultValue": "false",
            "id": "genotype_germline_sites",
            "type": "boolean?",
            "inputBinding": {
              "prefix": "--genotype-germline-sites",
              "shellQuote": false,
              "position": 4
            },
            "label": "Genotype germline sites",
            "doc": "(experimental) call all apparent germline site even though they will ultimately be filtered."
          },
          {
            "sbg:category": "Optional Tool Arguments",
            "sbg:toolDefaultValue": "false",
            "id": "genotype_pon_sites",
            "type": "boolean?",
            "inputBinding": {
              "prefix": "--genotype-pon-sites",
              "shellQuote": false,
              "position": 4
            },
            "label": "Genotype pon sites",
            "doc": "Call sites in the pon even though they will ultimately be filtered."
          },
          {
            "sbg:category": "Optional Tool Arguments",
            "sbg:toolDefaultValue": "null",
            "id": "germline_resource",
            "type": "File?",
            "inputBinding": {
              "prefix": "--germline-resource",
              "shellQuote": false,
              "position": 4
            },
            "label": "Germline resource",
            "doc": "Population vcf of germline sequencing containing allele fractions. (typically gNOMAD)",
            "sbg:fileTypes": "VCF, VCF.GZ",
            "secondaryFiles": [
              {
                "pattern": "${\n    if (self.nameext == \".vcf\")\n    {\n        return self.basename + \".idx\";\n    }\n    else\n    {\n        return self.basename + \".tbi\";\n    }\n}"
              }
            ]
          },
          {
            "sbg:altPrefix": "-graph",
            "sbg:category": "Optional Tool Arguments",
            "sbg:toolDefaultValue": "null",
            "id": "graph_output",
            "type": "string?",
            "inputBinding": {
              "prefix": "--graph-output",
              "shellQuote": false,
              "position": 4
            },
            "label": "Graph output",
            "doc": "Write debug assembly graph information to this file."
          },
          {
            "sbg:category": "Optional Tool Arguments",
            "sbg:toolDefaultValue": "false",
            "id": "ignore_itr_artifacts",
            "type": "boolean?",
            "inputBinding": {
              "prefix": "--ignore-itr-artifacts",
              "shellQuote": false,
              "position": 4
            },
            "label": "Ignore itr artifacts",
            "doc": "Off read transformer that clips artifacts associated with end repair insertions near inverted tandem repeats."
          },
          {
            "sbg:altPrefix": "-init-lod",
            "sbg:category": "Optional Tool Arguments",
            "sbg:toolDefaultValue": "2.0",
            "id": "initial_tumor_lod",
            "type": "float?",
            "inputBinding": {
              "prefix": "--initial-tumor-lod",
              "shellQuote": false,
              "position": 4
            },
            "label": "Initial tumor lod",
            "doc": "Log 10 odds threshold to consider pileup active. 0."
          },
          {
            "sbg:altPrefix": "-ixp",
            "sbg:category": "Optional Common Arguments",
            "sbg:toolDefaultValue": "0",
            "id": "interval_exclusion_padding",
            "type": "int?",
            "inputBinding": {
              "prefix": "--interval-exclusion-padding",
              "shellQuote": false,
              "position": 4
            },
            "label": "Interval exclusion padding",
            "doc": "Amount of padding (in bp) to add to each interval you are excluding."
          },
          {
            "sbg:altPrefix": "-imr",
            "sbg:category": "Optional Tool Arguments",
            "sbg:toolDefaultValue": "ALL",
            "id": "interval_merging_rule",
            "type": [
              "null",
              {
                "type": "enum",
                "symbols": [
                  "ALL",
                  "OVERLAPPING_ONLY"
                ],
                "name": "interval_merging_rule"
              }
            ],
            "inputBinding": {
              "prefix": "--interval-merging-rule",
              "shellQuote": false,
              "position": 4
            },
            "label": "Interval merging rule",
            "doc": "Interval merging rule for abutting intervals."
          },
          {
            "sbg:altPrefix": "-ip",
            "sbg:category": "Optional Common Arguments",
            "sbg:toolDefaultValue": "0",
            "id": "interval_padding",
            "type": "int?",
            "inputBinding": {
              "prefix": "--interval-padding",
              "shellQuote": false,
              "position": 4
            },
            "label": "Interval padding",
            "doc": "Of padding (in bp) to add to each interval you are including."
          },
          {
            "sbg:altPrefix": "-isr",
            "sbg:category": "Optional Common Arguments",
            "sbg:toolDefaultValue": "UNION",
            "id": "interval_set_rule",
            "type": [
              "null",
              {
                "type": "enum",
                "symbols": [
                  "UNION",
                  "INTERSECTION"
                ],
                "name": "interval_set_rule"
              }
            ],
            "inputBinding": {
              "prefix": "--interval-set-rule",
              "shellQuote": false,
              "position": 4
            },
            "label": "Interval set rule",
            "doc": "Set merging approach to use for combining interval inputs."
          },
          {
            "sbg:altPrefix": "-L",
            "sbg:category": "Optional Tool Arguments",
            "sbg:toolDefaultValue": "null",
            "id": "intervals",
            "type": "string[]?",
            "inputBinding": {
              "prefix": "",
              "shellQuote": false,
              "position": 4,
              "valueFrom": "${\n    var output = \"\";\n    for (var i=0; i<inputs.intervals.length; i++){\n        output += \" --intervals \" + inputs.intervals[i];\n    }\n    return output;\n}"
            },
            "label": "Intervals",
            "doc": "One or more genomic intervals over which to operate."
          },
          {
            "sbg:altPrefix": "-LE",
            "sbg:category": "Optional Common Arguments",
            "sbg:toolDefaultValue": "false",
            "id": "lenient",
            "type": "boolean?",
            "inputBinding": {
              "prefix": "--lenient",
              "shellQuote": false,
              "position": 4
            },
            "label": "Lenient",
            "doc": "Lenient processing of vcf files."
          },
          {
            "sbg:altPrefix": "-max-af",
            "sbg:category": "Optional Tool Arguments",
            "sbg:toolDefaultValue": "0.01",
            "id": "max_population_af",
            "type": "float?",
            "inputBinding": {
              "prefix": "--max-population-af",
              "shellQuote": false,
              "position": 4
            },
            "label": "Max population af",
            "doc": "Maximum population allele frequency in tumor-only mode. 01."
          },
          {
            "sbg:category": "Optional Tool Arguments",
            "sbg:toolDefaultValue": "50",
            "id": "max_reads_per_alignment_start",
            "type": "int?",
            "inputBinding": {
              "prefix": "--max-reads-per-alignment-start",
              "shellQuote": false,
              "position": 4
            },
            "label": "Max reads per alignment start",
            "doc": "Maximum number of reads to retain per alignment start position. Reads above this threshold will be downsampled. Set to 0 to disable."
          },
          {
            "sbg:altPrefix": "-mbq",
            "sbg:category": "Optional Tool Arguments",
            "sbg:toolDefaultValue": "10",
            "id": "min_base_quality_score",
            "type": "string?",
            "inputBinding": {
              "prefix": "--min-base-quality-score",
              "shellQuote": false,
              "position": 4
            },
            "label": "Min base quality score",
            "doc": "Minimum base quality required to consider a base for calling."
          },
          {
            "sbg:category": "Optional Tool Arguments",
            "sbg:toolDefaultValue": "false",
            "id": "mitochondria_mode",
            "type": "boolean?",
            "inputBinding": {
              "prefix": "--mitochondria-mode",
              "shellQuote": false,
              "position": 4
            },
            "label": "Mitochondria mode",
            "doc": "Mitochondria mode sets emission and initial lods to 0."
          },
          {
            "sbg:category": "Optional Tool Arguments",
            "sbg:toolDefaultValue": "4",
            "id": "native_pair_hmm_threads",
            "type": "int?",
            "inputBinding": {
              "prefix": "--native-pair-hmm-threads",
              "shellQuote": false,
              "position": 4
            },
            "label": "Native pair hmm threads",
            "doc": "How many threads should a native pairhmm implementation use."
          },
          {
            "sbg:category": "Optional Tool Arguments",
            "sbg:toolDefaultValue": "false",
            "id": "native_pair_hmm_use_double_precision",
            "type": "boolean?",
            "inputBinding": {
              "prefix": "--native-pair-hmm-use-double-precision",
              "shellQuote": false,
              "position": 4
            },
            "label": "Native pair hmm use double precision",
            "doc": "Use double precision in the native pairhmm. This is slower but matches the java implementation better."
          },
          {
            "sbg:category": "Optional Tool Arguments",
            "sbg:toolDefaultValue": "2.2",
            "id": "normal_lod",
            "type": "float?",
            "inputBinding": {
              "prefix": "--normal-lod",
              "shellQuote": false,
              "position": 4
            },
            "label": "Normal lod",
            "doc": "Log 10 odds threshold for calling normal variant non-germline. 2."
          },
          {
            "sbg:altPrefix": "-normal",
            "sbg:category": "Optional Tool Arguments",
            "sbg:toolDefaultValue": "null",
            "id": "normal_sample",
            "type": [
              "null",
              {
                "type": "array",
                "items": [
                  "string",
                  "null"
                ]
              }
            ],
            "inputBinding": {
              "shellQuote": false,
              "position": 4,
              "valueFrom": "${\n    var output = \"\";\n    var normal_samples = [].concat(self);\n    for (var i=0; i<normal_samples.length; i++)\n    {\n        if (normal_samples[i])\n        {\n            output = output + '--normal-sample \"' \n                    + normal_samples[i] + '\" ';   \n        }\n    }\n    return output;\n}"
            },
            "label": "Normal sample",
            "doc": "Sample name of normal(s), if any. May be url-encoded as output by getsamplename with -encode argument."
          },
          {
            "sbg:altPrefix": "-pon",
            "sbg:category": "Optional Tool Arguments",
            "sbg:toolDefaultValue": "null",
            "id": "panel_of_normals",
            "type": "File?",
            "inputBinding": {
              "prefix": "--panel-of-normals",
              "shellQuote": false,
              "position": 4
            },
            "label": "Panel of normals",
            "doc": "Vcf file of sites observed in normal.",
            "sbg:fileTypes": "VCF, VCF.GZ",
            "secondaryFiles": [
              {
                "pattern": "${\n    if (self.nameext == \".vcf\")\n    {\n        return self.basename + \".idx\";\n    }\n    else\n    {\n        return self.basename + \".tbi\";\n    }\n}"
              }
            ]
          },
          {
            "sbg:category": "Optional Tool Arguments",
            "sbg:toolDefaultValue": "40",
            "id": "pcr_indel_qual",
            "type": "int?",
            "inputBinding": {
              "prefix": "--pcr-indel-qual",
              "shellQuote": false,
              "position": 4
            },
            "label": "Pcr indel qual",
            "doc": "Phred-scaled pcr snv qual for overlapping fragments."
          },
          {
            "sbg:category": "Optional Tool Arguments",
            "sbg:toolDefaultValue": "40",
            "id": "pcr_snv_qual",
            "type": "int?",
            "inputBinding": {
              "prefix": "--pcr-snv-qual",
              "shellQuote": false,
              "position": 4
            },
            "label": "Pcr snv qual",
            "doc": "Phred-scaled pcr snv qual for overlapping fragments."
          },
          {
            "sbg:altPrefix": "-ped",
            "sbg:category": "Optional Tool Arguments",
            "sbg:toolDefaultValue": "null",
            "id": "pedigree",
            "type": "File?",
            "inputBinding": {
              "prefix": "--pedigree",
              "shellQuote": false,
              "position": 4
            },
            "label": "Pedigree",
            "doc": "Pedigree file for determining the population \"founders\"."
          },
          {
            "sbg:altPrefix": "-RF",
            "sbg:category": "Optional Common Arguments",
            "sbg:toolDefaultValue": "null",
            "id": "read_filter",
            "type": [
              "null",
              {
                "type": "array",
                "items": {
                  "type": "enum",
                  "name": "read_filter",
                  "symbols": [
                    "AlignmentAgreesWithHeaderReadFilter",
                    "AllowAllReadsReadFilter",
                    "AmbiguousBaseReadFilter",
                    "CigarContainsNoNOperator",
                    "FirstOfPairReadFilter",
                    "FragmentLengthReadFilter",
                    "GoodCigarReadFilter",
                    "HasReadGroupReadFilter",
                    "IntervalOverlapReadFilter",
                    "LibraryReadFilter",
                    "MappedReadFilter",
                    "MappingQualityAvailableReadFilter",
                    "MappingQualityNotZeroReadFilter",
                    "MappingQualityReadFilter",
                    "MatchingBasesAndQualsReadFilter",
                    "MateDifferentStrandReadFilter",
                    "MateOnSameContigOrNoMappedMateReadFilter",
                    "MateUnmappedAndUnmappedReadFilter",
                    "MetricsReadFilter",
                    "NonChimericOriginalAlignmentReadFilter",
                    "NonZeroFragmentLengthReadFilter",
                    "NonZeroReferenceLengthAlignmentReadFilter",
                    "NotDuplicateReadFilter",
                    "NotOpticalDuplicateReadFilter",
                    "NotSecondaryAlignmentReadFilter",
                    "NotSupplementaryAlignmentReadFilter",
                    "OverclippedReadFilter",
                    "PairedReadFilter",
                    "PassesVendorQualityCheckReadFilter",
                    "PlatformReadFilter",
                    "PlatformUnitReadFilter",
                    "PrimaryLineReadFilter",
                    "ProperlyPairedReadFilter",
                    "ReadGroupBlackListReadFilter",
                    "ReadGroupReadFilter",
                    "ReadLengthEqualsCigarLengthReadFilter",
                    "ReadLengthReadFilter",
                    "ReadNameReadFilter",
                    "ReadStrandFilter",
                    "SampleReadFilter",
                    "SecondOfPairReadFilter",
                    "SeqIsStoredReadFilter",
                    "ValidAlignmentEndReadFilter",
                    "ValidAlignmentStartReadFilter",
                    "WellformedReadFilter"
                  ]
                }
              }
            ],
            "inputBinding": {
              "prefix": "",
              "shellQuote": false,
              "position": 4,
              "valueFrom": "${\n    var output = \"\";\n    for (var i=0; i<inputs.read_filter.length; i++)\n    {\n        output = output + \"--read-filter \" + inputs.read_filter[i] + \" \";\n    }\n    return output;\n}"
            },
            "label": "Read filter",
            "doc": "Read filters to be applied before analysis."
          },
          {
            "sbg:altPrefix": "-read-index",
            "sbg:category": "Optional Common Arguments",
            "sbg:toolDefaultValue": "null",
            "id": "read_index",
            "type": "File[]?",
            "inputBinding": {
              "prefix": "--read-index",
              "shellQuote": false,
              "position": 4,
              "valueFrom": "${\n    var output = \"\";\n    for (var i=0; i<inputs.read_index.length; i++)\n    {\n        output = output + \"--read-index \" + inputs.read_index[i].path + \" \";\n    }\n    return output;\n}"
            },
            "label": "Read index",
            "doc": "Indices to use for the read inputs. If specified, an index must be provided for every read input and in the same order as the read inputs. If this argument is not specified, the path to the index for each input will be inferred automatically."
          },
          {
            "sbg:altPrefix": "-VS",
            "sbg:category": "Optional Common Arguments",
            "sbg:toolDefaultValue": "SILENT",
            "id": "read_validation_stringency",
            "type": [
              "null",
              {
                "type": "enum",
                "symbols": [
                  "STRICT",
                  "LENIENT",
                  "SILENT"
                ],
                "name": "read_validation_stringency"
              }
            ],
            "inputBinding": {
              "prefix": "--read-validation-stringency",
              "shellQuote": false,
              "position": 4
            },
            "label": "Read validation stringency",
            "doc": "Validation stringency for all sam/bam/cram/sra files read by this program. The default stringency value silent can improve performance when processing a bam file in which variable-length data (read, qualities, tags) do not otherwise need to be decoded."
          },
          {
            "sbg:altPrefix": "-seconds-between-progress-updates",
            "sbg:category": "Optional Common Arguments",
            "sbg:toolDefaultValue": "10.0",
            "id": "seconds_between_progress_updates",
            "type": "float?",
            "inputBinding": {
              "prefix": "--seconds-between-progress-updates",
              "shellQuote": false,
              "position": 4
            },
            "label": "Seconds between progress updates",
            "doc": "Output traversal statistics every time this many seconds elapse 0."
          },
          {
            "sbg:altPrefix": "-sequence-dictionary",
            "sbg:category": "Optional Common Arguments",
            "sbg:toolDefaultValue": "null",
            "id": "sequence_dictionary",
            "type": "File?",
            "inputBinding": {
              "prefix": "--sequence-dictionary",
              "shellQuote": false,
              "position": 4,
              "valueFrom": "${\n    if (self){\n        self = [].concat(self)[0];\n        if (self.nameext != \".dict\" && self.secondaryFiles && self.secondaryFiles[0]){\n            for (var i = 0; i < self.secondaryFiles.length; i ++){\n                if (self.secondaryFiles[i].nameext == '.dict'){\n                    return self.secondaryFiles[i].path;\n                }\n            }\n        }\n        return self.path;\n    } else {\n        return null;\n    }\n}"
            },
            "label": "Sequence dictionary",
            "doc": "Use the given sequence dictionary as the master/canonical sequence dictionary. Must be a .dict file.",
            "sbg:fileTypes": "DICT"
          },
          {
            "sbg:category": "Optional Tool Arguments",
            "sbg:toolDefaultValue": "false",
            "id": "sites_only_vcf_output",
            "type": "boolean?",
            "inputBinding": {
              "prefix": "--sites-only-vcf-output",
              "shellQuote": false,
              "position": 4
            },
            "label": "Sites only vcf output",
            "doc": "If true, don't emit genotype fields when writing vcf file output."
          },
          {
            "sbg:altPrefix": "-emit-lod",
            "sbg:category": "Optional Tool Arguments",
            "sbg:toolDefaultValue": "3,0",
            "id": "tumor_lod_to_emit",
            "type": "float?",
            "inputBinding": {
              "prefix": "--tumor-lod-to-emit",
              "shellQuote": false,
              "position": 4
            },
            "label": "Tumor lod to emit",
            "doc": "Log 10 odds threshold to emit variant to vcf. 0."
          },
          {
            "sbg:altPrefix": "-tumor",
            "sbg:category": "Deprecated Arguments",
            "sbg:toolDefaultValue": "null",
            "id": "tumor_sample",
            "type": "string?",
            "inputBinding": {
              "prefix": "--tumor-sample",
              "shellQuote": false,
              "position": 4,
              "valueFrom": "${\n    return '\"' + self + '\"';\n}"
            },
            "label": "Tumor sample",
            "doc": "Bam sample name of tumor. May be url-encoded as output by getsamplename with -encode argument."
          },
          {
            "sbg:altPrefix": "-jdk-deflater",
            "sbg:category": "Optional Common Arguments",
            "sbg:toolDefaultValue": "false",
            "id": "use_jdk_deflater",
            "type": "boolean?",
            "inputBinding": {
              "prefix": "--use-jdk-deflater",
              "shellQuote": false,
              "position": 4
            },
            "label": "Use jdk deflater",
            "doc": "Whether to use the jdkdeflater (as opposed to inteldeflater)."
          },
          {
            "sbg:altPrefix": "-jdk-inflater",
            "sbg:category": "Optional Common Arguments",
            "sbg:toolDefaultValue": "false",
            "id": "use_jdk_inflater",
            "type": "boolean?",
            "inputBinding": {
              "prefix": "--use-jdk-inflater",
              "shellQuote": false,
              "position": 4
            },
            "label": "Use jdk inflater",
            "doc": "Whether to use the jdkinflater (as opposed to intelinflater)."
          },
          {
            "sbg:altPrefix": "-verbosity",
            "sbg:category": "Optional Common Arguments",
            "sbg:toolDefaultValue": "INFO",
            "id": "verbosity",
            "type": [
              "null",
              {
                "type": "enum",
                "symbols": [
                  "ERROR",
                  "WARNING",
                  "INFO",
                  "DEBUG"
                ],
                "name": "verbosity"
              }
            ],
            "inputBinding": {
              "prefix": "--verbosity",
              "shellQuote": false,
              "position": 4
            },
            "label": "Verbosity",
            "doc": "Control verbosity of logging."
          },
          {
            "sbg:category": "Advanced Arguments",
            "sbg:toolDefaultValue": "0",
            "id": "active_probability_threshold",
            "type": "float?",
            "inputBinding": {
              "prefix": "--active-probability-threshold",
              "shellQuote": false,
              "position": 4
            },
            "label": "Active probability threshold",
            "doc": "Minimum probability for a locus to be considered active. 002."
          },
          {
            "sbg:category": "Advanced Arguments",
            "sbg:toolDefaultValue": "0",
            "id": "adaptive_pruning_initial_error_rate",
            "type": "float?",
            "inputBinding": {
              "prefix": "--adaptive-pruning-initial-error-rate",
              "shellQuote": false,
              "position": 4
            },
            "label": "Adaptive pruning initial error rate",
            "doc": "Initial base error rate estimate for adaptive pruning 001."
          },
          {
            "sbg:category": "Advanced Arguments",
            "sbg:toolDefaultValue": "false",
            "id": "allow_non_unique_kmers_in_ref",
            "type": "boolean?",
            "inputBinding": {
              "prefix": "--allow-non-unique-kmers-in-ref",
              "shellQuote": false,
              "position": 4
            },
            "label": "Allow non unique kmers in ref",
            "doc": "Allow graphs that have non-unique kmers in the reference."
          },
          {
            "sbg:category": "Advanced Arguments",
            "sbg:toolDefaultValue": "100",
            "id": "assembly_region_padding",
            "type": "int?",
            "inputBinding": {
              "prefix": "--assembly-region-padding",
              "shellQuote": false,
              "position": 4
            },
            "label": "Assembly region padding",
            "doc": "Number of additional bases of context to include around each assembly region."
          },
          {
            "sbg:category": "Advanced Arguments",
            "sbg:toolDefaultValue": "CALLED_HAPLOTYPES",
            "id": "bam_writer_type",
            "type": [
              "null",
              {
                "type": "enum",
                "symbols": [
                  "ALL_POSSIBLE_HAPLOTYPES",
                  "CALLED_HAPLOTYPES"
                ],
                "name": "bam_writer_type"
              }
            ],
            "inputBinding": {
              "prefix": "--bam-writer-type",
              "shellQuote": false,
              "position": 4
            },
            "label": "Bam writer type",
            "doc": "Which haplotypes should be written to the bam."
          },
          {
            "sbg:altPrefix": "-debug",
            "sbg:category": "Advanced Arguments",
            "sbg:toolDefaultValue": "false",
            "id": "debug_assembly",
            "type": "boolean?",
            "inputBinding": {
              "prefix": "--debug-assembly",
              "shellQuote": false,
              "position": 4
            },
            "label": "Debug assembly",
            "doc": "Print out verbose debug information about each assembly region."
          },
          {
            "sbg:category": "Advanced Arguments",
            "sbg:toolDefaultValue": "false",
            "id": "disable_adaptive_pruning",
            "type": "boolean?",
            "inputBinding": {
              "prefix": "--disable-adaptive-pruning",
              "shellQuote": false,
              "position": 4
            },
            "label": "Disable adaptive pruning",
            "doc": "Disable the adaptive algorithm for pruning paths in the graph."
          },
          {
            "sbg:altPrefix": "-disable-tool-default-annotations",
            "sbg:category": "Advanced Arguments",
            "sbg:toolDefaultValue": "false",
            "id": "disable_tool_default_annotations",
            "type": "boolean?",
            "inputBinding": {
              "prefix": "--disable-tool-default-annotations",
              "shellQuote": false,
              "position": 4
            },
            "label": "Disable tool default annotations",
            "doc": "Disable all tool default annotations."
          },
          {
            "sbg:altPrefix": "-disable-tool-default-read-filters",
            "sbg:category": "Optional Common Arguments",
            "sbg:toolDefaultValue": "false",
            "id": "disable_tool_default_read_filters",
            "type": "boolean?",
            "inputBinding": {
              "prefix": "--disable-tool-default-read-filters",
              "shellQuote": false,
              "position": 4
            },
            "label": "Disable tool default read filters",
            "doc": "Disable all tool default read filters (warning: many tools will not function correctly without their default read filters on)."
          },
          {
            "sbg:category": "Advanced Arguments",
            "sbg:toolDefaultValue": "false",
            "id": "dont_increase_kmer_sizes_for_cycles",
            "type": "boolean?",
            "inputBinding": {
              "prefix": "--dont-increase-kmer-sizes-for-cycles",
              "shellQuote": false,
              "position": 4
            },
            "label": "Dont increase kmer sizes for cycles",
            "doc": "Disable iterating over kmer sizes when graph cycles are detected."
          },
          {
            "sbg:category": "Advanced Arguments",
            "id": "dont_trim_active_regions",
            "type": "boolean?",
            "inputBinding": {
              "prefix": "--dont-trim-active-regions",
              "shellQuote": false,
              "position": 4
            },
            "label": "Dont trim active regions",
            "doc": "If specified, we will not trim down the active region from the full region (active."
          },
          {
            "sbg:category": "Advanced Arguments",
            "sbg:toolDefaultValue": "false",
            "id": "dont_use_soft_clipped_bases",
            "type": "boolean?",
            "inputBinding": {
              "prefix": "--dont-use-soft-clipped-bases",
              "shellQuote": false,
              "position": 4
            },
            "label": "Dont use soft clipped bases",
            "doc": "Do not analyze soft clipped bases in the reads."
          },
          {
            "sbg:altPrefix": "-ERC",
            "sbg:category": "Advanced Arguments",
            "sbg:toolDefaultValue": "NONE",
            "id": "emit_ref_confidence",
            "type": [
              "null",
              {
                "type": "enum",
                "symbols": [
                  "NONE",
                  "BP_RESOLUTION",
                  "GVCF"
                ],
                "name": "emit_ref_confidence"
              }
            ],
            "inputBinding": {
              "prefix": "--emit-ref-confidence",
              "shellQuote": false,
              "position": 4
            },
            "label": "Emit ref confidence",
            "doc": "(beta feature) mode for emitting reference confidence scores."
          },
          {
            "sbg:category": "Advanced Arguments",
            "sbg:toolDefaultValue": "false",
            "id": "enable_all_annotations",
            "type": "boolean?",
            "inputBinding": {
              "prefix": "--enable-all-annotations",
              "shellQuote": false,
              "position": 4
            },
            "label": "Enable all annotations",
            "doc": "Use all possible annotations (not for the faint of heart)."
          },
          {
            "sbg:category": "Advanced Arguments",
            "sbg:toolDefaultValue": "false",
            "id": "force_active",
            "type": "boolean?",
            "inputBinding": {
              "prefix": "--force-active",
              "shellQuote": false,
              "position": 4
            },
            "label": "Force active",
            "doc": "If provided, all regions will be marked as active."
          },
          {
            "sbg:altPrefix": "--genotype-filtered-alleles",
            "sbg:category": "Advanced Arguments",
            "sbg:toolDefaultValue": "false",
            "id": "force_call_filtered_alleles",
            "type": "boolean?",
            "inputBinding": {
              "prefix": "--force-call-filtered-alleles",
              "shellQuote": false,
              "position": 4
            },
            "label": "Genotype filtered alleles",
            "doc": "Whether to force genotype even filtered alleles."
          },
          {
            "sbg:altPrefix": "-LODB",
            "sbg:category": "Advanced Arguments",
            "sbg:toolDefaultValue": "[-2.5, -2.0, -1.5, -1.0, -0.5, 0.0, 0.5, 1.0]",
            "id": "gvcf_lod_band",
            "type": "float[]?",
            "inputBinding": {
              "prefix": "",
              "shellQuote": false,
              "position": 4,
              "valueFrom": "${\n    var output = \"\";\n    for (var i=0; i<inputs.gvcf_lod_band.length; i++)\n    {\n        output = output + \"--gvcf-lod-band \" + inputs.gvcf_lod_band[i] + \" \";\n    }\n    return output;\n}"
            },
            "label": "Gvcf lod band",
            "doc": "Exclusive upper bounds for reference confidence lod bands (must be specified in increasing order) default value:."
          },
          {
            "sbg:category": "Advanced Arguments",
            "sbg:toolDefaultValue": "[10, 25]",
            "id": "kmer_size",
            "type": "int[]?",
            "inputBinding": {
              "prefix": "",
              "shellQuote": false,
              "position": 4,
              "valueFrom": "${\n    var output = \"\";\n    for (var i=0; i<inputs.kmer_size.length; i++)\n    {\n        output = output + \"--kmer-size \" + inputs.kmer_size[i] + \" \";\n    }\n    return output;\n}"
            },
            "label": "Kmer size",
            "doc": "Kmer size to use in the read threading assembler default value:."
          },
          {
            "sbg:category": "Advanced Arguments",
            "sbg:toolDefaultValue": "300",
            "id": "max_assembly_region_size",
            "type": "int?",
            "inputBinding": {
              "prefix": "--max-assembly-region-size",
              "shellQuote": false,
              "position": 4
            },
            "label": "Max assembly region size",
            "doc": "Maximum size of an assembly region."
          },
          {
            "sbg:altPrefix": "-mnp-dist",
            "sbg:category": "Advanced Arguments",
            "sbg:toolDefaultValue": "1",
            "id": "max_mnp_distance",
            "type": "int?",
            "inputBinding": {
              "prefix": "--max-mnp-distance",
              "shellQuote": false,
              "position": 4
            },
            "label": "Max mnp distance",
            "doc": "Two or more phased substitutions separated by this distance or less are merged into mnps."
          },
          {
            "sbg:category": "Advanced Arguments",
            "sbg:toolDefaultValue": "128",
            "id": "max_num_haplotypes_in_population",
            "type": "int?",
            "inputBinding": {
              "prefix": "--max-num-haplotypes-in-population",
              "shellQuote": false,
              "position": 4
            },
            "label": "Max num haplotypes in population",
            "doc": "Maximum number of haplotypes to consider for your population."
          },
          {
            "sbg:category": "Advanced Arguments",
            "sbg:toolDefaultValue": "50",
            "id": "max_prob_propagation_distance",
            "type": "int?",
            "inputBinding": {
              "prefix": "--max-prob-propagation-distance",
              "shellQuote": false,
              "position": 4
            },
            "label": "Max prob propagation distance",
            "doc": "Upper limit on how many bases away probability mass can be moved around when calculating the boundaries between active and inactive assembly regions."
          },
          {
            "sbg:category": "Advanced Arguments",
            "sbg:toolDefaultValue": "0",
            "id": "max_suspicious_reads_per_alignment_start",
            "type": "int?",
            "inputBinding": {
              "prefix": "--max-suspicious-reads-per-alignment-start",
              "shellQuote": false,
              "position": 4
            },
            "label": "Max suspicious reads per alignment start",
            "doc": "Maximum number of suspicious reads (mediocre mapping quality or too many substitutions) allowed in a downsampling stride. Set to 0 to disable."
          },
          {
            "sbg:category": "Advanced Arguments",
            "sbg:toolDefaultValue": "100",
            "id": "max_unpruned_variants",
            "type": "int?",
            "inputBinding": {
              "prefix": "--max-unpruned-variants",
              "shellQuote": false,
              "position": 4
            },
            "label": "Max unpruned variants",
            "doc": "Maximum number of variants in graph the adaptive pruner will allow."
          },
          {
            "sbg:category": "Advanced Arguments",
            "sbg:toolDefaultValue": "50",
            "id": "min_assembly_region_size",
            "type": "int?",
            "inputBinding": {
              "prefix": "--min-assembly-region-size",
              "shellQuote": false,
              "position": 4
            },
            "label": "Min assembly region size",
            "doc": "Minimum size of an assembly region."
          },
          {
            "sbg:category": "Advanced Arguments",
            "sbg:toolDefaultValue": "4",
            "id": "min_dangling_branch_length",
            "type": "int?",
            "inputBinding": {
              "prefix": "--min-dangling-branch-length",
              "shellQuote": false,
              "position": 4
            },
            "label": "Min dangling branch length",
            "doc": "Minimum length of a dangling branch to attempt recovery."
          },
          {
            "sbg:category": "Advanced Arguments",
            "sbg:toolDefaultValue": "2",
            "id": "min_pruning",
            "type": "int?",
            "inputBinding": {
              "prefix": "--min-pruning",
              "shellQuote": false,
              "position": 4
            },
            "label": "Min pruning",
            "doc": "Minimum support to not prune paths in the graph."
          },
          {
            "sbg:altPrefix": "-min-AF",
            "sbg:category": "Advanced Arguments",
            "sbg:toolDefaultValue": "0",
            "id": "minimum_allele_fraction",
            "type": "float?",
            "inputBinding": {
              "prefix": "--minimum-allele-fraction",
              "shellQuote": false,
              "position": 4
            },
            "label": "Minimum allele fraction",
            "doc": "Lower bound of variant allele fractions to consider when calculating variant lod 0."
          },
          {
            "sbg:category": "Advanced Arguments",
            "sbg:toolDefaultValue": "1",
            "id": "num_pruning_samples",
            "type": "int?",
            "inputBinding": {
              "prefix": "--num-pruning-samples",
              "shellQuote": false,
              "position": 4
            },
            "label": "Num pruning samples",
            "doc": "Number of samples that must pass the minpruning threshold."
          },
          {
            "sbg:category": "Advanced Arguments",
            "sbg:toolDefaultValue": "10",
            "id": "pair_hmm_gap_continuation_penalty",
            "type": "int?",
            "inputBinding": {
              "prefix": "--pair-hmm-gap-continuation-penalty",
              "shellQuote": false,
              "position": 4
            },
            "label": "Pair hmm gap continuation penalty",
            "doc": "Flat gap continuation penalty for use in the pair hmm."
          },
          {
            "sbg:altPrefix": "-pairHMM",
            "sbg:category": "Advanced Arguments",
            "sbg:toolDefaultValue": "FASTEST_AVAILABLE",
            "id": "pair_hmm_implementation",
            "type": [
              "null",
              {
                "type": "enum",
                "symbols": [
                  "EXACT",
                  "ORIGINAL",
                  "LOGLESS_CACHING",
                  "AVX_LOGLESS_CACHING",
                  "AVX_LOGLESS_CACHING_OMP",
                  "EXPERIMENTAL_FPGA_LOGLESS_CACHING",
                  "FASTEST_AVAILABLE"
                ],
                "name": "pair_hmm_implementation"
              }
            ],
            "inputBinding": {
              "prefix": "--pair-hmm-implementation",
              "shellQuote": false,
              "position": 4
            },
            "label": "Pair hmm implementation",
            "doc": "The pairhmm implementation to use for genotype likelihood calculations."
          },
          {
            "sbg:category": "Advanced Arguments",
            "sbg:toolDefaultValue": "CONSERVATIVE",
            "id": "pcr_indel_model",
            "type": [
              "null",
              {
                "type": "enum",
                "symbols": [
                  "NONE",
                  "HOSTILE",
                  "AGGRESSIVE",
                  "CONSERVATIVE"
                ],
                "name": "pcr_indel_model"
              }
            ],
            "inputBinding": {
              "prefix": "--pcr-indel-model",
              "shellQuote": false,
              "position": 4
            },
            "label": "Pcr indel model",
            "doc": "The pcr indel model to use."
          },
          {
            "sbg:category": "Advanced Arguments",
            "sbg:toolDefaultValue": "45",
            "id": "phred_scaled_global_read_mismapping_rate",
            "type": "int?",
            "inputBinding": {
              "prefix": "--phred-scaled-global-read-mismapping-rate",
              "shellQuote": false,
              "position": 4
            },
            "label": "Phred scaled global read mismapping rate",
            "doc": "The global assumed mismapping rate for reads."
          },
          {
            "sbg:category": "Advanced Arguments",
            "sbg:toolDefaultValue": "2.302585092994046",
            "id": "pruning_lod_threshold",
            "type": "float?",
            "inputBinding": {
              "prefix": "--pruning-lod-threshold",
              "shellQuote": false,
              "position": 4
            },
            "label": "Pruning lod threshold",
            "doc": "Ln likelihood ratio threshold for adaptive pruning algorithm"
          },
          {
            "sbg:category": "Advanced Arguments",
            "sbg:toolDefaultValue": "false",
            "id": "recover_all_dangling_branches",
            "type": "boolean?",
            "inputBinding": {
              "prefix": "--recover-all-dangling-branches",
              "shellQuote": false,
              "position": 4
            },
            "label": "Recover all dangling branches",
            "doc": "Recover all dangling branches."
          },
          {
            "sbg:altPrefix": "-showHidden",
            "sbg:category": "Advanced Arguments",
            "sbg:toolDefaultValue": "false",
            "id": "showhidden",
            "type": "boolean?",
            "inputBinding": {
              "prefix": "--showHidden",
              "shellQuote": false,
              "position": 4
            },
            "label": "Showhidden",
            "doc": "Display hidden arguments."
          },
          {
            "sbg:category": "Advanced Arguments",
            "sbg:toolDefaultValue": "JAVA",
            "id": "smith_waterman",
            "type": [
              "null",
              {
                "type": "enum",
                "symbols": [
                  "FASTEST_AVAILABLE",
                  "AVX_ENABLED",
                  "JAVA"
                ],
                "name": "smith_waterman"
              }
            ],
            "inputBinding": {
              "prefix": "--smith-waterman",
              "shellQuote": false,
              "position": 4
            },
            "label": "Smith waterman",
            "doc": "Which smith-waterman implementation to use, generally fastest_available is the right choice."
          },
          {
            "sbg:category": "Advanced Arguments",
            "sbg:toolDefaultValue": "null",
            "id": "ambig_filter_bases",
            "type": "int?",
            "inputBinding": {
              "prefix": "--ambig-filter-bases",
              "shellQuote": false,
              "position": 4
            },
            "label": "Ambig filter bases",
            "doc": "Threshold number of ambiguous bases. If null, uses threshold fraction; otherwise, overrides threshold fraction. Cannot be used in conjuction with argument(s) maxambiguousbasefraction. Valid only if \"ambiguousbasereadfilter\" is specified."
          },
          {
            "sbg:category": "Advanced Arguments",
            "sbg:toolDefaultValue": "0",
            "id": "ambig_filter_frac",
            "type": "float?",
            "inputBinding": {
              "prefix": "--ambig-filter-frac",
              "shellQuote": false,
              "position": 4
            },
            "label": "Ambig filter frac",
            "doc": "Threshold fraction of ambiguous bases 05. Cannot be used in conjuction with argument(s) maxambiguousbases. Valid only if \"ambiguousbasereadfilter\" is specified."
          },
          {
            "sbg:category": "Advanced Arguments",
            "sbg:toolDefaultValue": "1000000",
            "id": "max_fragment_length",
            "type": "int?",
            "inputBinding": {
              "prefix": "--max-fragment-length",
              "shellQuote": false,
              "position": 4
            },
            "label": "Max fragment length",
            "doc": "Maximum length of fragment (insert size). Valid only if \"fragmentlengthreadfilter\" is specified."
          },
          {
            "sbg:category": "Advanced Arguments",
            "sbg:toolDefaultValue": "0",
            "id": "min_fragment_length",
            "type": "int?",
            "inputBinding": {
              "prefix": "--min-fragment-length",
              "shellQuote": false,
              "position": 4
            },
            "label": "Min fragment length",
            "doc": "Minimum length of fragment (insert size). Valid only if \"fragmentlengthreadfilter\" is specified."
          },
          {
            "sbg:category": "Advanced Arguments",
            "id": "keep_intervals",
            "type": "string?",
            "inputBinding": {
              "prefix": "--keep-intervals",
              "shellQuote": false,
              "position": 4
            },
            "label": "Keep intervals",
            "doc": "One or more genomic intervals to keep this argument must be specified at least once. Valid only if \"intervaloverlapreadfilter\" is specified."
          },
          {
            "sbg:altPrefix": "-library",
            "sbg:category": "Advanced Arguments",
            "id": "library",
            "type": "string?",
            "inputBinding": {
              "prefix": "--library",
              "shellQuote": false,
              "position": 4
            },
            "label": "Library",
            "doc": "Name of the library to keep this argument must be specified at least once. Valid only if \"libraryreadfilter\" is specified."
          },
          {
            "sbg:category": "Advanced Arguments",
            "sbg:toolDefaultValue": "null",
            "id": "maximum_mapping_quality",
            "type": "int?",
            "inputBinding": {
              "prefix": "--maximum-mapping-quality",
              "shellQuote": false,
              "position": 4
            },
            "label": "Maximum mapping quality",
            "doc": "Maximum mapping quality to keep (inclusive). Valid only if \"mappingqualityreadfilter\" is specified."
          },
          {
            "sbg:category": "Advanced Arguments",
            "sbg:toolDefaultValue": "20",
            "id": "minimum_mapping_quality",
            "type": "int?",
            "inputBinding": {
              "prefix": "--minimum-mapping-quality",
              "shellQuote": false,
              "position": 4
            },
            "label": "Minimum mapping quality",
            "doc": "Minimum mapping quality to keep (inclusive). Valid only if \"mappingqualityreadfilter\" is specified."
          },
          {
            "sbg:category": "Advanced Arguments",
            "sbg:toolDefaultValue": "false",
            "id": "dont_require_soft_clips_both_ends",
            "type": "boolean?",
            "inputBinding": {
              "prefix": "--dont-require-soft-clips-both-ends",
              "shellQuote": false,
              "position": 4
            },
            "label": "Dont require soft clips both ends",
            "doc": "Allow a read to be filtered out based on having only 1 soft-clipped block. By default, both ends must have a soft-clipped block, setting this flag requires only 1 soft-clipped block. Valid only if \"overclippedreadfilter\" is specified."
          },
          {
            "sbg:category": "Advanced Arguments",
            "sbg:toolDefaultValue": "30",
            "id": "filter_too_short",
            "type": "int?",
            "inputBinding": {
              "prefix": "--filter-too-short",
              "shellQuote": false,
              "position": 4
            },
            "label": "Filter too short",
            "doc": "Minimum number of aligned bases. Valid only if \"overclippedreadfilter\" is specified."
          },
          {
            "sbg:category": "Advanced Arguments",
            "id": "platform_filter_name",
            "type": "string?",
            "inputBinding": {
              "prefix": "--platform-filter-name",
              "shellQuote": false,
              "position": 4,
              "valueFrom": "${\n    return '\"' + self + '\"';\n}"
            },
            "label": "Platform filter name",
            "doc": "Platform attribute (pl) to match this argument must be specified at least once. Valid only if \"platformreadfilter\" is specified."
          },
          {
            "sbg:category": "Advanced Arguments",
            "id": "black_listed_lanes",
            "type": "string?",
            "inputBinding": {
              "prefix": "--black-listed-lanes",
              "shellQuote": false,
              "position": 4
            },
            "label": "Black listed lanes",
            "doc": "Platform unit (pu) to filter out this argument must be specified at least once. Valid only if \"platformunitreadfilter\" is specified."
          },
          {
            "sbg:category": "Advanced Arguments",
            "id": "read_group_black_list",
            "type": "string?",
            "inputBinding": {
              "prefix": "--read-group-black-list",
              "shellQuote": false,
              "position": 4
            },
            "label": "Read group black list",
            "doc": "Name of the read group to filter out this argument must be specified at least once. Valid only if \"readgroupblacklistreadfilter\" is specified."
          },
          {
            "sbg:category": "Advanced Arguments",
            "id": "keep_read_group",
            "type": "string?",
            "inputBinding": {
              "prefix": "--keep-read-group",
              "shellQuote": false,
              "position": 4
            },
            "label": "Keep read group",
            "doc": "The name of the read group to keep. Valid only if \"readgroupreadfilter\" is specified."
          },
          {
            "sbg:category": "Advanced Arguments",
            "sbg:toolDefaultValue": "2147483647",
            "id": "max_read_length",
            "type": "int?",
            "inputBinding": {
              "prefix": "--max-read-length",
              "shellQuote": false,
              "position": 4
            },
            "label": "Max read length",
            "doc": "Keep only reads with length at most equal to the specified value. Valid only if \"readlengthreadfilter\" is specified."
          },
          {
            "sbg:category": "Advanced Arguments",
            "sbg:toolDefaultValue": "30",
            "id": "min_read_length",
            "type": "int?",
            "inputBinding": {
              "prefix": "--min-read-length",
              "shellQuote": false,
              "position": 4
            },
            "label": "Min read length",
            "doc": "Keep only reads with length at least equal to the specified value. Valid only if \"readlengthreadfilter\" is specified."
          },
          {
            "sbg:category": "Advanced Arguments",
            "id": "read_name",
            "type": "string?",
            "inputBinding": {
              "prefix": "--read-name",
              "shellQuote": false,
              "position": 4,
              "valueFrom": "${\n    return '\"' + self + '\"';\n}"
            },
            "label": "Read name",
            "doc": "Keep only reads with this read name. Valid only if \"readnamereadfilter\" is specified."
          },
          {
            "sbg:category": "Advanced Arguments",
            "id": "keep_reverse_strand_only",
            "type": "boolean?",
            "inputBinding": {
              "prefix": "--keep-reverse-strand-only",
              "shellQuote": false,
              "position": 4
            },
            "label": "Keep reverse strand only",
            "doc": "Keep only reads on the reverse strand. Valid only if \"readstrandfilter\" is specified."
          },
          {
            "sbg:altPrefix": "-sample",
            "sbg:category": "Advanced Arguments",
            "id": "sample",
            "type": "string?",
            "inputBinding": {
              "prefix": "--sample",
              "shellQuote": false,
              "position": 4,
              "valueFrom": "${\n    return '\"' + self + '\"';\n}"
            },
            "label": "Sample",
            "doc": "The name of the sample(s) to keep, filtering out all others this argument must be specified at least once. Valid only if \"samplereadfilter\" is specified."
          },
          {
            "sbg:category": "Execution",
            "sbg:toolDefaultValue": "1",
            "id": "cpu_per_job",
            "type": "int?",
            "label": "CPU per job",
            "doc": "Number of CPUs per job"
          },
          {
            "sbg:altPrefix": "-L",
            "sbg:category": "Optional Tool Arguments",
            "id": "in_interval_files",
            "type": "File[]?",
            "inputBinding": {
              "shellQuote": false,
              "position": 4,
              "valueFrom": "${\n    var output = \"\";\n    var interval_files = [].concat(self);\n    for (var i=0; i < interval_files.length; i++)\n        output += \" --intervals \" + interval_files[i].path;\n    return output;\n}"
            },
            "label": "Interval Files",
            "doc": "One or more genomic intervals, given in form of a file, over which to operate.",
            "sbg:fileTypes": "LIST, BED, INTERVALS, VCF, INTERVAL_LIST"
          },
          {
            "sbg:category": "Optional Arguments",
            "id": "exclude_interval_files",
            "type": "File[]?",
            "inputBinding": {
              "shellQuote": false,
              "position": 4,
              "valueFrom": "${\n    var output = \"\";\n    for (var i=0; i<self.length; i++)\n        output += \" -XL \" + self[i].path;\n    return output;\n}"
            },
            "label": "Exclude intervals",
            "doc": "Or more genomic intervals, in form of a file, to exclude from processing.",
            "sbg:fileTypes": "LIST, INTERVALS, VCF, BED, INTERVAL_LIST"
          },
          {
            "sbg:category": "Advanced Arguments",
            "sbg:toolDefaultValue": "null",
            "id": "make_bamout",
            "type": "boolean?",
            "label": "Make BAM output",
            "doc": "File to which assembled haplotypes should be written"
          },
          {
            "sbg:category": "Advanced Arguments",
            "id": "make_f1r2",
            "type": "boolean?",
            "label": "Make f1r2 file",
            "doc": "Make f1r2 output file."
          },
          {
            "sbg:category": "Advanced Arguments",
            "id": "compress",
            "type": "boolean?",
            "label": "Compress output",
            "doc": "Compres output VCF."
          },
          {
            "sbg:category": "Execution",
            "sbg:toolDefaultValue": "3500",
            "id": "mem_per_job",
            "type": "int?",
            "label": "Memory Per Job",
            "doc": "Memory Per Job (in MB)"
          },
          {
            "sbg:category": "Execution",
            "sbg:toolDefaultValue": "500",
            "id": "mem_overhead_per_job",
            "type": "int?",
            "label": "Memory overhead per job",
            "doc": "Memory overhead per job (in MB)."
          },
          {
            "sbg:altPrefix": "-bamout",
            "sbg:category": "Advanced Arguments",
            "sbg:toolDefaultValue": "null",
            "id": "output_bam_filename",
            "type": "string?",
            "label": "Output BAM filename",
            "doc": "Filename of the output BAM file."
          },
          {
            "sbg:category": "Additional inputs",
            "sbg:toolDefaultValue": "False",
            "id": "append_interval_to_name",
            "type": "boolean?",
            "label": "Append interval to name",
            "doc": "Appends first 4 characters of the intervals name to the output name. This option should be used if Mutect is scattered by input intervals."
          },
          {
            "sbg:category": "Optional Tool Arguments",
            "sbg:toolDefaultValue": "None",
            "id": "mutect2_extra_arguments",
            "type": "string[]?",
            "inputBinding": {
              "shellQuote": false,
              "position": 4,
              "valueFrom": "${\n    if (self.length > 0){\n        return self.join(\" \");\n} else {\n        return null;\n    }\n}"
            },
            "label": "Extra Arguments",
            "doc": "This will be inserted directly into the command line of the tool (Use with care!)."
          }
        ],
        "outputs": [
          {
            "id": "out_variants",
            "doc": "Output variants in VCF or VCF.GZ format.",
            "label": "Output variants",
            "type": "File?",
            "outputBinding": {
              "glob": "${\n    return [\"*.vcf.gz\", \"*.vcf\"]\n}",
              "outputEval": "${\n    function removeNull(array){\n        var output = [];\n        for (var i = 0; i<array.length; i++){\n            if (array[i] != null){\n                output.push(array[i]);\n            }\n        }\n        return output;\n    }\n    \n    var setMetadata = function(file, metadata) {\n        if (!('metadata' in file)) {\n            file['metadata'] = {}\n        }\n        for (var key in metadata) {\n            file['metadata'][key] = metadata[key];\n        }\n        return file\n    };\n    \n    var inheritMetadata = function(o1, o2) {\n        var commonMetadata = {};\n        if (!o2) {\n            return o1;\n        };\n        if (!Array.isArray(o2)) {\n            o2 = [o2]\n        }\n        for (var i = 0; i < o2.length; i++) {\n            var example = o2[i]['metadata'];\n            for (var key in example) {\n                if (i == 0)\n                    commonMetadata[key] = example[key];\n                else {\n                    if (!(commonMetadata[key] == example[key])) {\n                        delete commonMetadata[key]\n                    }\n                }\n            }\n            for (var key in commonMetadata) {\n                if (!(key in example)) {\n                    delete commonMetadata[key]\n                }\n            }\n        }\n        if (!Array.isArray(o1)) {\n            o1 = setMetadata(o1, commonMetadata)\n        } else {\n            for (var i = 0; i < o1.length; i++) {\n                o1[i] = setMetadata(o1[i], commonMetadata)\n            }\n        }\n        return o1;\n    };\n    \n    self = inheritMetadata(self, removeNull([].concat(inputs.in_alignments)));\n    return self;\n}"
            },
            "secondaryFiles": [
              {
                "pattern": "${\n    return [self.basename + \".idx\", self.nameroot + \".idx\"]\n}"
              },
              {
                "pattern": "${\n    return [self.basename + \".tbi\", self.nameroot + \".tbi\"]\n}"
              }
            ],
            "sbg:fileTypes": "VCF, VCF.GZ"
          },
          {
            "id": "out_alignments",
            "doc": "Output alignments in BAM format",
            "label": "Output alignments",
            "type": "File?",
            "outputBinding": {
              "glob": "*.bam",
              "outputEval": "${\n    function removeNull(array){\n        var output = [];\n        for (var i = 0; i<array.length; i++){\n            if (array[i] != null){\n                output.push(array[i]);\n            }\n        }\n        return output;\n    }\n    \n    var setMetadata = function(file, metadata) {\n        if (!('metadata' in file)) {\n            file['metadata'] = {}\n        }\n        for (var key in metadata) {\n            file['metadata'][key] = metadata[key];\n        }\n        return file\n    };\n    \n    var inheritMetadata = function(o1, o2) {\n        var commonMetadata = {};\n        if (!o2) {\n            return o1;\n        };\n        if (!Array.isArray(o2)) {\n            o2 = [o2]\n        }\n        for (var i = 0; i < o2.length; i++) {\n            var example = o2[i]['metadata'];\n            for (var key in example) {\n                if (i == 0)\n                    commonMetadata[key] = example[key];\n                else {\n                    if (!(commonMetadata[key] == example[key])) {\n                        delete commonMetadata[key]\n                    }\n                }\n            }\n            for (var key in commonMetadata) {\n                if (!(key in example)) {\n                    delete commonMetadata[key]\n                }\n            }\n        }\n        if (!Array.isArray(o1)) {\n            o1 = setMetadata(o1, commonMetadata)\n        } else {\n            for (var i = 0; i < o1.length; i++) {\n                o1[i] = setMetadata(o1[i], commonMetadata)\n            }\n        }\n        return o1;\n    };\n    \n    self = inheritMetadata(self, removeNull([].concat(inputs.in_alignments)));\n    return self;\n}"
            },
            "secondaryFiles": [
              {
                "pattern": ".bai"
              },
              {
                "pattern": "^.bai"
              }
            ],
            "sbg:fileTypes": "BAM"
          },
          {
            "id": "f1r2_counts",
            "doc": "Output f1r2 counts in TAR.GZ format",
            "label": "Output f1r2 counts",
            "type": "File?",
            "outputBinding": {
              "glob": "*.tar.gz",
              "outputEval": "${\n    function removeNull(array){\n        var output = [];\n        for (var i = 0; i<array.length; i++){\n            if (array[i] != null){\n                output.push(array[i]);\n            }\n        }\n        return output;\n    }\n    \n    var setMetadata = function(file, metadata) {\n        if (!('metadata' in file)) {\n            file['metadata'] = {}\n        }\n        for (var key in metadata) {\n            file['metadata'][key] = metadata[key];\n        }\n        return file\n    };\n    \n    var inheritMetadata = function(o1, o2) {\n        var commonMetadata = {};\n        if (!o2) {\n            return o1;\n        };\n        if (!Array.isArray(o2)) {\n            o2 = [o2]\n        }\n        for (var i = 0; i < o2.length; i++) {\n            var example = o2[i]['metadata'];\n            for (var key in example) {\n                if (i == 0)\n                    commonMetadata[key] = example[key];\n                else {\n                    if (!(commonMetadata[key] == example[key])) {\n                        delete commonMetadata[key]\n                    }\n                }\n            }\n            for (var key in commonMetadata) {\n                if (!(key in example)) {\n                    delete commonMetadata[key]\n                }\n            }\n        }\n        if (!Array.isArray(o1)) {\n            o1 = setMetadata(o1, commonMetadata)\n        } else {\n            for (var i = 0; i < o1.length; i++) {\n                o1[i] = setMetadata(o1[i], commonMetadata)\n            }\n        }\n        return o1;\n    };\n    \n    self = inheritMetadata(self, removeNull([].concat(inputs.in_alignments)));\n    return self;\n}"
            },
            "sbg:fileTypes": "TAR.GZ"
          },
          {
            "id": "out_stats",
            "doc": "Output stat file.",
            "label": "Output stats",
            "type": "File?",
            "outputBinding": {
              "glob": "${\n    return [\"*.vcf.gz.stats\", \"*.vcf.stats\"]\n}",
              "outputEval": "${\n    function removeNull(array){\n        var output = [];\n        for (var i = 0; i<array.length; i++){\n            if (array[i] != null){\n                output.push(array[i]);\n            }\n        }\n        return output;\n    }\n    \n    var setMetadata = function(file, metadata) {\n        if (!('metadata' in file)) {\n            file['metadata'] = {}\n        }\n        for (var key in metadata) {\n            file['metadata'][key] = metadata[key];\n        }\n        return file\n    };\n    \n    var inheritMetadata = function(o1, o2) {\n        var commonMetadata = {};\n        if (!o2) {\n            return o1;\n        };\n        if (!Array.isArray(o2)) {\n            o2 = [o2]\n        }\n        for (var i = 0; i < o2.length; i++) {\n            var example = o2[i]['metadata'];\n            for (var key in example) {\n                if (i == 0)\n                    commonMetadata[key] = example[key];\n                else {\n                    if (!(commonMetadata[key] == example[key])) {\n                        delete commonMetadata[key]\n                    }\n                }\n            }\n            for (var key in commonMetadata) {\n                if (!(key in example)) {\n                    delete commonMetadata[key]\n                }\n            }\n        }\n        if (!Array.isArray(o1)) {\n            o1 = setMetadata(o1, commonMetadata)\n        } else {\n            for (var i = 0; i < o1.length; i++) {\n                o1[i] = setMetadata(o1[i], commonMetadata)\n            }\n        }\n        return o1;\n    };\n    \n    self = inheritMetadata(self, removeNull([].concat(inputs.in_alignments)));\n    return self;\n}"
            },
            "sbg:fileTypes": "STATS, VCF.GZ.STATS, VCF.STATS"
          }
        ],
        "doc": "**Mutect2** is used to call somatic SNVs and indels via local assembly of haplotypes.\n\n###Common Use Cases\nExample commands show how to run Mutect2 for typical scenarios. The three modes are (i) tumor-normal mode where a tumor sample is matched with a normal sample in analysis, (ii) tumor-only mode where a single sample's alignment data undergoes analysis, and (iii) mitochondrial mode where sensitive calling at high depths is desirable.\n\n- As of v4.1, there is no longer a need to specify the tumor sample name with -tumor. You need only specify the normal sample name with -normal, if you include a normal.\n\n- Starting with v4.0.4.0, GATK recommends the default setting of --af-of-alleles-not-in-resource, which the tool dynamically adjusts for different modes. tumor-only calling sets the default to 5e-8, tumor-normal calling sets it to 1e-6 and mitochondrial mode sets it to 4e-3. For previous versions, the default was 0.001, the average heterozygosity of humans. For other organisms, change --af-of-alleles-not-in-resource to 1/(ploidy*samples in resource).\n\n**Tumor with matched normal**\nGiven a matched normal, Mutect2 is designed to call somatic variants only. The tool includes logic to skip emitting variants that are clearly present in the germline based on provided evidence, e.g. in the matched normal. This is done at an early stage to avoid spending computational resources on germline events. If the variant's germline status is borderline, then Mutect2 will emit the variant to the callset for subsequent filtering by FilterMutectCalls and review.\n\n```\ngatk Mutect2 \\\n     -R reference.fa \\\n     -I tumor.bam \\\n     -I normal.bam \\\n     -normal normal_sample_name \\\n     --germline-resource af-only-gnomad.vcf.gz \\\n     --panel-of-normals pon.vcf.gz \\\n     -O somatic.vcf.gz\n```\n\nMutect2 also generates a stats file names [output vcf].stats. That is, in the above example the stats file would be named somatic.vcf.gz.stats and would be in the same folder as somatic.vcf.gz. As of GATK 4.1.1 this file is a required input to FilterMutectCalls.\n- As of v4.1 Mutect2 supports joint calling of multiple tumor and normal samples from the same individual. The only difference is that -I and -normal must be specified for the extra samples.\n```\n gatk Mutect2 \\\n     -R reference.fa \\\n     -I tumor1.bam \\\n     -I tumor2.bam \\\n     -I normal1.bam \\\n     -I normal2.bam \\\n     -normal normal1_sample_name \\\n     -normal normal2_sample_name \\\n     --germline-resource af-only-gnomad.vcf.gz \\\n     --panel-of-normals pon.vcf.gz \\\n     -O somatic.vcf.gz\n```\n**Tumor-only mode**\nThis mode runs on a single type of sample, e.g. the tumor or the normal. To create a PoN, call on each normal sample in this mode, then use CreateSomaticPanelOfNormals to generate the PoN.\n```\n  gatk Mutect2 \\\n       -R reference.fa \\\n       -I sample.bam \\\n       -O single_sample.vcf.gz\n```\nTo call mutations on a tumor sample, call in this mode using a PoN and germline resource. After FilterMutectCalls filtering, consider additional filtering by functional significance with Funcotator.\n```\n  gatk Mutect2 \\\n       -R reference.fa \\\n       -I sample.bam \\\n       --germline-resource af-only-gnomad.vcf.gz \\\n       --panel-of-normals pon.vcf.gz \\\n       -O single_sample.vcf.gz\n```\n**Mitochondrial mode**\nMutect2 automatically sets parameters appropriately for calling on mitochondria with the --mitochondria flag. Specifically, the mode sets \u2013-initial-tumor-lod to 0, \u2013-tumor-lod-to-emit to 0, --af-of-alleles-not-in-resource to 4e-3, and the advanced parameter --pruning-lod-threshold to -4.\n```\ngatk Mutect2 \\\n     -R reference.fa \\\n     -L chrM \\\n     --mitochondria \\\n     --median-autosomal-coverage 30 \\\n     -I mitochondria.bam \\\n     -O mitochondria.vcf.gz\n```\nSetting the advanced option --median-autosomal-coverage argument (default 0) activates a recommended filter against likely erroneously mapped NuMTs (nuclear mitochondrial DNA segments). For the value, provide the median coverage expected in autosomal regions with coverage. The mode accepts only a single sample, which can be provided in multiple files.\n\n**Force-calling mode**\nThis mode force-calls all alleles in force-call-alleles.vcf in addition to any other variants Mutect2 discovers.\n```\ngatk Mutect2 \\\n     -R reference.fa \\\n     -I sample.bam \\\n     -alleles force-call-alleles.vcf\n     -O single_sample.vcf.gz\n```\nIf the sample is suspected to exhibit orientation bias artifacts (such as in the case of FFPE tumor samples) one should also collect F1R2 metrics by adding an --f1r2-tar-gz argument as shown below. This file contains information that can then be passed to LearnReadOrientationModel, which generate an artifact prior table for each tumor sample for FilterMutectCalls to use.\n\n```\n gatk Mutect2 \\\n     -R reference.fa \\\n     -I sample.bam \\\n     --f1r2-tar-gz f1r2.tar.gz \\\n     -O single_sample.vcf.gz\n```\n\n###Changes Introduced by Seven Bridges\n- **Output filename** (`--output`)  parameter, if not provided explicitly, will be generated automatically based on other inputs. Namely, if **Tumor sample** and **Normal sample** are provided, they will be used to generate the output name; if not provided input file names will be used.\n- String array argument **Extra Arguments** has been added for ease of use in certain workflows.\n\n###Common Issues and Important Notes\nNone\n###Performance Benchmarking",
        "label": "GATK Mutect2 CWL1.0",
        "arguments": [
          {
            "prefix": "--java-options",
            "shellQuote": false,
            "position": 2,
            "valueFrom": "${\n    if (inputs.mem_per_job) {\n        return '\\\"-Xmx'.concat(inputs.mem_per_job, 'M') + '\\\"'\n    }\n    return '\\\"-Xmx7500M\\\"'\n}"
          },
          {
            "shellQuote": false,
            "position": 3,
            "valueFrom": "Mutect2"
          },
          {
            "prefix": "--output",
            "shellQuote": false,
            "position": 5,
            "valueFrom": "${\n    function extractSampleId(file) {\n        if (file.hasOwnProperty('metadata') && file.metadata && file.metadata['sample_id']){\n            return file.metadata['sample_id'];\n        } else {\n            return file.basename.split(\".\").slice(0)[0];\n        }\n    }\n    \n    function isTumor(file){\n        if (file.hasOwnProperty('metadata') && file.metadata && file.metadata['sample_type']){\n            return file.metadata['sample_type'].indexOf('Tumor') != -1;\n        } else {\n            return false;\n        }\n    }\n    \n    function removeEmpty(list){\n        list = [].concat(list);\n        var new_list = [];\n        for (var i=0; i < list.length; i++){\n            if (list[i] != \"\"){\n                new_list.push(list[i]);\n            }\n        }\n        return new_list;\n    }\n    \n    var added_suffix = \"\";\n    if (inputs.append_interval_to_name){\n        var intervals = [].concat(inputs.in_interval_files);\n        if (intervals.length > 0){\n            added_suffix = intervals[0].nameroot;\n            if (added_suffix.length >= 4){\n                added_suffix = added_suffix.substring(0, 4);\n            } else {\n                added_suffix = \"\";\n            }\n        }\n    }\n    \n    if (added_suffix.length > 0){\n        added_suffix = \"_\" + added_suffix;\n    }\n    \n    var suffix = added_suffix + \".somatic.vcf\";\n    if (inputs.compress){\n        suffix += \".gz\";\n    }\n    \n    var output = \"mutect2\";\n    \n    if (inputs.output_filename){\n        output = inputs.output_filename;\n    } else {\n        var tumor_id = \"\";\n        var normal_id = \"\";\n        var output_files = [].concat(inputs.in_alignments);\n        \n        if (inputs.tumor_sample){\n            tumor_id = removeEmpty(inputs.tumor_sample)[0];\n        }\n        \n        if (inputs.normal_sample){\n            normal_id = removeEmpty(inputs.normal_sample)[0];\n        }\n        \n        if (!tumor_id || !normal_id){\n            var normal_names = [];\n            var tumor_names = [];\n            \n            if (inputs.normal_sample){\n                normal_names = removeEmpty(inputs.normal_sample);\n            }\n            if (!normal_names[0]){\n                for (var i=0; i < output_files.length; i++){\n                    if (output_files[i]){\n                        var id = extractSampleId(output_files[i]);\n                        if (!isTumor(output_files[i]) && id){\n                            normal_names.push(id);\n                        }\n                    }\n                }\n            }\n            \n            if (inputs.tumor_sample){\n                tumor_names = removeEmpty(inputs.tumor_sample);\n            }\n            if (!tumor_names[0]){\n                for (var i=0; i < output_files.length; i++){\n                    if (output_files[i]){\n                        var id = extractSampleId(output_files[i]);\n                        if (isTumor(output_files[i]) && id){\n                            tumor_names.push(id);\n                        }\n                    }\n                }\n            }\n            \n            if (tumor_names.length == 1){\n                tumor_id = tumor_names[0];\n            }\n            \n            if (normal_names.length == 1){\n                normal_id = normal_names[0];\n            }\n            \n            if (!tumor_id || tumor_names.length>1 || normal_names.length>1){\n                tumor_id = 'mutect2';\n                normal_id = '';\n            }\n        }\n        if (normal_id){\n            output = tumor_id + \"-\" + normal_id\n        } else {\n            output = tumor_id;\n        }\n    }\n    var name = output + suffix;\n    while (name.indexOf(\" \") > -1){\n        name = name.replace(\" \", \"_\")\n    }\n    return name;\n}"
          },
          {
            "prefix": "--f1r2-tar-gz",
            "shellQuote": false,
            "position": 5,
            "valueFrom": "${\n    function extractSampleId(file) {\n        if (file.metadata && file.metadata['sample_id']){\n            return file.metadata['sample_id'];\n        } else {\n            return file.basename.split(\".\").slice(0)[0];\n        }\n    }\n    \n    function isTumor(file){\n        if (output_files[i].metadata && output_files[i].metadata['sample_type']){\n            return output_files[i].metadata['sample_type'].indexOf('Tumor') != -1;\n        } else {\n            return false;\n        }\n    }\n    \n    function removeEmpty(list){\n        list = [].concat(list);\n        var new_list = [];\n        for (var i=0; i < list.length; i++){\n            if (list[i] != \"\"){\n                new_list.push(list[i]);\n            }\n        }\n        return new_list;\n    }\n    \n    // If make_f1_r2 is true, create outoput name and prefix\n    if (inputs.make_f1r2){\n        var added_suffix = \"\";\n        if (inputs.in_interval_files.length > 0){\n            added_suffix = inputs.in_interval_files[0].nameroot;\n            if (added_suffix.length >= 4){\n                added_suffix = added_suffix.substring(0, 4);\n            } else {\n                added_suffix = \"\";\n            }\n        }\n        \n        if (added_suffix.length > 0){\n            added_suffix = \"_\" + added_suffix;\n        }\n        var suffix = added_suffix + \".tar.gz\";\n        var output = \"f1r2\";\n        \n        if (inputs.f1r2_tar_gz){\n            output = inputs.f1r2_tar_gz;\n        } else if (inputs.output_filename){\n            output = inputs.output_filename;\n        } else {\n            var tumor_id = \"\";\n            var normal_id = \"\";\n            var output_files = [].concat(inputs.in_alignments);\n            \n            if (inputs.tumor_sample){\n                tumor_id = removeEmpty(inputs.tumor_sample)[0];\n            }\n            \n            if (inputs.normal_sample){\n                normal_id = removeEmpty(inputs.normal_sample)[0];\n            }\n            \n            if (!tumor_id || !normal_id){\n                var normal_names = [];\n                var tumor_names = [];\n                \n                if (inputs.normal_sample){\n                    normal_names = removeEmpty(inputs.normal_sample);\n                }\n                \n                if (inputs.tumor_sample){\n                    tumor_names = removeEmpty(inputs.tumor_sample);\n                }\n                if (!normal_names[0]){\n                    for (var i=0; i < output_files.length; i++){\n                        var id = extractSampleId(output_files[i]);\n                        if (!isTumor(output_files[i]) && id){\n                            normal_names.push(id);\n                        }\n                    }\n                }\n                \n                if (!tumor_names[0]){\n                    for (var i=0; i < output_files.length; i++){\n                        var id = extractSampleId(output_files[i]);\n                        if (isTumor(output_files[i]) && id){\n                            tumor_names.push(id);\n                        }\n                    }\n                }\n                \n                if (tumor_names.length == 1){\n                    tumor_id = tumor_names[0];\n                }\n                \n                if (normal_names.length == 1){\n                    normal_id = normal_names[0];\n                }\n                \n                if (!tumor_id || tumor_names.length>1 || normal_names.length>1){\n                    tumor_id = 'f1r2';\n                    normal_id = '';\n                }\n            }\n            if (normal_id){\n                output = tumor_id + \"-\" + normal_id\n            } else {\n                output = tumor_id;\n            }\n        }\n        var name = output + suffix;\n        while (name.indexOf(\" \") > -1){\n            name = name.replace(\" \", \"_\")\n        }\n        return name;\n    } else {\n        return null;\n    }\n}"
          },
          {
            "prefix": "--bam-output",
            "shellQuote": false,
            "position": 5,
            "valueFrom": "${\n    function extractSampleId(file) {\n        if (file.metadata && file.metadata['sample_id']){\n            return file.metadata['sample_id'];\n        } else {\n            return file.basename.split(\".\").slice(0)[0];\n        }\n    }\n    \n    function isTumor(file){\n        if (output_files[i].metadata && output_files[i].metadata['sample_type']){\n            return output_files[i].metadata['sample_type'].indexOf('Tumor') != -1;\n        } else {\n            return false;\n        }\n    }\n    \n    function removeEmpty(list){\n        list = [].concat(list);\n        var new_list = [];\n        for (var i=0; i < list.length; i++){\n            if (list[i] != \"\"){\n                new_list.push(list[i]);\n            }\n        }\n        return new_list;\n    }\n    \n    if (inputs.make_bamout){\n        var suffix = '.bam'\n        \n        var output = \"mutect2\";\n        \n        if (inputs.output_bam_filename){\n            output = inputs.output_bam_filename;\n        } else {\n            var tumor_id = \"\";\n            var normal_id = \"\";\n            var output_files = [].concat(inputs.in_alignments);\n            \n            if (inputs.tumor_sample){\n                tumor_id = removeEmpty(inputs.tumor_sample)[0];\n            }\n            \n            if (inputs.normal_sample){\n                normal_id = removeEmpty(inputs.normal_sample)[0];\n            }\n            \n            if (!tumor_id || !normal_id){\n                var normal_names = [];\n                var tumor_names = [];\n                \n                if (inputs.normal_sample){\n                    normal_names = removeEmpty(inputs.normal_sample);\n                }\n                \n                if (inputs.tumor_sample){\n                    tumor_names = removeEmpty(inputs.tumor_sample);\n                }\n                if (!normal_names[0]){\n                    for (var i=0; i < output_files.length; i++){\n                        var id = extractSampleId(output_files[i]);\n                        if (!isTumor(output_files[i]) && id){\n                            normal_names.push(id);\n                        }\n                    }\n                }\n                \n                if (!tumor_names[0]){\n                    for (var i=0; i < output_files.length; i++){\n                        var id = extractSampleId(output_files[i]);\n                        if (isTumor(output_files[i]) && id){\n                            tumor_names.push(id);\n                        }\n                    }\n                }\n                \n                if (tumor_names.length == 1){\n                    tumor_id = tumor_names[0];\n                }\n                \n                if (normal_names.length == 1){\n                    normal_id = normal_names[0];\n                }\n                \n                if (!tumor_id || tumor_names.length>1 || normal_names.length>1){\n                    tumor_id = 'mutect2';\n                    normal_id = '';\n                }\n            }\n            if (normal_id){\n                output = tumor_id + \"-\" + normal_id\n            } else {\n                output = tumor_id;\n            }\n        }\n        var name = output + suffix;\n        while (name.indexOf(\" \") > -1){\n            name = name.replace(\" \", \"_\")\n        }\n        return name;\n    } else {\n        return null;\n    }\n}"
          }
        ],
        "requirements": [
          {
            "class": "ShellCommandRequirement"
          },
          {
            "class": "ResourceRequirement",
            "ramMin": "${\n    var memory = 7500;\n    if (inputs.mem_per_job){\n        memory = inputs.mem_per_job;\n    }\n    var overhead = 500;\n    if (inputs.mem_overhead_per_job || inputs.mem_overhead_per_job == 0){\n        overhead = inputs.mem_overhead_per_job;\n    }\n    return memory + overhead;\n}",
            "coresMin": "${\n    var cpus = 1;\n    if (inputs.cpu_per_job){\n        cpus = inputs.cpu_per_job;\n    }\n    return cpus;\n}"
          },
          {
            "class": "DockerRequirement",
            "dockerPull": "images.sbgenomics.com/pavle.marinkovic/gatk_4-1-9-0:0"
          },
          {
            "class": "InitialWorkDirRequirement",
            "listing": []
          },
          {
            "class": "InlineJavascriptRequirement"
          }
        ],
        "sbg:categories": [
          "GATK-4",
          "CWL1.0"
        ],
        "sbg:image_url": null,
        "sbg:license": "Open source BSD (3-clause) license",
        "sbg:links": [
          {
            "id": "https://software.broadinstitute.org/gatk/",
            "label": "Homepage"
          },
          {
            "id": "https://github.com/broadinstitute/gatk/",
            "label": "Source"
          },
          {
            "id": "https://github.com/broadinstitute/gatk/releases/download/4.1.6.0/gatk-4.1.6.0.zip",
            "label": "Download"
          },
          {
            "id": "https://www.ncbi.nlm.nih.gov/pubmed?term=20644199",
            "label": "Publication"
          },
          {
            "id": "https://software.broadinstitute.org/gatk/documentation/tooldocs/4.1.6.0/org_broadinstitute_hellbender_tools_walkers_mutect_Mutect2.php",
            "label": "Documentation"
          }
        ],
        "sbg:projectName": "BUILD: Mitochondria Pipeline",
        "sbg:revisionsInfo": [
          {
            "sbg:revision": 0,
            "sbg:modifiedBy": "dave",
            "sbg:modifiedOn": 1622646232,
            "sbg:revisionNotes": "Uploaded using sbpack v2020.10.05. \nSource: gatk_mutect2_cwl1_0.cwl"
          },
          {
            "sbg:revision": 1,
            "sbg:modifiedBy": "dave",
            "sbg:modifiedOn": 1622834532,
            "sbg:revisionNotes": "single input file bam"
          },
          {
            "sbg:revision": 2,
            "sbg:modifiedBy": "dave",
            "sbg:modifiedOn": 1622834908,
            "sbg:revisionNotes": ""
          },
          {
            "sbg:revision": 3,
            "sbg:modifiedBy": "dave",
            "sbg:modifiedOn": 1622835842,
            "sbg:revisionNotes": "added .fai secondary file"
          },
          {
            "sbg:revision": 4,
            "sbg:modifiedBy": "dave",
            "sbg:modifiedOn": 1622855767,
            "sbg:revisionNotes": "^.dict"
          },
          {
            "sbg:revision": 5,
            "sbg:modifiedBy": "dave",
            "sbg:modifiedOn": 1622862857,
            "sbg:revisionNotes": ""
          }
        ],
        "sbg:toolAuthor": "Broad Institute",
        "sbg:toolkit": "GATK",
        "sbg:toolkitVersion": "4.1.9.0",
        "sbg:wrapperAuthor": "Pavle Marinkovic",
        "sbg:appVersion": [
          "v1.2"
        ],
        "sbg:id": "dave/build-mitochondria-pipeline/gatk-mutect2/5",
        "sbg:revision": 5,
        "sbg:revisionNotes": "",
        "sbg:modifiedOn": 1622862857,
        "sbg:modifiedBy": "dave",
        "sbg:createdOn": 1622646232,
        "sbg:createdBy": "dave",
        "sbg:project": "dave/build-mitochondria-pipeline",
        "sbg:sbgMaintained": false,
        "sbg:validationErrors": [],
        "sbg:contributors": [
          "dave"
        ],
        "sbg:latestRevision": 5,
        "sbg:publisher": "sbg",
        "sbg:content_hash": "acace08f44a80755f97843e88640bde484aaa476b26c41ac00ec1ff7cf2407fc2"
      },
      "label": "shifted mutect2",
      "doc": "https://github.com/cwl-apps/gatk-best-practices/blob/8f54dbc054ef5d5401a48d13b9979d3156da4e6d/pre-processing.cwl.steps/gatk_samtofastq_4_1_0_0.cwl",
      "sbg:x": 1301.24658203125,
      "sbg:y": 277.34375
    },
    {
      "id": "picard_collectwgsmetricswithnonzerocoverage_2_21_6_cwl1_2",
      "in": [
        {
          "id": "in_alignments",
          "source": "bwa_mem_bundle/aligned_reads"
        },
        {
          "id": "in_reference",
          "source": "in_reference_and_index_1"
        }
      ],
      "out": [
        {
          "id": "output_chart"
        },
        {
          "id": "wgs_metrics"
        },
        {
          "id": "theoretical_sensitivity_out_file"
        }
      ],
      "run": {
        "class": "CommandLineTool",
        "cwlVersion": "v1.2",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "id": "dave/build-mitochondria-pipeline/picard-collectwgsmetricswithnonzerocoverage-2-21-6-cwl1-0/1",
        "baseCommand": [
          "java"
        ],
        "inputs": [
          {
            "sbg:altPrefix": "CHART=",
            "id": "chart_output",
            "type": "string?",
            "inputBinding": {
              "prefix": "CHART_OUTPUT=",
              "separate": false,
              "shellQuote": false,
              "position": 7,
              "valueFrom": "${\n    if (self == 0) {\n        self = null;\n        inputs.chart_output = null\n    };\n\n\n    if (inputs.chart_output) {\n        return inputs.chart_output.concat('.pdf')\n    } else {\n        filename = [].concat(inputs.in_alignments)[0].nameroot\n        return filename.concat('.pdf')\n    }\n}"
            },
            "label": "Output chart file name",
            "doc": "Output chart file name.",
            "default": 0
          },
          {
            "sbg:category": "Options",
            "sbg:toolDefaultValue": "5",
            "id": "compression_level",
            "type": "int?",
            "inputBinding": {
              "prefix": "COMPRESSION_LEVEL=",
              "separate": false,
              "shellQuote": false,
              "position": 8
            },
            "label": "Compression level",
            "doc": "Compression level for all compressed files created (e.g. BAM and GELI). Default value: 5. This option can be set to 'null' to clear the default value."
          },
          {
            "sbg:category": "Options",
            "sbg:toolDefaultValue": "false",
            "id": "count_unpaired",
            "type": [
              "null",
              {
                "type": "enum",
                "symbols": [
                  "true",
                  "false"
                ],
                "name": "count_unpaired"
              }
            ],
            "inputBinding": {
              "prefix": "COUNT_UNPAIRED=",
              "separate": false,
              "shellQuote": false,
              "position": 4
            },
            "label": "Count unpaired",
            "doc": "If option true is selected, unpaired reads and paired reads with one unmapped end will be counted. Possible values: {true, false}."
          },
          {
            "sbg:altPrefix": "CAP",
            "sbg:category": "Options",
            "sbg:toolDefaultValue": "250",
            "id": "coverage_cap",
            "type": "int?",
            "inputBinding": {
              "prefix": "COVERAGE_CAP=",
              "separate": false,
              "shellQuote": false,
              "position": 11
            },
            "label": "Coverage cap",
            "doc": "This option provides a maximum value for base coverage. Bases with coverage exceeding the given coverage value will be treated as they if they had such maximum value."
          },
          {
            "sbg:category": "Options",
            "sbg:toolDefaultValue": "false",
            "id": "include_bq_histogram",
            "type": [
              "null",
              {
                "type": "enum",
                "symbols": [
                  "true",
                  "false"
                ],
                "name": "include_bq_histogram"
              }
            ],
            "inputBinding": {
              "prefix": "INCLUDE_BQ_HISTOGRAM=",
              "separate": false,
              "shellQuote": false,
              "position": 4
            },
            "label": "Include base quality histogram",
            "doc": "This parameter determines whether to include the base quality histogram in the metrics file.  Possible values: {true, false}."
          },
          {
            "sbg:altPrefix": "I",
            "sbg:category": "File inputs",
            "id": "in_alignments",
            "type": "File",
            "inputBinding": {
              "prefix": "INPUT=",
              "separate": false,
              "shellQuote": false,
              "position": 4
            },
            "label": "Input SAM or BAM file",
            "doc": "Input SAM or BAM file.  Required. Note: Sort order should be coordinate based and not query name based.",
            "sbg:fileTypes": "SAM, BAM"
          },
          {
            "sbg:category": "File inputs",
            "id": "intervals",
            "type": "File?",
            "inputBinding": {
              "prefix": "INTERVALS=",
              "separate": false,
              "shellQuote": false,
              "position": 7
            },
            "label": "Intervals file",
            "doc": "Intervals file.",
            "sbg:fileTypes": "INTERVAL_LIST"
          },
          {
            "sbg:category": "Options",
            "sbg:toolDefaultValue": "500000",
            "id": "max_records_in_ram",
            "type": "int?",
            "inputBinding": {
              "prefix": "MAX_RECORDS_IN_RAM=",
              "separate": false,
              "shellQuote": false,
              "position": 8
            },
            "label": "Max records in RAM",
            "doc": "When writing SAM files that need to be sorted, this parameter will specify the number of records stored in RAM before spilling to disk. Increasing this number reduces the number of file handles needed to sort a SAM file, and increases the amount of RAM needed. Default value: 500000. This option can be set to 'null' to clear the default value."
          },
          {
            "sbg:category": "Platform options",
            "sbg:toolDefaultValue": "2048",
            "id": "mem_per_job",
            "type": "int?",
            "label": "Memory per job [MB]",
            "doc": "Amount of RAM memory to be used per job. Defaults to 2048MB for single threaded jobs."
          },
          {
            "sbg:altPrefix": "Q",
            "sbg:category": "Options",
            "sbg:toolDefaultValue": "20",
            "id": "minimum_base_quality",
            "type": "int?",
            "inputBinding": {
              "prefix": "MINIMUM_BASE_QUALITY=",
              "separate": false,
              "shellQuote": false,
              "position": 11
            },
            "label": "Minimum base quality",
            "doc": "Minimum base quality for a base to contribute coverage."
          },
          {
            "sbg:altPrefix": "MQ",
            "sbg:category": "Options",
            "sbg:toolDefaultValue": "20",
            "id": "minimum_mapping_quality",
            "type": "int?",
            "inputBinding": {
              "prefix": "MINIMUM_MAPPING_QUALITY=",
              "separate": false,
              "shellQuote": false,
              "position": 11
            },
            "label": "Minimum mapping quality",
            "doc": "Minimum mapping quality for a read to contribute coverage."
          },
          {
            "sbg:category": "Options",
            "sbg:toolDefaultValue": "false",
            "id": "quiet",
            "type": [
              "null",
              {
                "type": "enum",
                "symbols": [
                  "true",
                  "false"
                ],
                "name": "quiet"
              }
            ],
            "inputBinding": {
              "prefix": "QUIET=",
              "separate": false,
              "shellQuote": false,
              "position": 8
            },
            "label": "Quiet",
            "doc": "Whether to suppress job-summary info on System.err. Default value: false. This option can be set to 'null' to clear the default value. Possible values: {true, false}."
          },
          {
            "sbg:altPrefix": "R=",
            "sbg:category": "File inputs",
            "id": "in_reference",
            "type": "File",
            "inputBinding": {
              "prefix": "REFERENCE_SEQUENCE=",
              "separate": false,
              "shellQuote": false,
              "position": 7
            },
            "label": "Reference",
            "doc": "The reference sequence in FASTA format to which reads will be aligned.  Required.",
            "sbg:fileTypes": "FASTA, FA, FASTA.GZ"
          },
          {
            "sbg:category": "Options",
            "sbg:toolDefaultValue": "-1",
            "id": "stop_after",
            "type": "int?",
            "inputBinding": {
              "prefix": "STOP_AFTER=",
              "separate": false,
              "shellQuote": false,
              "position": 13
            },
            "label": "Stop after",
            "doc": "For debugging purposes, stop after processing the given number of genomic bases.  Default value: -1. This option can be set to 'null' to clear the default value."
          },
          {
            "sbg:category": "Options",
            "sbg:toolDefaultValue": "SILENT",
            "id": "validation_stringency",
            "type": [
              "null",
              {
                "type": "enum",
                "symbols": [
                  "STRICT",
                  "LENIENT",
                  "SILENT"
                ],
                "name": "validation_stringency"
              }
            ],
            "inputBinding": {
              "prefix": "VALIDATION_STRINGENCY=",
              "separate": false,
              "shellQuote": false,
              "position": 8,
              "valueFrom": "${\n    if (self == 0) {\n        self = null;\n        inputs.validation_stringency = null\n    };\n\n\n    if (inputs.validation_stringency) {\n        return inputs.validation_stringency\n    } else {\n        return \"SILENT\"\n    }\n}"
            },
            "label": "Validation stringency",
            "doc": "Validation stringency for all SAM files read by this program. Setting stringency to SILENT can improve performance when processing a BAM file in which variable-length data (read, qualities, tags) do not otherwise need to be decoded. Default value: STRICT. This option can be set to 'null' to clear the default value. Possible values: {STRICT, LENIENT, SILENT}.",
            "default": 0
          },
          {
            "sbg:category": "Options",
            "sbg:toolDefaultValue": "INFO",
            "id": "verbosity",
            "type": [
              "null",
              {
                "type": "enum",
                "symbols": [
                  "ERROR",
                  "WARNING",
                  "INFO",
                  "DEBUG"
                ],
                "name": "verbosity"
              }
            ],
            "inputBinding": {
              "prefix": "VERBOSITY=",
              "separate": false,
              "shellQuote": false,
              "position": 10
            },
            "label": "Verbosity",
            "doc": "Control verbosity of logging. Default value: INFO. This option can be set to 'null' to clear the default value. Possible values: {ERROR, WARNING, INFO, DEBUG}."
          },
          {
            "sbg:altPrefix": "O",
            "id": "output_prefix",
            "type": "string?",
            "label": "Output metrics file prefix",
            "doc": "Output metrics file prefix."
          },
          {
            "sbg:category": "Options",
            "sbg:toolDefaultValue": "100000",
            "id": "locus_accumulation_cap",
            "type": "int?",
            "inputBinding": {
              "prefix": "LOCUS_ACCUMULATION_CAP=",
              "separate": false,
              "shellQuote": false,
              "position": 10
            },
            "label": "Locus accumulation cap",
            "doc": "At positions with coverage exceeding this value, completely ignore reads that accumulate beyond this value (so that they will not be considered for PCT_EXC_CAPPED).  Used to keep memory consumption in check, but could create bias if set too low."
          },
          {
            "sbg:category": "Options",
            "sbg:toolDefaultValue": "10000",
            "id": "sample_size",
            "type": "int?",
            "inputBinding": {
              "prefix": "SAMPLE_SIZE=",
              "separate": false,
              "shellQuote": false,
              "position": 12
            },
            "label": "Sample size for theoretical het sensitivity sampling",
            "doc": "Sample Size used for theoretical het sensitivity sampling. Default is 10000."
          },
          {
            "sbg:category": "Options",
            "id": "theoretical_sensitivity_output",
            "type": "string?",
            "inputBinding": {
              "prefix": "THEORETICAL_SENSITIVITY_OUTPUT=",
              "separate": false,
              "shellQuote": false,
              "position": 13,
              "valueFrom": "${\n    if (self == 0) {\n        self = null;\n        inputs.theoretical_sensitivity_output = null\n    };\n\n\n    if (inputs.theoretical_sensitivity_output) {\n        return inputs.theoretical_sensitivity_output.concat('.ths.txt')\n    } else {\n        filename = [].concat(inputs.in_alignments)[0].nameroot\n        return filename.concat('.ths.txt')\n    }\n}"
            },
            "label": "Output file name prefix for theoretical sensitivity",
            "doc": "Outpu file namet prefix for theoretical sensitivity metrics."
          },
          {
            "sbg:category": "Options",
            "id": "allele_fraction",
            "type": [
              "null",
              {
                "type": "array",
                "items": "float",
                "inputBinding": {
                  "separate": false,
                  "prefix": "ALLELE_FRACTION="
                }
              }
            ],
            "inputBinding": {
              "prefix": "",
              "separate": false,
              "shellQuote": false,
              "position": 14
            },
            "label": "Allele fraction for theoretical sensitivity",
            "doc": "Allele fraction for which to calculate theoretical sensitivity.  Default value: [0.001,\n 0.005, 0.01, 0.02, 0.05, 0.1, 0.2, 0.3, 0.5]."
          },
          {
            "sbg:category": "Options",
            "id": "use_fast_algorithm",
            "type": [
              "null",
              {
                "type": "enum",
                "symbols": [
                  "true",
                  "false"
                ],
                "name": "use_fast_algorithm"
              }
            ],
            "inputBinding": {
              "prefix": "USE_FAST_ALGORITHM=",
              "separate": false,
              "shellQuote": false,
              "position": 15
            },
            "label": "Use fast algorithm",
            "doc": "Use fast algorithm."
          },
          {
            "sbg:category": "Options",
            "sbg:toolDefaultValue": "150",
            "id": "read_length",
            "type": "int?",
            "inputBinding": {
              "prefix": "READ_LENGTH=",
              "separate": false,
              "shellQuote": false,
              "position": 16
            },
            "label": "Average read length",
            "doc": "Average read length in the file. Default is 150."
          },
          {
            "sbg:category": "Platform Options",
            "sbg:toolDefaultValue": "128",
            "id": "mem_overhead_per_job",
            "type": "int?",
            "label": "Memory overhead per job [MB]",
            "doc": "Memory overhead per job [MB]."
          }
        ],
        "outputs": [
          {
            "id": "output_chart",
            "doc": "Output chart.",
            "label": "Output chart",
            "type": "File?",
            "outputBinding": {
              "glob": "*.pdf",
              "outputEval": "${\n    return inheritMetadata(self, inputs.in_alignments)\n\n}"
            },
            "sbg:fileTypes": "PDF"
          },
          {
            "id": "wgs_metrics",
            "doc": "Output metrics file.",
            "label": "WGS metrics",
            "type": "File?",
            "outputBinding": {
              "glob": "*.wgs_metrics.txt",
              "outputEval": "$(inheritMetadata(self, inputs.in_alignments))"
            },
            "sbg:fileTypes": "TXT"
          },
          {
            "id": "theoretical_sensitivity_out_file",
            "doc": "Theoretical sensitivity output file.",
            "label": "Theoretical sensitivity output file",
            "type": "File?",
            "outputBinding": {
              "glob": "*.ths.txt",
              "outputEval": "$(inheritMetadata(self, inputs.in_alignments))"
            },
            "sbg:fileTypes": "TXT"
          }
        ],
        "doc": "**Picard CollectWgsMetricsWithNonZeroCoverage** evaluates the coverage and performance of whole genome sequencing experiments [1].\n\n*A list of **all inputs and parameters** with corresponding descriptions can be found at the end of the page.*\n\n### Common Use Cases\n\n**Picard CollectWgsMetricsWithNonZeroCoverage** can be used for quality control of WGS data.\n\n### Changes Introduced by Seven Bridges\n\nNo significant changes were introduced. \n\n### Common Issues and Important Notes\n\n* Input  **Input SAM or BAM file** is required and the file should be coordinate sorted. \n* Input **Reference** is required.\n\n### Performance Benchmarking\n\nPerformance of the tool depends on the size of the input alignments file. Analysing 30x (40 GB) and 50x (72.3 GB) coverage WGS BAM files on the default on-demand AWS instances took 2 h 9 min ($0.86) and 3 h 32 min ($1.41), respectively.\n\n*Cost can be significantly reduced by **spot instance** usage. Visit the [Knowledge Center](https://docs.sevenbridges.com/docs/about-spot-instances) for more details.*  \n\n### References\n\n[1] [Picard documentation](http://broadinstitute.github.io/picard/command-line-overview.html#CollectWgsMetricsWithNonZeroCoverage)",
        "label": "Picard CollectWgsMetricsWithNonZeroCoverage CWL1.0",
        "arguments": [
          {
            "prefix": "",
            "shellQuote": false,
            "position": 0,
            "valueFrom": "${\n    if (inputs.mem_per_job) {\n        return '-Xmx'.concat(inputs.mem_per_job, 'M')\n    }\n    return '-Xmx2048M'\n}"
          },
          {
            "shellQuote": false,
            "position": 1,
            "valueFrom": "-jar"
          },
          {
            "prefix": "",
            "shellQuote": false,
            "position": 2,
            "valueFrom": "/opt/picard-2.21.6/picard.jar"
          },
          {
            "shellQuote": false,
            "position": 3,
            "valueFrom": "CollectWgsMetricsWithNonZeroCoverage"
          },
          {
            "prefix": "OUTPUT=",
            "separate": false,
            "shellQuote": false,
            "position": 4,
            "valueFrom": "${\n    if (inputs.output_prefix)\n    {\n        return inputs.output_prefix.concat(\".wgs_metrics.txt\")\n    }\n    else if (inputs.in_alignments) {\n        filename = [].concat(inputs.in_alignments)[0].nameroot\n\n        return filename.concat(\".wgs_metrics.txt\")\n    }\n}"
          }
        ],
        "requirements": [
          {
            "class": "ShellCommandRequirement"
          },
          {
            "class": "ResourceRequirement",
            "ramMin": "${\n    if ((inputs.mem_per_job) && (inputs.mem_overhead_per_job))\n    {\n        return inputs.mem_per_job + inputs.mem_overhead_per_job\n    }\n    else if (inputs.mem_per_job)\n    {\n        return inputs.mem_per_job + 128\n    }\n    else if (inputs.mem_overhead_per_job)\n    {\n        return 2048 + inputs.mem_overhead_per_job\n    }\n    else\n    {\n    return 2048\n    }\n}",
            "coresMin": 1
          },
          {
            "class": "DockerRequirement",
            "dockerImageId": "eab0e70b6629",
            "dockerPull": "images.sbgenomics.com/jovana_vranic/picard-2-21-6:1"
          },
          {
            "class": "InitialWorkDirRequirement",
            "listing": []
          },
          {
            "class": "InlineJavascriptRequirement",
            "expressionLib": [
              "var updateMetadata = function(file, key, value) {\n    file['metadata'][key] = value;\n    return file;\n};\n\n\nvar setMetadata = function(file, metadata) {\n    if (!('metadata' in file)) {\n        file['metadata'] = {}\n    }\n    for (var key in metadata) {\n        file['metadata'][key] = metadata[key];\n    }\n    return file\n};\n\nvar inheritMetadata = function(o1, o2) {\n    var commonMetadata = {};\n    if (!Array.isArray(o2)) {\n        o2 = [o2]\n    }\n    for (var i = 0; i < o2.length; i++) {\n        var example = o2[i]['metadata'];\n        for (var key in example) {\n            if (i == 0)\n                commonMetadata[key] = example[key];\n            else {\n                if (!(commonMetadata[key] == example[key])) {\n                    delete commonMetadata[key]\n                }\n            }\n        }\n    }\n    if (!Array.isArray(o1)) {\n        o1 = setMetadata(o1, commonMetadata)\n    } else {\n        for (var i = 0; i < o1.length; i++) {\n            o1[i] = setMetadata(o1[i], commonMetadata)\n        }\n    }\n    return o1;\n};\n\nvar toArray = function(file) {\n    return [].concat(file);\n};\n\nvar groupBy = function(files, key) {\n    var groupedFiles = [];\n    var tempDict = {};\n    for (var i = 0; i < files.length; i++) {\n        var value = files[i]['metadata'][key];\n        if (value in tempDict)\n            tempDict[value].push(files[i]);\n        else tempDict[value] = [files[i]];\n    }\n    for (var key in tempDict) {\n        groupedFiles.push(tempDict[key]);\n    }\n    return groupedFiles;\n};\n\nvar orderBy = function(files, key, order) {\n    var compareFunction = function(a, b) {\n        if (a['metadata'][key].constructor === Number) {\n            return a['metadata'][key] - b['metadata'][key];\n        } else {\n            var nameA = a['metadata'][key].toUpperCase();\n            var nameB = b['metadata'][key].toUpperCase();\n            if (nameA < nameB) {\n                return -1;\n            }\n            if (nameA > nameB) {\n                return 1;\n            }\n            return 0;\n        }\n    };\n\n    files = files.sort(compareFunction);\n    if (order == undefined || order == \"asc\")\n        return files;\n    else\n        return files.reverse();\n};",
              "\nvar setMetadata = function(file, metadata) {\n    if (!('metadata' in file)) {\n        file['metadata'] = {}\n    }\n    for (var key in metadata) {\n        file['metadata'][key] = metadata[key];\n    }\n    return file\n};\nvar inheritMetadata = function(o1, o2) {\n    var commonMetadata = {};\n    if (!o2) {\n        return o1;\n    };\n    if (!Array.isArray(o2)) {\n        o2 = [o2]\n    }\n    for (var i = 0; i < o2.length; i++) {\n        var example = o2[i]['metadata'];\n        for (var key in example) {\n            if (i == 0)\n                commonMetadata[key] = example[key];\n            else {\n                if (!(commonMetadata[key] == example[key])) {\n                    delete commonMetadata[key]\n                }\n            }\n        }\n        for (var key in commonMetadata) {\n            if (!(key in example)) {\n                delete commonMetadata[key]\n            }\n        }\n    }\n    if (!Array.isArray(o1)) {\n        o1 = setMetadata(o1, commonMetadata)\n    } else {\n        for (var i = 0; i < o1.length; i++) {\n            o1[i] = setMetadata(o1[i], commonMetadata)\n        }\n    }\n    return o1;\n};"
            ]
          }
        ],
        "sbg:categories": [
          "SAM/BAM-Processing",
          "Quality-Control",
          "CWL1.0"
        ],
        "sbg:cmdPreview": "java -Xmx2048M -jar /opt/picard.jar CollectWgsMetricsWithNonZeroCoverage INPUT=/root/folder/example.bam OUTPUT=example.wgs_metrics.txt REFERENCE_SEQUENCE=/second/folder/human.fasta",
        "sbg:image_url": null,
        "sbg:license": "MIT License",
        "sbg:links": [
          {
            "id": "http://broadinstitute.github.io/picard/",
            "label": "Homepage"
          },
          {
            "id": "https://github.com/broadinstitute/picard/releases/tag/1.140",
            "label": "Source Code"
          },
          {
            "id": "http://broadinstitute.github.io/picard/",
            "label": "Wiki"
          },
          {
            "id": "https://github.com/broadinstitute/picard/zipball/master",
            "label": "Download"
          },
          {
            "id": "http://broadinstitute.github.io/picard/",
            "label": "Publication"
          }
        ],
        "sbg:toolAuthor": "Broad Institute",
        "sbg:toolkit": "Picard",
        "sbg:toolkitVersion": "2.21.6",
        "sbg:projectName": "BUILD: Mitochondria Pipeline",
        "sbg:revisionsInfo": [
          {
            "sbg:revision": 0,
            "sbg:modifiedBy": "dave",
            "sbg:modifiedOn": 1622863845,
            "sbg:revisionNotes": "Copy of admin/sbg-public-data/picard-collectwgsmetricswithnonzerocoverage-2-21-6-cwl1-0/3"
          },
          {
            "sbg:revision": 1,
            "sbg:modifiedBy": "dave",
            "sbg:modifiedOn": 1622864324,
            "sbg:revisionNotes": ""
          }
        ],
        "sbg:expand_workflow": false,
        "sbg:appVersion": [
          "v1.2"
        ],
        "sbg:id": "dave/build-mitochondria-pipeline/picard-collectwgsmetricswithnonzerocoverage-2-21-6-cwl1-0/1",
        "sbg:revision": 1,
        "sbg:revisionNotes": "",
        "sbg:modifiedOn": 1622864324,
        "sbg:modifiedBy": "dave",
        "sbg:createdOn": 1622863845,
        "sbg:createdBy": "dave",
        "sbg:project": "dave/build-mitochondria-pipeline",
        "sbg:sbgMaintained": false,
        "sbg:validationErrors": [],
        "sbg:contributors": [
          "dave"
        ],
        "sbg:latestRevision": 1,
        "sbg:publisher": "sbg",
        "sbg:content_hash": "aa7fb123a0b435d3e287ed99cc531fb694bb191bb5ce90c4755504b13cbda1bb1"
      },
      "label": "non shifted metrics",
      "sbg:x": 1301.24658203125,
      "sbg:y": 0
    },
    {
      "id": "picard_collectwgsmetricswithnonzerocoverage_2_21_6_cwl1_1",
      "in": [
        {
          "id": "in_alignments",
          "source": "bwa_mem_bundle_1/aligned_reads"
        },
        {
          "id": "in_reference",
          "source": "in_reference_and_index"
        }
      ],
      "out": [
        {
          "id": "output_chart"
        },
        {
          "id": "wgs_metrics"
        },
        {
          "id": "theoretical_sensitivity_out_file"
        }
      ],
      "run": {
        "class": "CommandLineTool",
        "cwlVersion": "v1.2",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "id": "dave/build-mitochondria-pipeline/picard-collectwgsmetricswithnonzerocoverage-2-21-6-cwl1-0/1",
        "baseCommand": [
          "java"
        ],
        "inputs": [
          {
            "sbg:altPrefix": "CHART=",
            "id": "chart_output",
            "type": "string?",
            "inputBinding": {
              "prefix": "CHART_OUTPUT=",
              "separate": false,
              "shellQuote": false,
              "position": 7,
              "valueFrom": "${\n    if (self == 0) {\n        self = null;\n        inputs.chart_output = null\n    };\n\n\n    if (inputs.chart_output) {\n        return inputs.chart_output.concat('.pdf')\n    } else {\n        filename = [].concat(inputs.in_alignments)[0].nameroot\n        return filename.concat('.pdf')\n    }\n}"
            },
            "label": "Output chart file name",
            "doc": "Output chart file name.",
            "default": 0
          },
          {
            "sbg:category": "Options",
            "sbg:toolDefaultValue": "5",
            "id": "compression_level",
            "type": "int?",
            "inputBinding": {
              "prefix": "COMPRESSION_LEVEL=",
              "separate": false,
              "shellQuote": false,
              "position": 8
            },
            "label": "Compression level",
            "doc": "Compression level for all compressed files created (e.g. BAM and GELI). Default value: 5. This option can be set to 'null' to clear the default value."
          },
          {
            "sbg:category": "Options",
            "sbg:toolDefaultValue": "false",
            "id": "count_unpaired",
            "type": [
              "null",
              {
                "type": "enum",
                "symbols": [
                  "true",
                  "false"
                ],
                "name": "count_unpaired"
              }
            ],
            "inputBinding": {
              "prefix": "COUNT_UNPAIRED=",
              "separate": false,
              "shellQuote": false,
              "position": 4
            },
            "label": "Count unpaired",
            "doc": "If option true is selected, unpaired reads and paired reads with one unmapped end will be counted. Possible values: {true, false}."
          },
          {
            "sbg:altPrefix": "CAP",
            "sbg:category": "Options",
            "sbg:toolDefaultValue": "250",
            "id": "coverage_cap",
            "type": "int?",
            "inputBinding": {
              "prefix": "COVERAGE_CAP=",
              "separate": false,
              "shellQuote": false,
              "position": 11
            },
            "label": "Coverage cap",
            "doc": "This option provides a maximum value for base coverage. Bases with coverage exceeding the given coverage value will be treated as they if they had such maximum value."
          },
          {
            "sbg:category": "Options",
            "sbg:toolDefaultValue": "false",
            "id": "include_bq_histogram",
            "type": [
              "null",
              {
                "type": "enum",
                "symbols": [
                  "true",
                  "false"
                ],
                "name": "include_bq_histogram"
              }
            ],
            "inputBinding": {
              "prefix": "INCLUDE_BQ_HISTOGRAM=",
              "separate": false,
              "shellQuote": false,
              "position": 4
            },
            "label": "Include base quality histogram",
            "doc": "This parameter determines whether to include the base quality histogram in the metrics file.  Possible values: {true, false}."
          },
          {
            "sbg:altPrefix": "I",
            "sbg:category": "File inputs",
            "id": "in_alignments",
            "type": "File",
            "inputBinding": {
              "prefix": "INPUT=",
              "separate": false,
              "shellQuote": false,
              "position": 4
            },
            "label": "Input SAM or BAM file",
            "doc": "Input SAM or BAM file.  Required. Note: Sort order should be coordinate based and not query name based.",
            "sbg:fileTypes": "SAM, BAM"
          },
          {
            "sbg:category": "File inputs",
            "id": "intervals",
            "type": "File?",
            "inputBinding": {
              "prefix": "INTERVALS=",
              "separate": false,
              "shellQuote": false,
              "position": 7
            },
            "label": "Intervals file",
            "doc": "Intervals file.",
            "sbg:fileTypes": "INTERVAL_LIST"
          },
          {
            "sbg:category": "Options",
            "sbg:toolDefaultValue": "500000",
            "id": "max_records_in_ram",
            "type": "int?",
            "inputBinding": {
              "prefix": "MAX_RECORDS_IN_RAM=",
              "separate": false,
              "shellQuote": false,
              "position": 8
            },
            "label": "Max records in RAM",
            "doc": "When writing SAM files that need to be sorted, this parameter will specify the number of records stored in RAM before spilling to disk. Increasing this number reduces the number of file handles needed to sort a SAM file, and increases the amount of RAM needed. Default value: 500000. This option can be set to 'null' to clear the default value."
          },
          {
            "sbg:category": "Platform options",
            "sbg:toolDefaultValue": "2048",
            "id": "mem_per_job",
            "type": "int?",
            "label": "Memory per job [MB]",
            "doc": "Amount of RAM memory to be used per job. Defaults to 2048MB for single threaded jobs."
          },
          {
            "sbg:altPrefix": "Q",
            "sbg:category": "Options",
            "sbg:toolDefaultValue": "20",
            "id": "minimum_base_quality",
            "type": "int?",
            "inputBinding": {
              "prefix": "MINIMUM_BASE_QUALITY=",
              "separate": false,
              "shellQuote": false,
              "position": 11
            },
            "label": "Minimum base quality",
            "doc": "Minimum base quality for a base to contribute coverage."
          },
          {
            "sbg:altPrefix": "MQ",
            "sbg:category": "Options",
            "sbg:toolDefaultValue": "20",
            "id": "minimum_mapping_quality",
            "type": "int?",
            "inputBinding": {
              "prefix": "MINIMUM_MAPPING_QUALITY=",
              "separate": false,
              "shellQuote": false,
              "position": 11
            },
            "label": "Minimum mapping quality",
            "doc": "Minimum mapping quality for a read to contribute coverage."
          },
          {
            "sbg:category": "Options",
            "sbg:toolDefaultValue": "false",
            "id": "quiet",
            "type": [
              "null",
              {
                "type": "enum",
                "symbols": [
                  "true",
                  "false"
                ],
                "name": "quiet"
              }
            ],
            "inputBinding": {
              "prefix": "QUIET=",
              "separate": false,
              "shellQuote": false,
              "position": 8
            },
            "label": "Quiet",
            "doc": "Whether to suppress job-summary info on System.err. Default value: false. This option can be set to 'null' to clear the default value. Possible values: {true, false}."
          },
          {
            "sbg:altPrefix": "R=",
            "sbg:category": "File inputs",
            "id": "in_reference",
            "type": "File",
            "inputBinding": {
              "prefix": "REFERENCE_SEQUENCE=",
              "separate": false,
              "shellQuote": false,
              "position": 7
            },
            "label": "Reference",
            "doc": "The reference sequence in FASTA format to which reads will be aligned.  Required.",
            "sbg:fileTypes": "FASTA, FA, FASTA.GZ"
          },
          {
            "sbg:category": "Options",
            "sbg:toolDefaultValue": "-1",
            "id": "stop_after",
            "type": "int?",
            "inputBinding": {
              "prefix": "STOP_AFTER=",
              "separate": false,
              "shellQuote": false,
              "position": 13
            },
            "label": "Stop after",
            "doc": "For debugging purposes, stop after processing the given number of genomic bases.  Default value: -1. This option can be set to 'null' to clear the default value."
          },
          {
            "sbg:category": "Options",
            "sbg:toolDefaultValue": "SILENT",
            "id": "validation_stringency",
            "type": [
              "null",
              {
                "type": "enum",
                "symbols": [
                  "STRICT",
                  "LENIENT",
                  "SILENT"
                ],
                "name": "validation_stringency"
              }
            ],
            "inputBinding": {
              "prefix": "VALIDATION_STRINGENCY=",
              "separate": false,
              "shellQuote": false,
              "position": 8,
              "valueFrom": "${\n    if (self == 0) {\n        self = null;\n        inputs.validation_stringency = null\n    };\n\n\n    if (inputs.validation_stringency) {\n        return inputs.validation_stringency\n    } else {\n        return \"SILENT\"\n    }\n}"
            },
            "label": "Validation stringency",
            "doc": "Validation stringency for all SAM files read by this program. Setting stringency to SILENT can improve performance when processing a BAM file in which variable-length data (read, qualities, tags) do not otherwise need to be decoded. Default value: STRICT. This option can be set to 'null' to clear the default value. Possible values: {STRICT, LENIENT, SILENT}.",
            "default": 0
          },
          {
            "sbg:category": "Options",
            "sbg:toolDefaultValue": "INFO",
            "id": "verbosity",
            "type": [
              "null",
              {
                "type": "enum",
                "symbols": [
                  "ERROR",
                  "WARNING",
                  "INFO",
                  "DEBUG"
                ],
                "name": "verbosity"
              }
            ],
            "inputBinding": {
              "prefix": "VERBOSITY=",
              "separate": false,
              "shellQuote": false,
              "position": 10
            },
            "label": "Verbosity",
            "doc": "Control verbosity of logging. Default value: INFO. This option can be set to 'null' to clear the default value. Possible values: {ERROR, WARNING, INFO, DEBUG}."
          },
          {
            "sbg:altPrefix": "O",
            "id": "output_prefix",
            "type": "string?",
            "label": "Output metrics file prefix",
            "doc": "Output metrics file prefix."
          },
          {
            "sbg:category": "Options",
            "sbg:toolDefaultValue": "100000",
            "id": "locus_accumulation_cap",
            "type": "int?",
            "inputBinding": {
              "prefix": "LOCUS_ACCUMULATION_CAP=",
              "separate": false,
              "shellQuote": false,
              "position": 10
            },
            "label": "Locus accumulation cap",
            "doc": "At positions with coverage exceeding this value, completely ignore reads that accumulate beyond this value (so that they will not be considered for PCT_EXC_CAPPED).  Used to keep memory consumption in check, but could create bias if set too low."
          },
          {
            "sbg:category": "Options",
            "sbg:toolDefaultValue": "10000",
            "id": "sample_size",
            "type": "int?",
            "inputBinding": {
              "prefix": "SAMPLE_SIZE=",
              "separate": false,
              "shellQuote": false,
              "position": 12
            },
            "label": "Sample size for theoretical het sensitivity sampling",
            "doc": "Sample Size used for theoretical het sensitivity sampling. Default is 10000."
          },
          {
            "sbg:category": "Options",
            "id": "theoretical_sensitivity_output",
            "type": "string?",
            "inputBinding": {
              "prefix": "THEORETICAL_SENSITIVITY_OUTPUT=",
              "separate": false,
              "shellQuote": false,
              "position": 13,
              "valueFrom": "${\n    if (self == 0) {\n        self = null;\n        inputs.theoretical_sensitivity_output = null\n    };\n\n\n    if (inputs.theoretical_sensitivity_output) {\n        return inputs.theoretical_sensitivity_output.concat('.ths.txt')\n    } else {\n        filename = [].concat(inputs.in_alignments)[0].nameroot\n        return filename.concat('.ths.txt')\n    }\n}"
            },
            "label": "Output file name prefix for theoretical sensitivity",
            "doc": "Outpu file namet prefix for theoretical sensitivity metrics."
          },
          {
            "sbg:category": "Options",
            "id": "allele_fraction",
            "type": [
              "null",
              {
                "type": "array",
                "items": "float",
                "inputBinding": {
                  "separate": false,
                  "prefix": "ALLELE_FRACTION="
                }
              }
            ],
            "inputBinding": {
              "prefix": "",
              "separate": false,
              "shellQuote": false,
              "position": 14
            },
            "label": "Allele fraction for theoretical sensitivity",
            "doc": "Allele fraction for which to calculate theoretical sensitivity.  Default value: [0.001,\n 0.005, 0.01, 0.02, 0.05, 0.1, 0.2, 0.3, 0.5]."
          },
          {
            "sbg:category": "Options",
            "id": "use_fast_algorithm",
            "type": [
              "null",
              {
                "type": "enum",
                "symbols": [
                  "true",
                  "false"
                ],
                "name": "use_fast_algorithm"
              }
            ],
            "inputBinding": {
              "prefix": "USE_FAST_ALGORITHM=",
              "separate": false,
              "shellQuote": false,
              "position": 15
            },
            "label": "Use fast algorithm",
            "doc": "Use fast algorithm."
          },
          {
            "sbg:category": "Options",
            "sbg:toolDefaultValue": "150",
            "id": "read_length",
            "type": "int?",
            "inputBinding": {
              "prefix": "READ_LENGTH=",
              "separate": false,
              "shellQuote": false,
              "position": 16
            },
            "label": "Average read length",
            "doc": "Average read length in the file. Default is 150."
          },
          {
            "sbg:category": "Platform Options",
            "sbg:toolDefaultValue": "128",
            "id": "mem_overhead_per_job",
            "type": "int?",
            "label": "Memory overhead per job [MB]",
            "doc": "Memory overhead per job [MB]."
          }
        ],
        "outputs": [
          {
            "id": "output_chart",
            "doc": "Output chart.",
            "label": "Output chart",
            "type": "File?",
            "outputBinding": {
              "glob": "*.pdf",
              "outputEval": "${\n    return inheritMetadata(self, inputs.in_alignments)\n\n}"
            },
            "sbg:fileTypes": "PDF"
          },
          {
            "id": "wgs_metrics",
            "doc": "Output metrics file.",
            "label": "WGS metrics",
            "type": "File?",
            "outputBinding": {
              "glob": "*.wgs_metrics.txt",
              "outputEval": "$(inheritMetadata(self, inputs.in_alignments))"
            },
            "sbg:fileTypes": "TXT"
          },
          {
            "id": "theoretical_sensitivity_out_file",
            "doc": "Theoretical sensitivity output file.",
            "label": "Theoretical sensitivity output file",
            "type": "File?",
            "outputBinding": {
              "glob": "*.ths.txt",
              "outputEval": "$(inheritMetadata(self, inputs.in_alignments))"
            },
            "sbg:fileTypes": "TXT"
          }
        ],
        "doc": "**Picard CollectWgsMetricsWithNonZeroCoverage** evaluates the coverage and performance of whole genome sequencing experiments [1].\n\n*A list of **all inputs and parameters** with corresponding descriptions can be found at the end of the page.*\n\n### Common Use Cases\n\n**Picard CollectWgsMetricsWithNonZeroCoverage** can be used for quality control of WGS data.\n\n### Changes Introduced by Seven Bridges\n\nNo significant changes were introduced. \n\n### Common Issues and Important Notes\n\n* Input  **Input SAM or BAM file** is required and the file should be coordinate sorted. \n* Input **Reference** is required.\n\n### Performance Benchmarking\n\nPerformance of the tool depends on the size of the input alignments file. Analysing 30x (40 GB) and 50x (72.3 GB) coverage WGS BAM files on the default on-demand AWS instances took 2 h 9 min ($0.86) and 3 h 32 min ($1.41), respectively.\n\n*Cost can be significantly reduced by **spot instance** usage. Visit the [Knowledge Center](https://docs.sevenbridges.com/docs/about-spot-instances) for more details.*  \n\n### References\n\n[1] [Picard documentation](http://broadinstitute.github.io/picard/command-line-overview.html#CollectWgsMetricsWithNonZeroCoverage)",
        "label": "Picard CollectWgsMetricsWithNonZeroCoverage CWL1.0",
        "arguments": [
          {
            "prefix": "",
            "shellQuote": false,
            "position": 0,
            "valueFrom": "${\n    if (inputs.mem_per_job) {\n        return '-Xmx'.concat(inputs.mem_per_job, 'M')\n    }\n    return '-Xmx2048M'\n}"
          },
          {
            "shellQuote": false,
            "position": 1,
            "valueFrom": "-jar"
          },
          {
            "prefix": "",
            "shellQuote": false,
            "position": 2,
            "valueFrom": "/opt/picard-2.21.6/picard.jar"
          },
          {
            "shellQuote": false,
            "position": 3,
            "valueFrom": "CollectWgsMetricsWithNonZeroCoverage"
          },
          {
            "prefix": "OUTPUT=",
            "separate": false,
            "shellQuote": false,
            "position": 4,
            "valueFrom": "${\n    if (inputs.output_prefix)\n    {\n        return inputs.output_prefix.concat(\".wgs_metrics.txt\")\n    }\n    else if (inputs.in_alignments) {\n        filename = [].concat(inputs.in_alignments)[0].nameroot\n\n        return filename.concat(\".wgs_metrics.txt\")\n    }\n}"
          }
        ],
        "requirements": [
          {
            "class": "ShellCommandRequirement"
          },
          {
            "class": "ResourceRequirement",
            "ramMin": "${\n    if ((inputs.mem_per_job) && (inputs.mem_overhead_per_job))\n    {\n        return inputs.mem_per_job + inputs.mem_overhead_per_job\n    }\n    else if (inputs.mem_per_job)\n    {\n        return inputs.mem_per_job + 128\n    }\n    else if (inputs.mem_overhead_per_job)\n    {\n        return 2048 + inputs.mem_overhead_per_job\n    }\n    else\n    {\n    return 2048\n    }\n}",
            "coresMin": 1
          },
          {
            "class": "DockerRequirement",
            "dockerImageId": "eab0e70b6629",
            "dockerPull": "images.sbgenomics.com/jovana_vranic/picard-2-21-6:1"
          },
          {
            "class": "InitialWorkDirRequirement",
            "listing": []
          },
          {
            "class": "InlineJavascriptRequirement",
            "expressionLib": [
              "var updateMetadata = function(file, key, value) {\n    file['metadata'][key] = value;\n    return file;\n};\n\n\nvar setMetadata = function(file, metadata) {\n    if (!('metadata' in file)) {\n        file['metadata'] = {}\n    }\n    for (var key in metadata) {\n        file['metadata'][key] = metadata[key];\n    }\n    return file\n};\n\nvar inheritMetadata = function(o1, o2) {\n    var commonMetadata = {};\n    if (!Array.isArray(o2)) {\n        o2 = [o2]\n    }\n    for (var i = 0; i < o2.length; i++) {\n        var example = o2[i]['metadata'];\n        for (var key in example) {\n            if (i == 0)\n                commonMetadata[key] = example[key];\n            else {\n                if (!(commonMetadata[key] == example[key])) {\n                    delete commonMetadata[key]\n                }\n            }\n        }\n    }\n    if (!Array.isArray(o1)) {\n        o1 = setMetadata(o1, commonMetadata)\n    } else {\n        for (var i = 0; i < o1.length; i++) {\n            o1[i] = setMetadata(o1[i], commonMetadata)\n        }\n    }\n    return o1;\n};\n\nvar toArray = function(file) {\n    return [].concat(file);\n};\n\nvar groupBy = function(files, key) {\n    var groupedFiles = [];\n    var tempDict = {};\n    for (var i = 0; i < files.length; i++) {\n        var value = files[i]['metadata'][key];\n        if (value in tempDict)\n            tempDict[value].push(files[i]);\n        else tempDict[value] = [files[i]];\n    }\n    for (var key in tempDict) {\n        groupedFiles.push(tempDict[key]);\n    }\n    return groupedFiles;\n};\n\nvar orderBy = function(files, key, order) {\n    var compareFunction = function(a, b) {\n        if (a['metadata'][key].constructor === Number) {\n            return a['metadata'][key] - b['metadata'][key];\n        } else {\n            var nameA = a['metadata'][key].toUpperCase();\n            var nameB = b['metadata'][key].toUpperCase();\n            if (nameA < nameB) {\n                return -1;\n            }\n            if (nameA > nameB) {\n                return 1;\n            }\n            return 0;\n        }\n    };\n\n    files = files.sort(compareFunction);\n    if (order == undefined || order == \"asc\")\n        return files;\n    else\n        return files.reverse();\n};",
              "\nvar setMetadata = function(file, metadata) {\n    if (!('metadata' in file)) {\n        file['metadata'] = {}\n    }\n    for (var key in metadata) {\n        file['metadata'][key] = metadata[key];\n    }\n    return file\n};\nvar inheritMetadata = function(o1, o2) {\n    var commonMetadata = {};\n    if (!o2) {\n        return o1;\n    };\n    if (!Array.isArray(o2)) {\n        o2 = [o2]\n    }\n    for (var i = 0; i < o2.length; i++) {\n        var example = o2[i]['metadata'];\n        for (var key in example) {\n            if (i == 0)\n                commonMetadata[key] = example[key];\n            else {\n                if (!(commonMetadata[key] == example[key])) {\n                    delete commonMetadata[key]\n                }\n            }\n        }\n        for (var key in commonMetadata) {\n            if (!(key in example)) {\n                delete commonMetadata[key]\n            }\n        }\n    }\n    if (!Array.isArray(o1)) {\n        o1 = setMetadata(o1, commonMetadata)\n    } else {\n        for (var i = 0; i < o1.length; i++) {\n            o1[i] = setMetadata(o1[i], commonMetadata)\n        }\n    }\n    return o1;\n};"
            ]
          }
        ],
        "sbg:categories": [
          "SAM/BAM-Processing",
          "Quality-Control",
          "CWL1.0"
        ],
        "sbg:cmdPreview": "java -Xmx2048M -jar /opt/picard.jar CollectWgsMetricsWithNonZeroCoverage INPUT=/root/folder/example.bam OUTPUT=example.wgs_metrics.txt REFERENCE_SEQUENCE=/second/folder/human.fasta",
        "sbg:image_url": null,
        "sbg:license": "MIT License",
        "sbg:links": [
          {
            "id": "http://broadinstitute.github.io/picard/",
            "label": "Homepage"
          },
          {
            "id": "https://github.com/broadinstitute/picard/releases/tag/1.140",
            "label": "Source Code"
          },
          {
            "id": "http://broadinstitute.github.io/picard/",
            "label": "Wiki"
          },
          {
            "id": "https://github.com/broadinstitute/picard/zipball/master",
            "label": "Download"
          },
          {
            "id": "http://broadinstitute.github.io/picard/",
            "label": "Publication"
          }
        ],
        "sbg:toolAuthor": "Broad Institute",
        "sbg:toolkit": "Picard",
        "sbg:toolkitVersion": "2.21.6",
        "sbg:projectName": "BUILD: Mitochondria Pipeline",
        "sbg:revisionsInfo": [
          {
            "sbg:revision": 0,
            "sbg:modifiedBy": "dave",
            "sbg:modifiedOn": 1622863845,
            "sbg:revisionNotes": "Copy of admin/sbg-public-data/picard-collectwgsmetricswithnonzerocoverage-2-21-6-cwl1-0/3"
          },
          {
            "sbg:revision": 1,
            "sbg:modifiedBy": "dave",
            "sbg:modifiedOn": 1622864324,
            "sbg:revisionNotes": ""
          }
        ],
        "sbg:expand_workflow": false,
        "sbg:appVersion": [
          "v1.2"
        ],
        "sbg:id": "dave/build-mitochondria-pipeline/picard-collectwgsmetricswithnonzerocoverage-2-21-6-cwl1-0/1",
        "sbg:revision": 1,
        "sbg:revisionNotes": "",
        "sbg:modifiedOn": 1622864324,
        "sbg:modifiedBy": "dave",
        "sbg:createdOn": 1622863845,
        "sbg:createdBy": "dave",
        "sbg:project": "dave/build-mitochondria-pipeline",
        "sbg:sbgMaintained": false,
        "sbg:validationErrors": [],
        "sbg:contributors": [
          "dave"
        ],
        "sbg:latestRevision": 1,
        "sbg:publisher": "sbg",
        "sbg:content_hash": "aa7fb123a0b435d3e287ed99cc531fb694bb191bb5ce90c4755504b13cbda1bb1"
      },
      "label": "shifted wgs metrics",
      "sbg:x": 1302.830322265625,
      "sbg:y": 144.15130615234375
    }
  ],
  "requirements": [
    {
      "class": "InlineJavascriptRequirement"
    },
    {
      "class": "StepInputExpressionRequirement"
    }
  ],
  "sbg:projectName": "TEST: Mito Pipeline",
  "sbg:revisionsInfo": [
    {
      "sbg:revision": 0,
      "sbg:modifiedBy": "dave",
      "sbg:modifiedOn": 1622053243,
      "sbg:revisionNotes": "Copy of dave/build-mitochondria-pipeline/mitochondria-pipeline/1"
    },
    {
      "sbg:revision": 1,
      "sbg:modifiedBy": "dave",
      "sbg:modifiedOn": 1622053878,
      "sbg:revisionNotes": "Copy of dave/build-mitochondria-pipeline/mitochondria-pipeline/2"
    },
    {
      "sbg:revision": 2,
      "sbg:modifiedBy": "dave",
      "sbg:modifiedOn": 1622160013,
      "sbg:revisionNotes": "Copy of dave/build-mitochondria-pipeline/mitochondria-pipeline/5"
    },
    {
      "sbg:revision": 3,
      "sbg:modifiedBy": "dave",
      "sbg:modifiedOn": 1622160527,
      "sbg:revisionNotes": "Copy of dave/build-mitochondria-pipeline/mitochondria-pipeline/6"
    },
    {
      "sbg:revision": 4,
      "sbg:modifiedBy": "dave",
      "sbg:modifiedOn": 1622161731,
      "sbg:revisionNotes": "Copy of dave/build-mitochondria-pipeline/mitochondria-pipeline/9"
    },
    {
      "sbg:revision": 5,
      "sbg:modifiedBy": "dave",
      "sbg:modifiedOn": 1622647034,
      "sbg:revisionNotes": "Copy of dave/build-mitochondria-pipeline/mitochondria-pipeline/10"
    },
    {
      "sbg:revision": 6,
      "sbg:modifiedBy": "dave",
      "sbg:modifiedOn": 1622647469,
      "sbg:revisionNotes": "Copy of dave/build-mitochondria-pipeline/mitochondria-pipeline/12"
    },
    {
      "sbg:revision": 7,
      "sbg:modifiedBy": "dave",
      "sbg:modifiedOn": 1622768166,
      "sbg:revisionNotes": "Copy of dave/build-mitochondria-pipeline/mitochondria-pipeline/14"
    },
    {
      "sbg:revision": 8,
      "sbg:modifiedBy": "dave",
      "sbg:modifiedOn": 1622834229,
      "sbg:revisionNotes": "Copy of dave/build-mitochondria-pipeline/mitochondria-pipeline/15"
    },
    {
      "sbg:revision": 9,
      "sbg:modifiedBy": "dave",
      "sbg:modifiedOn": 1622834642,
      "sbg:revisionNotes": "Copy of dave/build-mitochondria-pipeline/mitochondria-pipeline/16"
    },
    {
      "sbg:revision": 10,
      "sbg:modifiedBy": "dave",
      "sbg:modifiedOn": 1622835008,
      "sbg:revisionNotes": "Copy of dave/build-mitochondria-pipeline/mitochondria-pipeline/17"
    },
    {
      "sbg:revision": 11,
      "sbg:modifiedBy": "dave",
      "sbg:modifiedOn": 1622836521,
      "sbg:revisionNotes": "Copy of dave/build-mitochondria-pipeline/mitochondria-pipeline/18"
    },
    {
      "sbg:revision": 12,
      "sbg:modifiedBy": "dave",
      "sbg:modifiedOn": 1622858131,
      "sbg:revisionNotes": "Copy of dave/build-mitochondria-pipeline/mitochondria-pipeline/20"
    },
    {
      "sbg:revision": 13,
      "sbg:modifiedBy": "dave",
      "sbg:modifiedOn": 1622861082,
      "sbg:revisionNotes": "Copy of dave/build-mitochondria-pipeline/mitochondria-pipeline/22"
    },
    {
      "sbg:revision": 14,
      "sbg:modifiedBy": "dave",
      "sbg:modifiedOn": 1622861655,
      "sbg:revisionNotes": "Copy of dave/build-mitochondria-pipeline/mitochondria-pipeline/23"
    },
    {
      "sbg:revision": 15,
      "sbg:modifiedBy": "dave",
      "sbg:modifiedOn": 1622862081,
      "sbg:revisionNotes": "Copy of dave/build-mitochondria-pipeline/mitochondria-pipeline/25"
    },
    {
      "sbg:revision": 16,
      "sbg:modifiedBy": "dave",
      "sbg:modifiedOn": 1622862921,
      "sbg:revisionNotes": "Copy of dave/build-mitochondria-pipeline/mitochondria-pipeline/26"
    },
    {
      "sbg:revision": 17,
      "sbg:modifiedBy": "dave",
      "sbg:modifiedOn": 1622864408,
      "sbg:revisionNotes": "Copy of dave/build-mitochondria-pipeline/mitochondria-pipeline/29"
    },
    {
      "sbg:revision": 18,
      "sbg:modifiedBy": "dave",
      "sbg:modifiedOn": 1622864868,
      "sbg:revisionNotes": "Copy of dave/build-mitochondria-pipeline/mitochondria-pipeline/30"
    }
  ],
  "sbg:image_url": null,
  "sbg:appVersion": [
    "v1.2"
  ],
  "id": "https://api.sb.biodatacatalyst.nhlbi.nih.gov/v2/apps/dave/test-mito-pipeline/mitochondria-pipeline/18/raw/",
  "sbg:id": "dave/test-mito-pipeline/mitochondria-pipeline/18",
  "sbg:revision": 18,
  "sbg:revisionNotes": "Copy of dave/build-mitochondria-pipeline/mitochondria-pipeline/30",
  "sbg:modifiedOn": 1622864868,
  "sbg:modifiedBy": "dave",
  "sbg:createdOn": 1622053243,
  "sbg:createdBy": "dave",
  "sbg:project": "dave/test-mito-pipeline",
  "sbg:sbgMaintained": false,
  "sbg:validationErrors": [],
  "sbg:contributors": [
    "dave"
  ],
  "sbg:latestRevision": 18,
  "sbg:publisher": "sbg",
  "sbg:content_hash": "a59283b2b332787ec7822c99cba46c8727dfba1be48a78aa60528fa280343c955",
  "sbg:copyOf": "dave/build-mitochondria-pipeline/mitochondria-pipeline/30"
}
